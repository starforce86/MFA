// Code generated by Prisma (prisma@1.29.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  activationCode: (where?: ActivationCodeWhereInput) => Promise<boolean>;
  category: (where?: CategoryWhereInput) => Promise<boolean>;
  post: (where?: PostWhereInput) => Promise<boolean>;
  restoreCode: (where?: RestoreCodeWhereInput) => Promise<boolean>;
  tag: (where?: TagWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  video: (where?: VideoWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  activationCode: (
    where: ActivationCodeWhereUniqueInput
  ) => ActivationCodePromise;
  activationCodes: (
    args?: {
      where?: ActivationCodeWhereInput;
      orderBy?: ActivationCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ActivationCode>;
  activationCodesConnection: (
    args?: {
      where?: ActivationCodeWhereInput;
      orderBy?: ActivationCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ActivationCodeConnectionPromise;
  category: (where: CategoryWhereUniqueInput) => CategoryPromise;
  categories: (
    args?: {
      where?: CategoryWhereInput;
      orderBy?: CategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Category>;
  categoriesConnection: (
    args?: {
      where?: CategoryWhereInput;
      orderBy?: CategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CategoryConnectionPromise;
  post: (where: PostWhereUniqueInput) => PostPromise;
  posts: (
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Post>;
  postsConnection: (
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PostConnectionPromise;
  restoreCode: (where: RestoreCodeWhereUniqueInput) => RestoreCodePromise;
  restoreCodes: (
    args?: {
      where?: RestoreCodeWhereInput;
      orderBy?: RestoreCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<RestoreCode>;
  restoreCodesConnection: (
    args?: {
      where?: RestoreCodeWhereInput;
      orderBy?: RestoreCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RestoreCodeConnectionPromise;
  tag: (where: TagWhereUniqueInput) => TagPromise;
  tags: (
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Tag>;
  tagsConnection: (
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TagConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  video: (where: VideoWhereUniqueInput) => VideoPromise;
  videos: (
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Video>;
  videosConnection: (
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VideoConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createActivationCode: (
    data: ActivationCodeCreateInput
  ) => ActivationCodePromise;
  updateActivationCode: (
    args: {
      data: ActivationCodeUpdateInput;
      where: ActivationCodeWhereUniqueInput;
    }
  ) => ActivationCodePromise;
  updateManyActivationCodes: (
    args: {
      data: ActivationCodeUpdateManyMutationInput;
      where?: ActivationCodeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertActivationCode: (
    args: {
      where: ActivationCodeWhereUniqueInput;
      create: ActivationCodeCreateInput;
      update: ActivationCodeUpdateInput;
    }
  ) => ActivationCodePromise;
  deleteActivationCode: (
    where: ActivationCodeWhereUniqueInput
  ) => ActivationCodePromise;
  deleteManyActivationCodes: (
    where?: ActivationCodeWhereInput
  ) => BatchPayloadPromise;
  createCategory: (data: CategoryCreateInput) => CategoryPromise;
  updateCategory: (
    args: { data: CategoryUpdateInput; where: CategoryWhereUniqueInput }
  ) => CategoryPromise;
  updateManyCategories: (
    args: { data: CategoryUpdateManyMutationInput; where?: CategoryWhereInput }
  ) => BatchPayloadPromise;
  upsertCategory: (
    args: {
      where: CategoryWhereUniqueInput;
      create: CategoryCreateInput;
      update: CategoryUpdateInput;
    }
  ) => CategoryPromise;
  deleteCategory: (where: CategoryWhereUniqueInput) => CategoryPromise;
  deleteManyCategories: (where?: CategoryWhereInput) => BatchPayloadPromise;
  createPost: (data: PostCreateInput) => PostPromise;
  updatePost: (
    args: { data: PostUpdateInput; where: PostWhereUniqueInput }
  ) => PostPromise;
  updateManyPosts: (
    args: { data: PostUpdateManyMutationInput; where?: PostWhereInput }
  ) => BatchPayloadPromise;
  upsertPost: (
    args: {
      where: PostWhereUniqueInput;
      create: PostCreateInput;
      update: PostUpdateInput;
    }
  ) => PostPromise;
  deletePost: (where: PostWhereUniqueInput) => PostPromise;
  deleteManyPosts: (where?: PostWhereInput) => BatchPayloadPromise;
  createRestoreCode: (data: RestoreCodeCreateInput) => RestoreCodePromise;
  updateRestoreCode: (
    args: { data: RestoreCodeUpdateInput; where: RestoreCodeWhereUniqueInput }
  ) => RestoreCodePromise;
  updateManyRestoreCodes: (
    args: {
      data: RestoreCodeUpdateManyMutationInput;
      where?: RestoreCodeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertRestoreCode: (
    args: {
      where: RestoreCodeWhereUniqueInput;
      create: RestoreCodeCreateInput;
      update: RestoreCodeUpdateInput;
    }
  ) => RestoreCodePromise;
  deleteRestoreCode: (where: RestoreCodeWhereUniqueInput) => RestoreCodePromise;
  deleteManyRestoreCodes: (
    where?: RestoreCodeWhereInput
  ) => BatchPayloadPromise;
  createTag: (data: TagCreateInput) => TagPromise;
  updateTag: (
    args: { data: TagUpdateInput; where: TagWhereUniqueInput }
  ) => TagPromise;
  updateManyTags: (
    args: { data: TagUpdateManyMutationInput; where?: TagWhereInput }
  ) => BatchPayloadPromise;
  upsertTag: (
    args: {
      where: TagWhereUniqueInput;
      create: TagCreateInput;
      update: TagUpdateInput;
    }
  ) => TagPromise;
  deleteTag: (where: TagWhereUniqueInput) => TagPromise;
  deleteManyTags: (where?: TagWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createVideo: (data: VideoCreateInput) => VideoPromise;
  updateVideo: (
    args: { data: VideoUpdateInput; where: VideoWhereUniqueInput }
  ) => VideoPromise;
  updateManyVideos: (
    args: { data: VideoUpdateManyMutationInput; where?: VideoWhereInput }
  ) => BatchPayloadPromise;
  upsertVideo: (
    args: {
      where: VideoWhereUniqueInput;
      create: VideoCreateInput;
      update: VideoUpdateInput;
    }
  ) => VideoPromise;
  deleteVideo: (where: VideoWhereUniqueInput) => VideoPromise;
  deleteManyVideos: (where?: VideoWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  activationCode: (
    where?: ActivationCodeSubscriptionWhereInput
  ) => ActivationCodeSubscriptionPayloadSubscription;
  category: (
    where?: CategorySubscriptionWhereInput
  ) => CategorySubscriptionPayloadSubscription;
  post: (
    where?: PostSubscriptionWhereInput
  ) => PostSubscriptionPayloadSubscription;
  restoreCode: (
    where?: RestoreCodeSubscriptionWhereInput
  ) => RestoreCodeSubscriptionPayloadSubscription;
  tag: (
    where?: TagSubscriptionWhereInput
  ) => TagSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  video: (
    where?: VideoSubscriptionWhereInput
  ) => VideoSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type UserRole = "USER_VIEWER" | "USER_PUBLISHER" | "MODERATOR" | "ADMIN";

export type VideoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "publish_date_ASC"
  | "publish_date_DESC"
  | "file_url_ASC"
  | "file_url_DESC"
  | "video_duration_ASC"
  | "video_duration_DESC"
  | "preview_url_ASC"
  | "preview_url_DESC"
  | "preview_video_url_ASC"
  | "preview_video_url_DESC"
  | "preview_video_duration_ASC"
  | "preview_video_duration_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "firstname_ASC"
  | "firstname_DESC"
  | "lastname_ASC"
  | "lastname_DESC"
  | "username_ASC"
  | "username_DESC"
  | "email_ASC"
  | "email_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "role_ASC"
  | "role_DESC"
  | "password_hash_ASC"
  | "password_hash_DESC"
  | "password_salt_ASC"
  | "password_salt_DESC"
  | "avatar_ASC"
  | "avatar_DESC"
  | "background_image_ASC"
  | "background_image_DESC"
  | "about_text_ASC"
  | "about_text_DESC"
  | "billing_subscription_active_ASC"
  | "billing_subscription_active_DESC"
  | "stripe_customer_id_ASC"
  | "stripe_customer_id_DESC"
  | "stripe_subsciption_json_ASC"
  | "stripe_subsciption_json_DESC"
  | "last_login_date_ASC"
  | "last_login_date_DESC";

export type CategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC";

export type ActivationCodeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "valid_until_ASC"
  | "valid_until_DESC"
  | "code_ASC"
  | "code_DESC";

export type TagOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "text_ASC"
  | "text_DESC";

export type PostOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "mainImageUrl_ASC"
  | "mainImageUrl_DESC"
  | "text_ASC"
  | "text_DESC";

export type RestoreCodeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "valid_until_ASC"
  | "valid_until_DESC"
  | "code_ASC"
  | "code_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface CategoryUpdateManyWithoutVideosInput {
  create?:
    | CategoryCreateWithoutVideosInput[]
    | CategoryCreateWithoutVideosInput;
  delete?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
  connect?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
  set?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
  disconnect?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
  update?:
    | CategoryUpdateWithWhereUniqueWithoutVideosInput[]
    | CategoryUpdateWithWhereUniqueWithoutVideosInput;
  upsert?:
    | CategoryUpsertWithWhereUniqueWithoutVideosInput[]
    | CategoryUpsertWithWhereUniqueWithoutVideosInput;
  deleteMany?: CategoryScalarWhereInput[] | CategoryScalarWhereInput;
  updateMany?:
    | CategoryUpdateManyWithWhereNestedInput[]
    | CategoryUpdateManyWithWhereNestedInput;
}

export type ActivationCodeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface UserCreateManyWithoutLiked_videosInput {
  create?:
    | UserCreateWithoutLiked_videosInput[]
    | UserCreateWithoutLiked_videosInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface VideoUpsertWithWhereUniqueWithoutLike_usersInput {
  where: VideoWhereUniqueInput;
  update: VideoUpdateWithoutLike_usersDataInput;
  create: VideoCreateWithoutLike_usersInput;
}

export interface UserCreateWithoutLiked_videosInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email: String;
  phone?: String;
  role?: UserRole;
  password_hash: String;
  password_salt: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  my_videos?: VideoCreateManyWithoutAuthorInput;
  watched_videos?: VideoCreateManyWithoutWatched_usersInput;
  my_subscription_users?: UserCreateManyWithoutSubscribed_usersInput;
  subscribed_users?: UserCreateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  last_login_date?: DateTimeInput;
}

export interface CategoryUpdateManyWithWhereNestedInput {
  where: CategoryScalarWhereInput;
  data: CategoryUpdateManyDataInput;
}

export interface VideoCreateManyWithoutWatched_usersInput {
  create?:
    | VideoCreateWithoutWatched_usersInput[]
    | VideoCreateWithoutWatched_usersInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
}

export interface VideoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VideoWhereInput;
  AND?: VideoSubscriptionWhereInput[] | VideoSubscriptionWhereInput;
  OR?: VideoSubscriptionWhereInput[] | VideoSubscriptionWhereInput;
  NOT?: VideoSubscriptionWhereInput[] | VideoSubscriptionWhereInput;
}

export interface VideoCreateWithoutWatched_usersInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  author: UserCreateOneWithoutMy_videosInput;
  categories?: CategoryCreateManyWithoutVideosInput;
  like_users?: UserCreateManyWithoutLiked_videosInput;
  tags?: TagCreateManyWithoutVideosInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  firstname?: String;
  firstname_not?: String;
  firstname_in?: String[] | String;
  firstname_not_in?: String[] | String;
  firstname_lt?: String;
  firstname_lte?: String;
  firstname_gt?: String;
  firstname_gte?: String;
  firstname_contains?: String;
  firstname_not_contains?: String;
  firstname_starts_with?: String;
  firstname_not_starts_with?: String;
  firstname_ends_with?: String;
  firstname_not_ends_with?: String;
  lastname?: String;
  lastname_not?: String;
  lastname_in?: String[] | String;
  lastname_not_in?: String[] | String;
  lastname_lt?: String;
  lastname_lte?: String;
  lastname_gt?: String;
  lastname_gte?: String;
  lastname_contains?: String;
  lastname_not_contains?: String;
  lastname_starts_with?: String;
  lastname_not_starts_with?: String;
  lastname_ends_with?: String;
  lastname_not_ends_with?: String;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  role?: UserRole;
  role_not?: UserRole;
  role_in?: UserRole[] | UserRole;
  role_not_in?: UserRole[] | UserRole;
  password_hash?: String;
  password_hash_not?: String;
  password_hash_in?: String[] | String;
  password_hash_not_in?: String[] | String;
  password_hash_lt?: String;
  password_hash_lte?: String;
  password_hash_gt?: String;
  password_hash_gte?: String;
  password_hash_contains?: String;
  password_hash_not_contains?: String;
  password_hash_starts_with?: String;
  password_hash_not_starts_with?: String;
  password_hash_ends_with?: String;
  password_hash_not_ends_with?: String;
  password_salt?: String;
  password_salt_not?: String;
  password_salt_in?: String[] | String;
  password_salt_not_in?: String[] | String;
  password_salt_lt?: String;
  password_salt_lte?: String;
  password_salt_gt?: String;
  password_salt_gte?: String;
  password_salt_contains?: String;
  password_salt_not_contains?: String;
  password_salt_starts_with?: String;
  password_salt_not_starts_with?: String;
  password_salt_ends_with?: String;
  password_salt_not_ends_with?: String;
  avatar?: String;
  avatar_not?: String;
  avatar_in?: String[] | String;
  avatar_not_in?: String[] | String;
  avatar_lt?: String;
  avatar_lte?: String;
  avatar_gt?: String;
  avatar_gte?: String;
  avatar_contains?: String;
  avatar_not_contains?: String;
  avatar_starts_with?: String;
  avatar_not_starts_with?: String;
  avatar_ends_with?: String;
  avatar_not_ends_with?: String;
  background_image?: String;
  background_image_not?: String;
  background_image_in?: String[] | String;
  background_image_not_in?: String[] | String;
  background_image_lt?: String;
  background_image_lte?: String;
  background_image_gt?: String;
  background_image_gte?: String;
  background_image_contains?: String;
  background_image_not_contains?: String;
  background_image_starts_with?: String;
  background_image_not_starts_with?: String;
  background_image_ends_with?: String;
  background_image_not_ends_with?: String;
  about_text?: String;
  about_text_not?: String;
  about_text_in?: String[] | String;
  about_text_not_in?: String[] | String;
  about_text_lt?: String;
  about_text_lte?: String;
  about_text_gt?: String;
  about_text_gte?: String;
  about_text_contains?: String;
  about_text_not_contains?: String;
  about_text_starts_with?: String;
  about_text_not_starts_with?: String;
  about_text_ends_with?: String;
  about_text_not_ends_with?: String;
  my_videos_every?: VideoWhereInput;
  my_videos_some?: VideoWhereInput;
  my_videos_none?: VideoWhereInput;
  liked_videos_every?: VideoWhereInput;
  liked_videos_some?: VideoWhereInput;
  liked_videos_none?: VideoWhereInput;
  watched_videos_every?: VideoWhereInput;
  watched_videos_some?: VideoWhereInput;
  watched_videos_none?: VideoWhereInput;
  my_subscription_users_every?: UserWhereInput;
  my_subscription_users_some?: UserWhereInput;
  my_subscription_users_none?: UserWhereInput;
  subscribed_users_every?: UserWhereInput;
  subscribed_users_some?: UserWhereInput;
  subscribed_users_none?: UserWhereInput;
  billing_subscription_active?: Boolean;
  billing_subscription_active_not?: Boolean;
  stripe_customer_id?: String;
  stripe_customer_id_not?: String;
  stripe_customer_id_in?: String[] | String;
  stripe_customer_id_not_in?: String[] | String;
  stripe_customer_id_lt?: String;
  stripe_customer_id_lte?: String;
  stripe_customer_id_gt?: String;
  stripe_customer_id_gte?: String;
  stripe_customer_id_contains?: String;
  stripe_customer_id_not_contains?: String;
  stripe_customer_id_starts_with?: String;
  stripe_customer_id_not_starts_with?: String;
  stripe_customer_id_ends_with?: String;
  stripe_customer_id_not_ends_with?: String;
  last_login_date?: DateTimeInput;
  last_login_date_not?: DateTimeInput;
  last_login_date_in?: DateTimeInput[] | DateTimeInput;
  last_login_date_not_in?: DateTimeInput[] | DateTimeInput;
  last_login_date_lt?: DateTimeInput;
  last_login_date_lte?: DateTimeInput;
  last_login_date_gt?: DateTimeInput;
  last_login_date_gte?: DateTimeInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface TagCreateManyWithoutVideosInput {
  create?: TagCreateWithoutVideosInput[] | TagCreateWithoutVideosInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
}

export interface CategoryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  videos_every?: VideoWhereInput;
  videos_some?: VideoWhereInput;
  videos_none?: VideoWhereInput;
  AND?: CategoryWhereInput[] | CategoryWhereInput;
  OR?: CategoryWhereInput[] | CategoryWhereInput;
  NOT?: CategoryWhereInput[] | CategoryWhereInput;
}

export interface TagCreateWithoutVideosInput {
  text: String;
}

export interface TagSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TagWhereInput;
  AND?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  OR?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  NOT?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
}

export interface UserCreateManyWithoutSubscribed_usersInput {
  create?:
    | UserCreateWithoutSubscribed_usersInput[]
    | UserCreateWithoutSubscribed_usersInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface PostSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PostWhereInput;
  AND?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
  OR?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
  NOT?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
}

export interface UserCreateWithoutSubscribed_usersInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email: String;
  phone?: String;
  role?: UserRole;
  password_hash: String;
  password_salt: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  my_videos?: VideoCreateManyWithoutAuthorInput;
  liked_videos?: VideoCreateManyWithoutLike_usersInput;
  watched_videos?: VideoCreateManyWithoutWatched_usersInput;
  my_subscription_users?: UserCreateManyWithoutSubscribed_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  last_login_date?: DateTimeInput;
}

export interface ActivationCodeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ActivationCodeWhereInput;
  AND?:
    | ActivationCodeSubscriptionWhereInput[]
    | ActivationCodeSubscriptionWhereInput;
  OR?:
    | ActivationCodeSubscriptionWhereInput[]
    | ActivationCodeSubscriptionWhereInput;
  NOT?:
    | ActivationCodeSubscriptionWhereInput[]
    | ActivationCodeSubscriptionWhereInput;
}

export interface UserCreateManyWithoutMy_subscription_usersInput {
  create?:
    | UserCreateWithoutMy_subscription_usersInput[]
    | UserCreateWithoutMy_subscription_usersInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface ActivationCodeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  valid_until?: DateTimeInput;
  valid_until_not?: DateTimeInput;
  valid_until_in?: DateTimeInput[] | DateTimeInput;
  valid_until_not_in?: DateTimeInput[] | DateTimeInput;
  valid_until_lt?: DateTimeInput;
  valid_until_lte?: DateTimeInput;
  valid_until_gt?: DateTimeInput;
  valid_until_gte?: DateTimeInput;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  AND?: ActivationCodeWhereInput[] | ActivationCodeWhereInput;
  OR?: ActivationCodeWhereInput[] | ActivationCodeWhereInput;
  NOT?: ActivationCodeWhereInput[] | ActivationCodeWhereInput;
}

export interface UserCreateWithoutMy_subscription_usersInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email: String;
  phone?: String;
  role?: UserRole;
  password_hash: String;
  password_salt: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  my_videos?: VideoCreateManyWithoutAuthorInput;
  liked_videos?: VideoCreateManyWithoutLike_usersInput;
  watched_videos?: VideoCreateManyWithoutWatched_usersInput;
  subscribed_users?: UserCreateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  last_login_date?: DateTimeInput;
}

export interface VideoCreateInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  author: UserCreateOneWithoutMy_videosInput;
  categories?: CategoryCreateManyWithoutVideosInput;
  like_users?: UserCreateManyWithoutLiked_videosInput;
  watched_users?: UserCreateManyWithoutWatched_videosInput;
  tags?: TagCreateManyWithoutVideosInput;
}

export interface CategoryUpdateInput {
  title?: String;
  description?: String;
  videos?: VideoUpdateManyWithoutCategoriesInput;
}

export interface UserUpdateInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email?: String;
  phone?: String;
  role?: UserRole;
  password_hash?: String;
  password_salt?: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  my_videos?: VideoUpdateManyWithoutAuthorInput;
  liked_videos?: VideoUpdateManyWithoutLike_usersInput;
  watched_videos?: VideoUpdateManyWithoutWatched_usersInput;
  my_subscription_users?: UserUpdateManyWithoutSubscribed_usersInput;
  subscribed_users?: UserUpdateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  last_login_date?: DateTimeInput;
}

export interface VideoUpdateManyWithoutCategoriesInput {
  create?:
    | VideoCreateWithoutCategoriesInput[]
    | VideoCreateWithoutCategoriesInput;
  delete?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  set?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  disconnect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  update?:
    | VideoUpdateWithWhereUniqueWithoutCategoriesInput[]
    | VideoUpdateWithWhereUniqueWithoutCategoriesInput;
  upsert?:
    | VideoUpsertWithWhereUniqueWithoutCategoriesInput[]
    | VideoUpsertWithWhereUniqueWithoutCategoriesInput;
  deleteMany?: VideoScalarWhereInput[] | VideoScalarWhereInput;
  updateMany?:
    | VideoUpdateManyWithWhereNestedInput[]
    | VideoUpdateManyWithWhereNestedInput;
}

export interface TagUpdateManyMutationInput {
  text?: String;
}

export interface VideoUpdateWithWhereUniqueWithoutCategoriesInput {
  where: VideoWhereUniqueInput;
  data: VideoUpdateWithoutCategoriesDataInput;
}

export interface VideoUpsertWithWhereUniqueWithoutTagsInput {
  where: VideoWhereUniqueInput;
  update: VideoUpdateWithoutTagsDataInput;
  create: VideoCreateWithoutTagsInput;
}

export interface VideoUpdateWithoutCategoriesDataInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  author?: UserUpdateOneRequiredWithoutMy_videosInput;
  like_users?: UserUpdateManyWithoutLiked_videosInput;
  watched_users?: UserUpdateManyWithoutWatched_videosInput;
  tags?: TagUpdateManyWithoutVideosInput;
}

export interface VideoUpdateWithWhereUniqueWithoutTagsInput {
  where: VideoWhereUniqueInput;
  data: VideoUpdateWithoutTagsDataInput;
}

export interface UserUpdateOneRequiredWithoutMy_videosInput {
  create?: UserCreateWithoutMy_videosInput;
  update?: UserUpdateWithoutMy_videosDataInput;
  upsert?: UserUpsertWithoutMy_videosInput;
  connect?: UserWhereUniqueInput;
}

export type RestoreCodeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface UserUpdateWithoutMy_videosDataInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email?: String;
  phone?: String;
  role?: UserRole;
  password_hash?: String;
  password_salt?: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  liked_videos?: VideoUpdateManyWithoutLike_usersInput;
  watched_videos?: VideoUpdateManyWithoutWatched_usersInput;
  my_subscription_users?: UserUpdateManyWithoutSubscribed_usersInput;
  subscribed_users?: UserUpdateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  last_login_date?: DateTimeInput;
}

export interface RestoreCodeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  valid_until?: DateTimeInput;
  valid_until_not?: DateTimeInput;
  valid_until_in?: DateTimeInput[] | DateTimeInput;
  valid_until_not_in?: DateTimeInput[] | DateTimeInput;
  valid_until_lt?: DateTimeInput;
  valid_until_lte?: DateTimeInput;
  valid_until_gt?: DateTimeInput;
  valid_until_gte?: DateTimeInput;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  AND?: RestoreCodeWhereInput[] | RestoreCodeWhereInput;
  OR?: RestoreCodeWhereInput[] | RestoreCodeWhereInput;
  NOT?: RestoreCodeWhereInput[] | RestoreCodeWhereInput;
}

export interface VideoUpdateManyWithoutLike_usersInput {
  create?:
    | VideoCreateWithoutLike_usersInput[]
    | VideoCreateWithoutLike_usersInput;
  delete?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  set?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  disconnect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  update?:
    | VideoUpdateWithWhereUniqueWithoutLike_usersInput[]
    | VideoUpdateWithWhereUniqueWithoutLike_usersInput;
  upsert?:
    | VideoUpsertWithWhereUniqueWithoutLike_usersInput[]
    | VideoUpsertWithWhereUniqueWithoutLike_usersInput;
  deleteMany?: VideoScalarWhereInput[] | VideoScalarWhereInput;
  updateMany?:
    | VideoUpdateManyWithWhereNestedInput[]
    | VideoUpdateManyWithWhereNestedInput;
}

export interface VideoCreateManyWithoutTagsInput {
  create?: VideoCreateWithoutTagsInput[] | VideoCreateWithoutTagsInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
}

export interface VideoUpdateWithWhereUniqueWithoutLike_usersInput {
  where: VideoWhereUniqueInput;
  data: VideoUpdateWithoutLike_usersDataInput;
}

export interface RestoreCodeUpdateManyMutationInput {
  email?: String;
  valid_until?: DateTimeInput;
  code?: String;
}

export interface VideoUpdateWithoutLike_usersDataInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  author?: UserUpdateOneRequiredWithoutMy_videosInput;
  categories?: CategoryUpdateManyWithoutVideosInput;
  watched_users?: UserUpdateManyWithoutWatched_videosInput;
  tags?: TagUpdateManyWithoutVideosInput;
}

export interface RestoreCodeUpdateInput {
  email?: String;
  valid_until?: DateTimeInput;
  code?: String;
}

export interface VideoUpsertWithWhereUniqueWithoutCategoriesInput {
  where: VideoWhereUniqueInput;
  update: VideoUpdateWithoutCategoriesDataInput;
  create: VideoCreateWithoutCategoriesInput;
}

export interface PostUpdateManyMutationInput {
  title?: String;
  mainImageUrl?: String;
  text?: String;
}

export interface CategoryUpdateWithWhereUniqueWithoutVideosInput {
  where: CategoryWhereUniqueInput;
  data: CategoryUpdateWithoutVideosDataInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface CategoryUpdateWithoutVideosDataInput {
  title?: String;
  description?: String;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface CategoryUpsertWithWhereUniqueWithoutVideosInput {
  where: CategoryWhereUniqueInput;
  update: CategoryUpdateWithoutVideosDataInput;
  create: CategoryCreateWithoutVideosInput;
}

export interface PostUpdateInput {
  title?: String;
  mainImageUrl?: String;
  text?: String;
  author?: UserUpdateOneRequiredInput;
}

export interface CategoryScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: CategoryScalarWhereInput[] | CategoryScalarWhereInput;
  OR?: CategoryScalarWhereInput[] | CategoryScalarWhereInput;
  NOT?: CategoryScalarWhereInput[] | CategoryScalarWhereInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpsertWithoutMy_videosInput {
  update: UserUpdateWithoutMy_videosDataInput;
  create: UserCreateWithoutMy_videosInput;
}

export interface ActivationCodeCreateInput {
  email: String;
  valid_until: DateTimeInput;
  code: String;
}

export interface CategoryUpdateManyDataInput {
  title?: String;
  description?: String;
}

export interface ActivationCodeUpdateManyMutationInput {
  email?: String;
  valid_until?: DateTimeInput;
  code?: String;
}

export interface UserUpdateManyWithoutWatched_videosInput {
  create?:
    | UserCreateWithoutWatched_videosInput[]
    | UserCreateWithoutWatched_videosInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutWatched_videosInput[]
    | UserUpdateWithWhereUniqueWithoutWatched_videosInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutWatched_videosInput[]
    | UserUpsertWithWhereUniqueWithoutWatched_videosInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface CategoryUpdateManyMutationInput {
  title?: String;
  description?: String;
}

export interface UserUpdateWithWhereUniqueWithoutWatched_videosInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutWatched_videosDataInput;
}

export interface VideoCreateManyWithoutCategoriesInput {
  create?:
    | VideoCreateWithoutCategoriesInput[]
    | VideoCreateWithoutCategoriesInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
}

export interface UserUpdateWithoutWatched_videosDataInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email?: String;
  phone?: String;
  role?: UserRole;
  password_hash?: String;
  password_salt?: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  my_videos?: VideoUpdateManyWithoutAuthorInput;
  liked_videos?: VideoUpdateManyWithoutLike_usersInput;
  my_subscription_users?: UserUpdateManyWithoutSubscribed_usersInput;
  subscribed_users?: UserUpdateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  last_login_date?: DateTimeInput;
}

export interface UserCreateOneWithoutMy_videosInput {
  create?: UserCreateWithoutMy_videosInput;
  connect?: UserWhereUniqueInput;
}

export interface VideoUpdateManyWithoutAuthorInput {
  create?: VideoCreateWithoutAuthorInput[] | VideoCreateWithoutAuthorInput;
  delete?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  set?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  disconnect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  update?:
    | VideoUpdateWithWhereUniqueWithoutAuthorInput[]
    | VideoUpdateWithWhereUniqueWithoutAuthorInput;
  upsert?:
    | VideoUpsertWithWhereUniqueWithoutAuthorInput[]
    | VideoUpsertWithWhereUniqueWithoutAuthorInput;
  deleteMany?: VideoScalarWhereInput[] | VideoScalarWhereInput;
  updateMany?:
    | VideoUpdateManyWithWhereNestedInput[]
    | VideoUpdateManyWithWhereNestedInput;
}

export interface VideoCreateManyWithoutLike_usersInput {
  create?:
    | VideoCreateWithoutLike_usersInput[]
    | VideoCreateWithoutLike_usersInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
}

export interface VideoUpdateWithWhereUniqueWithoutAuthorInput {
  where: VideoWhereUniqueInput;
  data: VideoUpdateWithoutAuthorDataInput;
}

export interface CategoryCreateManyWithoutVideosInput {
  create?:
    | CategoryCreateWithoutVideosInput[]
    | CategoryCreateWithoutVideosInput;
  connect?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
}

export interface VideoUpdateWithoutAuthorDataInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  categories?: CategoryUpdateManyWithoutVideosInput;
  like_users?: UserUpdateManyWithoutLiked_videosInput;
  watched_users?: UserUpdateManyWithoutWatched_videosInput;
  tags?: TagUpdateManyWithoutVideosInput;
}

export interface UserCreateManyWithoutWatched_videosInput {
  create?:
    | UserCreateWithoutWatched_videosInput[]
    | UserCreateWithoutWatched_videosInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserUpdateManyWithoutLiked_videosInput {
  create?:
    | UserCreateWithoutLiked_videosInput[]
    | UserCreateWithoutLiked_videosInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutLiked_videosInput[]
    | UserUpdateWithWhereUniqueWithoutLiked_videosInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutLiked_videosInput[]
    | UserUpsertWithWhereUniqueWithoutLiked_videosInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface VideoCreateManyWithoutAuthorInput {
  create?: VideoCreateWithoutAuthorInput[] | VideoCreateWithoutAuthorInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
}

export interface UserUpdateWithWhereUniqueWithoutLiked_videosInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutLiked_videosDataInput;
}

export type CategoryWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateWithoutLiked_videosDataInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email?: String;
  phone?: String;
  role?: UserRole;
  password_hash?: String;
  password_salt?: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  my_videos?: VideoUpdateManyWithoutAuthorInput;
  watched_videos?: VideoUpdateManyWithoutWatched_usersInput;
  my_subscription_users?: UserUpdateManyWithoutSubscribed_usersInput;
  subscribed_users?: UserUpdateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  last_login_date?: DateTimeInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface VideoUpdateManyWithoutWatched_usersInput {
  create?:
    | VideoCreateWithoutWatched_usersInput[]
    | VideoCreateWithoutWatched_usersInput;
  delete?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  set?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  disconnect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  update?:
    | VideoUpdateWithWhereUniqueWithoutWatched_usersInput[]
    | VideoUpdateWithWhereUniqueWithoutWatched_usersInput;
  upsert?:
    | VideoUpsertWithWhereUniqueWithoutWatched_usersInput[]
    | VideoUpsertWithWhereUniqueWithoutWatched_usersInput;
  deleteMany?: VideoScalarWhereInput[] | VideoScalarWhereInput;
  updateMany?:
    | VideoUpdateManyWithWhereNestedInput[]
    | VideoUpdateManyWithWhereNestedInput;
}

export interface RestoreCodeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RestoreCodeWhereInput;
  AND?: RestoreCodeSubscriptionWhereInput[] | RestoreCodeSubscriptionWhereInput;
  OR?: RestoreCodeSubscriptionWhereInput[] | RestoreCodeSubscriptionWhereInput;
  NOT?: RestoreCodeSubscriptionWhereInput[] | RestoreCodeSubscriptionWhereInput;
}

export interface VideoUpdateWithWhereUniqueWithoutWatched_usersInput {
  where: VideoWhereUniqueInput;
  data: VideoUpdateWithoutWatched_usersDataInput;
}

export interface VideoUpdateManyMutationInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
}

export interface VideoUpdateWithoutWatched_usersDataInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  author?: UserUpdateOneRequiredWithoutMy_videosInput;
  categories?: CategoryUpdateManyWithoutVideosInput;
  like_users?: UserUpdateManyWithoutLiked_videosInput;
  tags?: TagUpdateManyWithoutVideosInput;
}

export interface UserUpdateManyMutationInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email?: String;
  phone?: String;
  role?: UserRole;
  password_hash?: String;
  password_salt?: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  last_login_date?: DateTimeInput;
}

export interface TagUpdateManyWithoutVideosInput {
  create?: TagCreateWithoutVideosInput[] | TagCreateWithoutVideosInput;
  delete?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  set?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  disconnect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  update?:
    | TagUpdateWithWhereUniqueWithoutVideosInput[]
    | TagUpdateWithWhereUniqueWithoutVideosInput;
  upsert?:
    | TagUpsertWithWhereUniqueWithoutVideosInput[]
    | TagUpsertWithWhereUniqueWithoutVideosInput;
  deleteMany?: TagScalarWhereInput[] | TagScalarWhereInput;
  updateMany?:
    | TagUpdateManyWithWhereNestedInput[]
    | TagUpdateManyWithWhereNestedInput;
}

export interface PostWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  mainImageUrl?: String;
  mainImageUrl_not?: String;
  mainImageUrl_in?: String[] | String;
  mainImageUrl_not_in?: String[] | String;
  mainImageUrl_lt?: String;
  mainImageUrl_lte?: String;
  mainImageUrl_gt?: String;
  mainImageUrl_gte?: String;
  mainImageUrl_contains?: String;
  mainImageUrl_not_contains?: String;
  mainImageUrl_starts_with?: String;
  mainImageUrl_not_starts_with?: String;
  mainImageUrl_ends_with?: String;
  mainImageUrl_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  author?: UserWhereInput;
  AND?: PostWhereInput[] | PostWhereInput;
  OR?: PostWhereInput[] | PostWhereInput;
  NOT?: PostWhereInput[] | PostWhereInput;
}

export interface TagUpdateWithWhereUniqueWithoutVideosInput {
  where: TagWhereUniqueInput;
  data: TagUpdateWithoutVideosDataInput;
}

export interface VideoUpdateManyWithoutTagsInput {
  create?: VideoCreateWithoutTagsInput[] | VideoCreateWithoutTagsInput;
  delete?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  set?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  disconnect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  update?:
    | VideoUpdateWithWhereUniqueWithoutTagsInput[]
    | VideoUpdateWithWhereUniqueWithoutTagsInput;
  upsert?:
    | VideoUpsertWithWhereUniqueWithoutTagsInput[]
    | VideoUpsertWithWhereUniqueWithoutTagsInput;
  deleteMany?: VideoScalarWhereInput[] | VideoScalarWhereInput;
  updateMany?:
    | VideoUpdateManyWithWhereNestedInput[]
    | VideoUpdateManyWithWhereNestedInput;
}

export interface TagUpdateWithoutVideosDataInput {
  text?: String;
}

export interface VideoCreateWithoutTagsInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  author: UserCreateOneWithoutMy_videosInput;
  categories?: CategoryCreateManyWithoutVideosInput;
  like_users?: UserCreateManyWithoutLiked_videosInput;
  watched_users?: UserCreateManyWithoutWatched_videosInput;
}

export interface TagUpsertWithWhereUniqueWithoutVideosInput {
  where: TagWhereUniqueInput;
  update: TagUpdateWithoutVideosDataInput;
  create: TagCreateWithoutVideosInput;
}

export type TagWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface TagScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  AND?: TagScalarWhereInput[] | TagScalarWhereInput;
  OR?: TagScalarWhereInput[] | TagScalarWhereInput;
  NOT?: TagScalarWhereInput[] | TagScalarWhereInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
  phone?: String;
  password_salt?: String;
  stripe_customer_id?: String;
}>;

export interface TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput;
  data: TagUpdateManyDataInput;
}

export type VideoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface TagUpdateManyDataInput {
  text?: String;
}

export interface PostCreateInput {
  title: String;
  mainImageUrl?: String;
  text: String;
  author: UserCreateOneInput;
}

export interface VideoUpsertWithWhereUniqueWithoutWatched_usersInput {
  where: VideoWhereUniqueInput;
  update: VideoUpdateWithoutWatched_usersDataInput;
  create: VideoCreateWithoutWatched_usersInput;
}

export interface VideoCreateWithoutCategoriesInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  author: UserCreateOneWithoutMy_videosInput;
  like_users?: UserCreateManyWithoutLiked_videosInput;
  watched_users?: UserCreateManyWithoutWatched_videosInput;
  tags?: TagCreateManyWithoutVideosInput;
}

export interface VideoScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  publish_date?: DateTimeInput;
  publish_date_not?: DateTimeInput;
  publish_date_in?: DateTimeInput[] | DateTimeInput;
  publish_date_not_in?: DateTimeInput[] | DateTimeInput;
  publish_date_lt?: DateTimeInput;
  publish_date_lte?: DateTimeInput;
  publish_date_gt?: DateTimeInput;
  publish_date_gte?: DateTimeInput;
  file_url?: String;
  file_url_not?: String;
  file_url_in?: String[] | String;
  file_url_not_in?: String[] | String;
  file_url_lt?: String;
  file_url_lte?: String;
  file_url_gt?: String;
  file_url_gte?: String;
  file_url_contains?: String;
  file_url_not_contains?: String;
  file_url_starts_with?: String;
  file_url_not_starts_with?: String;
  file_url_ends_with?: String;
  file_url_not_ends_with?: String;
  video_duration?: Int;
  video_duration_not?: Int;
  video_duration_in?: Int[] | Int;
  video_duration_not_in?: Int[] | Int;
  video_duration_lt?: Int;
  video_duration_lte?: Int;
  video_duration_gt?: Int;
  video_duration_gte?: Int;
  preview_url?: String;
  preview_url_not?: String;
  preview_url_in?: String[] | String;
  preview_url_not_in?: String[] | String;
  preview_url_lt?: String;
  preview_url_lte?: String;
  preview_url_gt?: String;
  preview_url_gte?: String;
  preview_url_contains?: String;
  preview_url_not_contains?: String;
  preview_url_starts_with?: String;
  preview_url_not_starts_with?: String;
  preview_url_ends_with?: String;
  preview_url_not_ends_with?: String;
  preview_video_url?: String;
  preview_video_url_not?: String;
  preview_video_url_in?: String[] | String;
  preview_video_url_not_in?: String[] | String;
  preview_video_url_lt?: String;
  preview_video_url_lte?: String;
  preview_video_url_gt?: String;
  preview_video_url_gte?: String;
  preview_video_url_contains?: String;
  preview_video_url_not_contains?: String;
  preview_video_url_starts_with?: String;
  preview_video_url_not_starts_with?: String;
  preview_video_url_ends_with?: String;
  preview_video_url_not_ends_with?: String;
  preview_video_duration?: String;
  preview_video_duration_not?: String;
  preview_video_duration_in?: String[] | String;
  preview_video_duration_not_in?: String[] | String;
  preview_video_duration_lt?: String;
  preview_video_duration_lte?: String;
  preview_video_duration_gt?: String;
  preview_video_duration_gte?: String;
  preview_video_duration_contains?: String;
  preview_video_duration_not_contains?: String;
  preview_video_duration_starts_with?: String;
  preview_video_duration_not_starts_with?: String;
  preview_video_duration_ends_with?: String;
  preview_video_duration_not_ends_with?: String;
  AND?: VideoScalarWhereInput[] | VideoScalarWhereInput;
  OR?: VideoScalarWhereInput[] | VideoScalarWhereInput;
  NOT?: VideoScalarWhereInput[] | VideoScalarWhereInput;
}

export interface VideoCreateWithoutLike_usersInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  author: UserCreateOneWithoutMy_videosInput;
  categories?: CategoryCreateManyWithoutVideosInput;
  watched_users?: UserCreateManyWithoutWatched_videosInput;
  tags?: TagCreateManyWithoutVideosInput;
}

export interface VideoUpdateManyWithWhereNestedInput {
  where: VideoScalarWhereInput;
  data: VideoUpdateManyDataInput;
}

export interface UserCreateWithoutWatched_videosInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email: String;
  phone?: String;
  role?: UserRole;
  password_hash: String;
  password_salt: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  my_videos?: VideoCreateManyWithoutAuthorInput;
  liked_videos?: VideoCreateManyWithoutLike_usersInput;
  my_subscription_users?: UserCreateManyWithoutSubscribed_usersInput;
  subscribed_users?: UserCreateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  last_login_date?: DateTimeInput;
}

export interface VideoUpdateManyDataInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
}

export interface VideoWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  publish_date?: DateTimeInput;
  publish_date_not?: DateTimeInput;
  publish_date_in?: DateTimeInput[] | DateTimeInput;
  publish_date_not_in?: DateTimeInput[] | DateTimeInput;
  publish_date_lt?: DateTimeInput;
  publish_date_lte?: DateTimeInput;
  publish_date_gt?: DateTimeInput;
  publish_date_gte?: DateTimeInput;
  file_url?: String;
  file_url_not?: String;
  file_url_in?: String[] | String;
  file_url_not_in?: String[] | String;
  file_url_lt?: String;
  file_url_lte?: String;
  file_url_gt?: String;
  file_url_gte?: String;
  file_url_contains?: String;
  file_url_not_contains?: String;
  file_url_starts_with?: String;
  file_url_not_starts_with?: String;
  file_url_ends_with?: String;
  file_url_not_ends_with?: String;
  video_duration?: Int;
  video_duration_not?: Int;
  video_duration_in?: Int[] | Int;
  video_duration_not_in?: Int[] | Int;
  video_duration_lt?: Int;
  video_duration_lte?: Int;
  video_duration_gt?: Int;
  video_duration_gte?: Int;
  preview_url?: String;
  preview_url_not?: String;
  preview_url_in?: String[] | String;
  preview_url_not_in?: String[] | String;
  preview_url_lt?: String;
  preview_url_lte?: String;
  preview_url_gt?: String;
  preview_url_gte?: String;
  preview_url_contains?: String;
  preview_url_not_contains?: String;
  preview_url_starts_with?: String;
  preview_url_not_starts_with?: String;
  preview_url_ends_with?: String;
  preview_url_not_ends_with?: String;
  preview_video_url?: String;
  preview_video_url_not?: String;
  preview_video_url_in?: String[] | String;
  preview_video_url_not_in?: String[] | String;
  preview_video_url_lt?: String;
  preview_video_url_lte?: String;
  preview_video_url_gt?: String;
  preview_video_url_gte?: String;
  preview_video_url_contains?: String;
  preview_video_url_not_contains?: String;
  preview_video_url_starts_with?: String;
  preview_video_url_not_starts_with?: String;
  preview_video_url_ends_with?: String;
  preview_video_url_not_ends_with?: String;
  preview_video_duration?: String;
  preview_video_duration_not?: String;
  preview_video_duration_in?: String[] | String;
  preview_video_duration_not_in?: String[] | String;
  preview_video_duration_lt?: String;
  preview_video_duration_lte?: String;
  preview_video_duration_gt?: String;
  preview_video_duration_gte?: String;
  preview_video_duration_contains?: String;
  preview_video_duration_not_contains?: String;
  preview_video_duration_starts_with?: String;
  preview_video_duration_not_starts_with?: String;
  preview_video_duration_ends_with?: String;
  preview_video_duration_not_ends_with?: String;
  author?: UserWhereInput;
  categories_every?: CategoryWhereInput;
  categories_some?: CategoryWhereInput;
  categories_none?: CategoryWhereInput;
  like_users_every?: UserWhereInput;
  like_users_some?: UserWhereInput;
  like_users_none?: UserWhereInput;
  watched_users_every?: UserWhereInput;
  watched_users_some?: UserWhereInput;
  watched_users_none?: UserWhereInput;
  tags_every?: TagWhereInput;
  tags_some?: TagWhereInput;
  tags_none?: TagWhereInput;
  AND?: VideoWhereInput[] | VideoWhereInput;
  OR?: VideoWhereInput[] | VideoWhereInput;
  NOT?: VideoWhereInput[] | VideoWhereInput;
}

export interface UserUpdateManyWithoutSubscribed_usersInput {
  create?:
    | UserCreateWithoutSubscribed_usersInput[]
    | UserCreateWithoutSubscribed_usersInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutSubscribed_usersInput[]
    | UserUpdateWithWhereUniqueWithoutSubscribed_usersInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutSubscribed_usersInput[]
    | UserUpsertWithWhereUniqueWithoutSubscribed_usersInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface CategorySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CategoryWhereInput;
  AND?: CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput;
  OR?: CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput;
  NOT?: CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput;
}

export interface UserUpdateWithWhereUniqueWithoutSubscribed_usersInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutSubscribed_usersDataInput;
}

export type PostWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateWithoutSubscribed_usersDataInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email?: String;
  phone?: String;
  role?: UserRole;
  password_hash?: String;
  password_salt?: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  my_videos?: VideoUpdateManyWithoutAuthorInput;
  liked_videos?: VideoUpdateManyWithoutLike_usersInput;
  watched_videos?: VideoUpdateManyWithoutWatched_usersInput;
  my_subscription_users?: UserUpdateManyWithoutSubscribed_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  last_login_date?: DateTimeInput;
}

export interface TagUpdateInput {
  text?: String;
  videos?: VideoUpdateManyWithoutTagsInput;
}

export interface UserUpsertWithWhereUniqueWithoutSubscribed_usersInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutSubscribed_usersDataInput;
  create: UserCreateWithoutSubscribed_usersInput;
}

export interface RestoreCodeCreateInput {
  email: String;
  valid_until: DateTimeInput;
  code: String;
}

export interface UserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  firstname?: String;
  firstname_not?: String;
  firstname_in?: String[] | String;
  firstname_not_in?: String[] | String;
  firstname_lt?: String;
  firstname_lte?: String;
  firstname_gt?: String;
  firstname_gte?: String;
  firstname_contains?: String;
  firstname_not_contains?: String;
  firstname_starts_with?: String;
  firstname_not_starts_with?: String;
  firstname_ends_with?: String;
  firstname_not_ends_with?: String;
  lastname?: String;
  lastname_not?: String;
  lastname_in?: String[] | String;
  lastname_not_in?: String[] | String;
  lastname_lt?: String;
  lastname_lte?: String;
  lastname_gt?: String;
  lastname_gte?: String;
  lastname_contains?: String;
  lastname_not_contains?: String;
  lastname_starts_with?: String;
  lastname_not_starts_with?: String;
  lastname_ends_with?: String;
  lastname_not_ends_with?: String;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  role?: UserRole;
  role_not?: UserRole;
  role_in?: UserRole[] | UserRole;
  role_not_in?: UserRole[] | UserRole;
  password_hash?: String;
  password_hash_not?: String;
  password_hash_in?: String[] | String;
  password_hash_not_in?: String[] | String;
  password_hash_lt?: String;
  password_hash_lte?: String;
  password_hash_gt?: String;
  password_hash_gte?: String;
  password_hash_contains?: String;
  password_hash_not_contains?: String;
  password_hash_starts_with?: String;
  password_hash_not_starts_with?: String;
  password_hash_ends_with?: String;
  password_hash_not_ends_with?: String;
  password_salt?: String;
  password_salt_not?: String;
  password_salt_in?: String[] | String;
  password_salt_not_in?: String[] | String;
  password_salt_lt?: String;
  password_salt_lte?: String;
  password_salt_gt?: String;
  password_salt_gte?: String;
  password_salt_contains?: String;
  password_salt_not_contains?: String;
  password_salt_starts_with?: String;
  password_salt_not_starts_with?: String;
  password_salt_ends_with?: String;
  password_salt_not_ends_with?: String;
  avatar?: String;
  avatar_not?: String;
  avatar_in?: String[] | String;
  avatar_not_in?: String[] | String;
  avatar_lt?: String;
  avatar_lte?: String;
  avatar_gt?: String;
  avatar_gte?: String;
  avatar_contains?: String;
  avatar_not_contains?: String;
  avatar_starts_with?: String;
  avatar_not_starts_with?: String;
  avatar_ends_with?: String;
  avatar_not_ends_with?: String;
  background_image?: String;
  background_image_not?: String;
  background_image_in?: String[] | String;
  background_image_not_in?: String[] | String;
  background_image_lt?: String;
  background_image_lte?: String;
  background_image_gt?: String;
  background_image_gte?: String;
  background_image_contains?: String;
  background_image_not_contains?: String;
  background_image_starts_with?: String;
  background_image_not_starts_with?: String;
  background_image_ends_with?: String;
  background_image_not_ends_with?: String;
  about_text?: String;
  about_text_not?: String;
  about_text_in?: String[] | String;
  about_text_not_in?: String[] | String;
  about_text_lt?: String;
  about_text_lte?: String;
  about_text_gt?: String;
  about_text_gte?: String;
  about_text_contains?: String;
  about_text_not_contains?: String;
  about_text_starts_with?: String;
  about_text_not_starts_with?: String;
  about_text_ends_with?: String;
  about_text_not_ends_with?: String;
  billing_subscription_active?: Boolean;
  billing_subscription_active_not?: Boolean;
  stripe_customer_id?: String;
  stripe_customer_id_not?: String;
  stripe_customer_id_in?: String[] | String;
  stripe_customer_id_not_in?: String[] | String;
  stripe_customer_id_lt?: String;
  stripe_customer_id_lte?: String;
  stripe_customer_id_gt?: String;
  stripe_customer_id_gte?: String;
  stripe_customer_id_contains?: String;
  stripe_customer_id_not_contains?: String;
  stripe_customer_id_starts_with?: String;
  stripe_customer_id_not_starts_with?: String;
  stripe_customer_id_ends_with?: String;
  stripe_customer_id_not_ends_with?: String;
  last_login_date?: DateTimeInput;
  last_login_date_not?: DateTimeInput;
  last_login_date_in?: DateTimeInput[] | DateTimeInput;
  last_login_date_not_in?: DateTimeInput[] | DateTimeInput;
  last_login_date_lt?: DateTimeInput;
  last_login_date_lte?: DateTimeInput;
  last_login_date_gt?: DateTimeInput;
  last_login_date_gte?: DateTimeInput;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export interface UserCreateInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email: String;
  phone?: String;
  role?: UserRole;
  password_hash: String;
  password_salt: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  my_videos?: VideoCreateManyWithoutAuthorInput;
  liked_videos?: VideoCreateManyWithoutLike_usersInput;
  watched_videos?: VideoCreateManyWithoutWatched_usersInput;
  my_subscription_users?: UserCreateManyWithoutSubscribed_usersInput;
  subscribed_users?: UserCreateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  last_login_date?: DateTimeInput;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface CategoryCreateInput {
  title: String;
  description?: String;
  videos?: VideoCreateManyWithoutCategoriesInput;
}

export interface UserUpdateManyDataInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email?: String;
  phone?: String;
  role?: UserRole;
  password_hash?: String;
  password_salt?: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  last_login_date?: DateTimeInput;
}

export interface CategoryCreateWithoutVideosInput {
  title: String;
  description?: String;
}

export interface UserUpdateManyWithoutMy_subscription_usersInput {
  create?:
    | UserCreateWithoutMy_subscription_usersInput[]
    | UserCreateWithoutMy_subscription_usersInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutMy_subscription_usersInput[]
    | UserUpdateWithWhereUniqueWithoutMy_subscription_usersInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutMy_subscription_usersInput[]
    | UserUpsertWithWhereUniqueWithoutMy_subscription_usersInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface TagWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  videos_every?: VideoWhereInput;
  videos_some?: VideoWhereInput;
  videos_none?: VideoWhereInput;
  AND?: TagWhereInput[] | TagWhereInput;
  OR?: TagWhereInput[] | TagWhereInput;
  NOT?: TagWhereInput[] | TagWhereInput;
}

export interface UserUpdateWithWhereUniqueWithoutMy_subscription_usersInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutMy_subscription_usersDataInput;
}

export interface VideoUpdateWithoutTagsDataInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  author?: UserUpdateOneRequiredWithoutMy_videosInput;
  categories?: CategoryUpdateManyWithoutVideosInput;
  like_users?: UserUpdateManyWithoutLiked_videosInput;
  watched_users?: UserUpdateManyWithoutWatched_videosInput;
}

export interface UserUpdateWithoutMy_subscription_usersDataInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email?: String;
  phone?: String;
  role?: UserRole;
  password_hash?: String;
  password_salt?: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  my_videos?: VideoUpdateManyWithoutAuthorInput;
  liked_videos?: VideoUpdateManyWithoutLike_usersInput;
  watched_videos?: VideoUpdateManyWithoutWatched_usersInput;
  subscribed_users?: UserUpdateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  last_login_date?: DateTimeInput;
}

export interface UserUpdateDataInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email?: String;
  phone?: String;
  role?: UserRole;
  password_hash?: String;
  password_salt?: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  my_videos?: VideoUpdateManyWithoutAuthorInput;
  liked_videos?: VideoUpdateManyWithoutLike_usersInput;
  watched_videos?: VideoUpdateManyWithoutWatched_usersInput;
  my_subscription_users?: UserUpdateManyWithoutSubscribed_usersInput;
  subscribed_users?: UserUpdateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  last_login_date?: DateTimeInput;
}

export interface UserUpsertWithWhereUniqueWithoutWatched_videosInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutWatched_videosDataInput;
  create: UserCreateWithoutWatched_videosInput;
}

export interface VideoUpsertWithWhereUniqueWithoutAuthorInput {
  where: VideoWhereUniqueInput;
  update: VideoUpdateWithoutAuthorDataInput;
  create: VideoCreateWithoutAuthorInput;
}

export interface UserUpsertWithWhereUniqueWithoutLiked_videosInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutLiked_videosDataInput;
  create: UserCreateWithoutLiked_videosInput;
}

export interface UserUpsertWithWhereUniqueWithoutMy_subscription_usersInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutMy_subscription_usersDataInput;
  create: UserCreateWithoutMy_subscription_usersInput;
}

export interface ActivationCodeUpdateInput {
  email?: String;
  valid_until?: DateTimeInput;
  code?: String;
}

export interface TagCreateInput {
  text: String;
  videos?: VideoCreateManyWithoutTagsInput;
}

export interface VideoUpdateInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  author?: UserUpdateOneRequiredWithoutMy_videosInput;
  categories?: CategoryUpdateManyWithoutVideosInput;
  like_users?: UserUpdateManyWithoutLiked_videosInput;
  watched_users?: UserUpdateManyWithoutWatched_videosInput;
  tags?: TagUpdateManyWithoutVideosInput;
}

export interface VideoCreateWithoutAuthorInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  categories?: CategoryCreateManyWithoutVideosInput;
  like_users?: UserCreateManyWithoutLiked_videosInput;
  watched_users?: UserCreateManyWithoutWatched_videosInput;
  tags?: TagCreateManyWithoutVideosInput;
}

export interface UserCreateWithoutMy_videosInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email: String;
  phone?: String;
  role?: UserRole;
  password_hash: String;
  password_salt: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  liked_videos?: VideoCreateManyWithoutLike_usersInput;
  watched_videos?: VideoCreateManyWithoutWatched_usersInput;
  my_subscription_users?: UserCreateManyWithoutSubscribed_usersInput;
  subscribed_users?: UserCreateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  last_login_date?: DateTimeInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface VideoPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title?: String;
  description?: String;
  publish_date?: DateTimeOutput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
}

export interface VideoPreviousValuesPromise
  extends Promise<VideoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  publish_date: () => Promise<DateTimeOutput>;
  file_url: () => Promise<String>;
  video_duration: () => Promise<Int>;
  preview_url: () => Promise<String>;
  preview_video_url: () => Promise<String>;
  preview_video_duration: () => Promise<String>;
}

export interface VideoPreviousValuesSubscription
  extends Promise<AsyncIterator<VideoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  publish_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  file_url: () => Promise<AsyncIterator<String>>;
  video_duration: () => Promise<AsyncIterator<Int>>;
  preview_url: () => Promise<AsyncIterator<String>>;
  preview_video_url: () => Promise<AsyncIterator<String>>;
  preview_video_duration: () => Promise<AsyncIterator<String>>;
}

export interface CategoryConnection {
  pageInfo: PageInfo;
  edges: CategoryEdge[];
}

export interface CategoryConnectionPromise
  extends Promise<CategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CategoryEdge>>() => T;
  aggregate: <T = AggregateCategoryPromise>() => T;
}

export interface CategoryConnectionSubscription
  extends Promise<AsyncIterator<CategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCategorySubscription>() => T;
}

export interface ActivationCodeEdge {
  node: ActivationCode;
  cursor: String;
}

export interface ActivationCodeEdgePromise
  extends Promise<ActivationCodeEdge>,
    Fragmentable {
  node: <T = ActivationCodePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ActivationCodeEdgeSubscription
  extends Promise<AsyncIterator<ActivationCodeEdge>>,
    Fragmentable {
  node: <T = ActivationCodeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Tag {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  text: String;
}

export interface TagPromise extends Promise<Tag>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
  videos: <T = FragmentableArray<Video>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface TagSubscription
  extends Promise<AsyncIterator<Tag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  text: () => Promise<AsyncIterator<String>>;
  videos: <T = Promise<AsyncIterator<VideoSubscription>>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateActivationCode {
  count: Int;
}

export interface AggregateActivationCodePromise
  extends Promise<AggregateActivationCode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateActivationCodeSubscription
  extends Promise<AsyncIterator<AggregateActivationCode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CategoryEdge {
  node: Category;
  cursor: String;
}

export interface CategoryEdgePromise
  extends Promise<CategoryEdge>,
    Fragmentable {
  node: <T = CategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CategoryEdgeSubscription
  extends Promise<AsyncIterator<CategoryEdge>>,
    Fragmentable {
  node: <T = CategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TagPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  text: String;
}

export interface TagPreviousValuesPromise
  extends Promise<TagPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
}

export interface TagPreviousValuesSubscription
  extends Promise<AsyncIterator<TagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface Category {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  description?: String;
}

export interface CategoryPromise extends Promise<Category>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  videos: <T = FragmentableArray<Video>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CategorySubscription
  extends Promise<AsyncIterator<Category>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  videos: <T = Promise<AsyncIterator<VideoSubscription>>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateVideo {
  count: Int;
}

export interface AggregateVideoPromise
  extends Promise<AggregateVideo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVideoSubscription
  extends Promise<AsyncIterator<AggregateVideo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VideoEdge {
  node: Video;
  cursor: String;
}

export interface VideoEdgePromise extends Promise<VideoEdge>, Fragmentable {
  node: <T = VideoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VideoEdgeSubscription
  extends Promise<AsyncIterator<VideoEdge>>,
    Fragmentable {
  node: <T = VideoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstname?: String;
  lastname?: String;
  username?: String;
  email: String;
  phone?: String;
  role: UserRole;
  password_hash: String;
  password_salt: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  billing_subscription_active: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  last_login_date?: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstname: () => Promise<String>;
  lastname: () => Promise<String>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  phone: () => Promise<String>;
  role: () => Promise<UserRole>;
  password_hash: () => Promise<String>;
  password_salt: () => Promise<String>;
  avatar: () => Promise<String>;
  background_image: () => Promise<String>;
  about_text: () => Promise<String>;
  billing_subscription_active: () => Promise<Boolean>;
  stripe_customer_id: () => Promise<String>;
  stripe_subsciption_json: () => Promise<Json>;
  last_login_date: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstname: () => Promise<AsyncIterator<String>>;
  lastname: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<UserRole>>;
  password_hash: () => Promise<AsyncIterator<String>>;
  password_salt: () => Promise<AsyncIterator<String>>;
  avatar: () => Promise<AsyncIterator<String>>;
  background_image: () => Promise<AsyncIterator<String>>;
  about_text: () => Promise<AsyncIterator<String>>;
  billing_subscription_active: () => Promise<AsyncIterator<Boolean>>;
  stripe_customer_id: () => Promise<AsyncIterator<String>>;
  stripe_subsciption_json: () => Promise<AsyncIterator<Json>>;
  last_login_date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TagEdge {
  node: Tag;
  cursor: String;
}

export interface TagEdgePromise extends Promise<TagEdge>, Fragmentable {
  node: <T = TagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TagEdgeSubscription
  extends Promise<AsyncIterator<TagEdge>>,
    Fragmentable {
  node: <T = TagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface AggregateRestoreCode {
  count: Int;
}

export interface AggregateRestoreCodePromise
  extends Promise<AggregateRestoreCode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRestoreCodeSubscription
  extends Promise<AsyncIterator<AggregateRestoreCode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ActivationCodeSubscriptionPayload {
  mutation: MutationType;
  node: ActivationCode;
  updatedFields: String[];
  previousValues: ActivationCodePreviousValues;
}

export interface ActivationCodeSubscriptionPayloadPromise
  extends Promise<ActivationCodeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ActivationCodePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ActivationCodePreviousValuesPromise>() => T;
}

export interface ActivationCodeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ActivationCodeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ActivationCodeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ActivationCodePreviousValuesSubscription>() => T;
}

export interface RestoreCodeConnection {
  pageInfo: PageInfo;
  edges: RestoreCodeEdge[];
}

export interface RestoreCodeConnectionPromise
  extends Promise<RestoreCodeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RestoreCodeEdge>>() => T;
  aggregate: <T = AggregateRestoreCodePromise>() => T;
}

export interface RestoreCodeConnectionSubscription
  extends Promise<AsyncIterator<RestoreCodeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RestoreCodeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRestoreCodeSubscription>() => T;
}

export interface ActivationCodePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  valid_until: DateTimeOutput;
  code: String;
}

export interface ActivationCodePreviousValuesPromise
  extends Promise<ActivationCodePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  valid_until: () => Promise<DateTimeOutput>;
  code: () => Promise<String>;
}

export interface ActivationCodePreviousValuesSubscription
  extends Promise<AsyncIterator<ActivationCodePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  valid_until: () => Promise<AsyncIterator<DateTimeOutput>>;
  code: () => Promise<AsyncIterator<String>>;
}

export interface RestoreCode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  valid_until: DateTimeOutput;
  code: String;
}

export interface RestoreCodePromise extends Promise<RestoreCode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  valid_until: () => Promise<DateTimeOutput>;
  code: () => Promise<String>;
}

export interface RestoreCodeSubscription
  extends Promise<AsyncIterator<RestoreCode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  valid_until: () => Promise<AsyncIterator<DateTimeOutput>>;
  code: () => Promise<AsyncIterator<String>>;
}

export interface ActivationCodeConnection {
  pageInfo: PageInfo;
  edges: ActivationCodeEdge[];
}

export interface ActivationCodeConnectionPromise
  extends Promise<ActivationCodeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ActivationCodeEdge>>() => T;
  aggregate: <T = AggregateActivationCodePromise>() => T;
}

export interface ActivationCodeConnectionSubscription
  extends Promise<AsyncIterator<ActivationCodeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ActivationCodeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateActivationCodeSubscription>() => T;
}

export interface PostEdge {
  node: Post;
  cursor: String;
}

export interface PostEdgePromise extends Promise<PostEdge>, Fragmentable {
  node: <T = PostPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostEdgeSubscription
  extends Promise<AsyncIterator<PostEdge>>,
    Fragmentable {
  node: <T = PostSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CategorySubscriptionPayload {
  mutation: MutationType;
  node: Category;
  updatedFields: String[];
  previousValues: CategoryPreviousValues;
}

export interface CategorySubscriptionPayloadPromise
  extends Promise<CategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CategoryPreviousValuesPromise>() => T;
}

export interface CategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CategoryPreviousValuesSubscription>() => T;
}

export interface VideoSubscriptionPayload {
  mutation: MutationType;
  node: Video;
  updatedFields: String[];
  previousValues: VideoPreviousValues;
}

export interface VideoSubscriptionPayloadPromise
  extends Promise<VideoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VideoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VideoPreviousValuesPromise>() => T;
}

export interface VideoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VideoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VideoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VideoPreviousValuesSubscription>() => T;
}

export interface CategoryPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  description?: String;
}

export interface CategoryPreviousValuesPromise
  extends Promise<CategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  description: () => Promise<String>;
}

export interface CategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<CategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCategory {
  count: Int;
}

export interface AggregateCategoryPromise
  extends Promise<AggregateCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCategorySubscription
  extends Promise<AsyncIterator<AggregateCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstname?: String;
  lastname?: String;
  username?: String;
  email: String;
  phone?: String;
  role: UserRole;
  password_hash: String;
  password_salt: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  billing_subscription_active: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  last_login_date?: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstname: () => Promise<String>;
  lastname: () => Promise<String>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  phone: () => Promise<String>;
  role: () => Promise<UserRole>;
  password_hash: () => Promise<String>;
  password_salt: () => Promise<String>;
  avatar: () => Promise<String>;
  background_image: () => Promise<String>;
  about_text: () => Promise<String>;
  my_videos: <T = FragmentableArray<Video>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  liked_videos: <T = FragmentableArray<Video>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  watched_videos: <T = FragmentableArray<Video>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  my_subscription_users: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  subscribed_users: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  billing_subscription_active: () => Promise<Boolean>;
  stripe_customer_id: () => Promise<String>;
  stripe_subsciption_json: () => Promise<Json>;
  last_login_date: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstname: () => Promise<AsyncIterator<String>>;
  lastname: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<UserRole>>;
  password_hash: () => Promise<AsyncIterator<String>>;
  password_salt: () => Promise<AsyncIterator<String>>;
  avatar: () => Promise<AsyncIterator<String>>;
  background_image: () => Promise<AsyncIterator<String>>;
  about_text: () => Promise<AsyncIterator<String>>;
  my_videos: <T = Promise<AsyncIterator<VideoSubscription>>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  liked_videos: <T = Promise<AsyncIterator<VideoSubscription>>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  watched_videos: <T = Promise<AsyncIterator<VideoSubscription>>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  my_subscription_users: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  subscribed_users: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  billing_subscription_active: () => Promise<AsyncIterator<Boolean>>;
  stripe_customer_id: () => Promise<AsyncIterator<String>>;
  stripe_subsciption_json: () => Promise<AsyncIterator<Json>>;
  last_login_date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PostSubscriptionPayload {
  mutation: MutationType;
  node: Post;
  updatedFields: String[];
  previousValues: PostPreviousValues;
}

export interface PostSubscriptionPayloadPromise
  extends Promise<PostSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostPreviousValuesPromise>() => T;
}

export interface PostSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostPreviousValuesSubscription>() => T;
}

export interface TagConnection {
  pageInfo: PageInfo;
  edges: TagEdge[];
}

export interface TagConnectionPromise
  extends Promise<TagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TagEdge>>() => T;
  aggregate: <T = AggregateTagPromise>() => T;
}

export interface TagConnectionSubscription
  extends Promise<AsyncIterator<TagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTagSubscription>() => T;
}

export interface PostPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  mainImageUrl?: String;
  text: String;
}

export interface PostPreviousValuesPromise
  extends Promise<PostPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  mainImageUrl: () => Promise<String>;
  text: () => Promise<String>;
}

export interface PostPreviousValuesSubscription
  extends Promise<AsyncIterator<PostPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  mainImageUrl: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface ActivationCode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  valid_until: DateTimeOutput;
  code: String;
}

export interface ActivationCodePromise
  extends Promise<ActivationCode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  valid_until: () => Promise<DateTimeOutput>;
  code: () => Promise<String>;
}

export interface ActivationCodeSubscription
  extends Promise<AsyncIterator<ActivationCode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  valid_until: () => Promise<AsyncIterator<DateTimeOutput>>;
  code: () => Promise<AsyncIterator<String>>;
}

export interface Video {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title?: String;
  description?: String;
  publish_date?: DateTimeOutput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
}

export interface VideoPromise extends Promise<Video>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  publish_date: () => Promise<DateTimeOutput>;
  file_url: () => Promise<String>;
  video_duration: () => Promise<Int>;
  preview_url: () => Promise<String>;
  preview_video_url: () => Promise<String>;
  preview_video_duration: () => Promise<String>;
  author: <T = UserPromise>() => T;
  categories: <T = FragmentableArray<Category>>(
    args?: {
      where?: CategoryWhereInput;
      orderBy?: CategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  like_users: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  watched_users: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tags: <T = FragmentableArray<Tag>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface VideoSubscription
  extends Promise<AsyncIterator<Video>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  publish_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  file_url: () => Promise<AsyncIterator<String>>;
  video_duration: () => Promise<AsyncIterator<Int>>;
  preview_url: () => Promise<AsyncIterator<String>>;
  preview_video_url: () => Promise<AsyncIterator<String>>;
  preview_video_duration: () => Promise<AsyncIterator<String>>;
  author: <T = UserSubscription>() => T;
  categories: <T = Promise<AsyncIterator<CategorySubscription>>>(
    args?: {
      where?: CategoryWhereInput;
      orderBy?: CategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  like_users: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  watched_users: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface PostConnection {
  pageInfo: PageInfo;
  edges: PostEdge[];
}

export interface PostConnectionPromise
  extends Promise<PostConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostEdge>>() => T;
  aggregate: <T = AggregatePostPromise>() => T;
}

export interface PostConnectionSubscription
  extends Promise<AsyncIterator<PostConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostSubscription>() => T;
}

export interface VideoConnection {
  pageInfo: PageInfo;
  edges: VideoEdge[];
}

export interface VideoConnectionPromise
  extends Promise<VideoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VideoEdge>>() => T;
  aggregate: <T = AggregateVideoPromise>() => T;
}

export interface VideoConnectionSubscription
  extends Promise<AsyncIterator<VideoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VideoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVideoSubscription>() => T;
}

export interface TagSubscriptionPayload {
  mutation: MutationType;
  node: Tag;
  updatedFields: String[];
  previousValues: TagPreviousValues;
}

export interface TagSubscriptionPayloadPromise
  extends Promise<TagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagPreviousValuesPromise>() => T;
}

export interface TagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagPreviousValuesSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface RestoreCodePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  valid_until: DateTimeOutput;
  code: String;
}

export interface RestoreCodePreviousValuesPromise
  extends Promise<RestoreCodePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  valid_until: () => Promise<DateTimeOutput>;
  code: () => Promise<String>;
}

export interface RestoreCodePreviousValuesSubscription
  extends Promise<AsyncIterator<RestoreCodePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  valid_until: () => Promise<AsyncIterator<DateTimeOutput>>;
  code: () => Promise<AsyncIterator<String>>;
}

export interface RestoreCodeSubscriptionPayload {
  mutation: MutationType;
  node: RestoreCode;
  updatedFields: String[];
  previousValues: RestoreCodePreviousValues;
}

export interface RestoreCodeSubscriptionPayloadPromise
  extends Promise<RestoreCodeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RestoreCodePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RestoreCodePreviousValuesPromise>() => T;
}

export interface RestoreCodeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RestoreCodeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RestoreCodeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RestoreCodePreviousValuesSubscription>() => T;
}

export interface AggregateTag {
  count: Int;
}

export interface AggregateTagPromise
  extends Promise<AggregateTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagSubscription
  extends Promise<AsyncIterator<AggregateTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Post {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  mainImageUrl?: String;
  text: String;
}

export interface PostPromise extends Promise<Post>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  mainImageUrl: () => Promise<String>;
  text: () => Promise<String>;
  author: <T = UserPromise>() => T;
}

export interface PostSubscription
  extends Promise<AsyncIterator<Post>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  mainImageUrl: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  author: <T = UserSubscription>() => T;
}

export interface AggregatePost {
  count: Int;
}

export interface AggregatePostPromise
  extends Promise<AggregatePost>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostSubscription
  extends Promise<AsyncIterator<AggregatePost>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RestoreCodeEdge {
  node: RestoreCode;
  cursor: String;
}

export interface RestoreCodeEdgePromise
  extends Promise<RestoreCodeEdge>,
    Fragmentable {
  node: <T = RestoreCodePromise>() => T;
  cursor: () => Promise<String>;
}

export interface RestoreCodeEdgeSubscription
  extends Promise<AsyncIterator<RestoreCodeEdge>>,
    Fragmentable {
  node: <T = RestoreCodeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Json = any;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "ActivationCode",
    embedded: false
  },
  {
    name: "RestoreCode",
    embedded: false
  },
  {
    name: "UserRole",
    embedded: false
  },
  {
    name: "Video",
    embedded: false
  },
  {
    name: "Tag",
    embedded: false
  },
  {
    name: "Category",
    embedded: false
  },
  {
    name: "Post",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
