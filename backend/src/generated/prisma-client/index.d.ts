// Code generated by Prisma (prisma@1.29.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  activationCode: (where?: ActivationCodeWhereInput) => Promise<boolean>;
  artistFactors: (where?: ArtistFactorsWhereInput) => Promise<boolean>;
  artistFactorsSetting: (
    where?: ArtistFactorsSettingWhereInput
  ) => Promise<boolean>;
  category: (where?: CategoryWhereInput) => Promise<boolean>;
  chargeHistory: (where?: ChargeHistoryWhereInput) => Promise<boolean>;
  curriculum: (where?: CurriculumWhereInput) => Promise<boolean>;
  playHistory: (where?: PlayHistoryWhereInput) => Promise<boolean>;
  post: (where?: PostWhereInput) => Promise<boolean>;
  profitPoolCalculation: (
    where?: ProfitPoolCalculationWhereInput
  ) => Promise<boolean>;
  profitPoolFactor: (where?: ProfitPoolFactorWhereInput) => Promise<boolean>;
  promoCode: (where?: PromoCodeWhereInput) => Promise<boolean>;
  restoreCode: (where?: RestoreCodeWhereInput) => Promise<boolean>;
  settings: (where?: SettingsWhereInput) => Promise<boolean>;
  subscriptionHistory: (
    where?: SubscriptionHistoryWhereInput
  ) => Promise<boolean>;
  tag: (where?: TagWhereInput) => Promise<boolean>;
  totalMinutesForArtist: (
    where?: TotalMinutesForArtistWhereInput
  ) => Promise<boolean>;
  transferPlan: (where?: TransferPlanWhereInput) => Promise<boolean>;
  transferTransaction: (
    where?: TransferTransactionWhereInput
  ) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  video: (where?: VideoWhereInput) => Promise<boolean>;
  videoDataForMonth: (where?: VideoDataForMonthWhereInput) => Promise<boolean>;
  videoParameters: (where?: VideoParametersWhereInput) => Promise<boolean>;
  videoParametersForMonth: (
    where?: VideoParametersForMonthWhereInput
  ) => Promise<boolean>;
  videoTotalParameters: (
    where?: VideoTotalParametersWhereInput
  ) => Promise<boolean>;
  watchedVideoUser: (where?: WatchedVideoUserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  activationCode: (
    where: ActivationCodeWhereUniqueInput
  ) => ActivationCodePromise;
  activationCodes: (
    args?: {
      where?: ActivationCodeWhereInput;
      orderBy?: ActivationCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ActivationCode>;
  activationCodesConnection: (
    args?: {
      where?: ActivationCodeWhereInput;
      orderBy?: ActivationCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ActivationCodeConnectionPromise;
  artistFactors: (where: ArtistFactorsWhereUniqueInput) => ArtistFactorsPromise;
  artistFactorses: (
    args?: {
      where?: ArtistFactorsWhereInput;
      orderBy?: ArtistFactorsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ArtistFactors>;
  artistFactorsesConnection: (
    args?: {
      where?: ArtistFactorsWhereInput;
      orderBy?: ArtistFactorsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ArtistFactorsConnectionPromise;
  artistFactorsSetting: (
    where: ArtistFactorsSettingWhereUniqueInput
  ) => ArtistFactorsSettingPromise;
  artistFactorsSettings: (
    args?: {
      where?: ArtistFactorsSettingWhereInput;
      orderBy?: ArtistFactorsSettingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ArtistFactorsSetting>;
  artistFactorsSettingsConnection: (
    args?: {
      where?: ArtistFactorsSettingWhereInput;
      orderBy?: ArtistFactorsSettingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ArtistFactorsSettingConnectionPromise;
  category: (where: CategoryWhereUniqueInput) => CategoryPromise;
  categories: (
    args?: {
      where?: CategoryWhereInput;
      orderBy?: CategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Category>;
  categoriesConnection: (
    args?: {
      where?: CategoryWhereInput;
      orderBy?: CategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CategoryConnectionPromise;
  chargeHistory: (where: ChargeHistoryWhereUniqueInput) => ChargeHistoryPromise;
  chargeHistories: (
    args?: {
      where?: ChargeHistoryWhereInput;
      orderBy?: ChargeHistoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ChargeHistory>;
  chargeHistoriesConnection: (
    args?: {
      where?: ChargeHistoryWhereInput;
      orderBy?: ChargeHistoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ChargeHistoryConnectionPromise;
  curriculum: (where: CurriculumWhereUniqueInput) => CurriculumPromise;
  curricula: (
    args?: {
      where?: CurriculumWhereInput;
      orderBy?: CurriculumOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Curriculum>;
  curriculaConnection: (
    args?: {
      where?: CurriculumWhereInput;
      orderBy?: CurriculumOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CurriculumConnectionPromise;
  playHistory: (where: PlayHistoryWhereUniqueInput) => PlayHistoryPromise;
  playHistories: (
    args?: {
      where?: PlayHistoryWhereInput;
      orderBy?: PlayHistoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PlayHistory>;
  playHistoriesConnection: (
    args?: {
      where?: PlayHistoryWhereInput;
      orderBy?: PlayHistoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PlayHistoryConnectionPromise;
  post: (where: PostWhereUniqueInput) => PostPromise;
  posts: (
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Post>;
  postsConnection: (
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PostConnectionPromise;
  profitPoolCalculation: (
    where: ProfitPoolCalculationWhereUniqueInput
  ) => ProfitPoolCalculationPromise;
  profitPoolCalculations: (
    args?: {
      where?: ProfitPoolCalculationWhereInput;
      orderBy?: ProfitPoolCalculationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProfitPoolCalculation>;
  profitPoolCalculationsConnection: (
    args?: {
      where?: ProfitPoolCalculationWhereInput;
      orderBy?: ProfitPoolCalculationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProfitPoolCalculationConnectionPromise;
  profitPoolFactor: (
    where: ProfitPoolFactorWhereUniqueInput
  ) => ProfitPoolFactorPromise;
  profitPoolFactors: (
    args?: {
      where?: ProfitPoolFactorWhereInput;
      orderBy?: ProfitPoolFactorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProfitPoolFactor>;
  profitPoolFactorsConnection: (
    args?: {
      where?: ProfitPoolFactorWhereInput;
      orderBy?: ProfitPoolFactorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProfitPoolFactorConnectionPromise;
  promoCode: (where: PromoCodeWhereUniqueInput) => PromoCodePromise;
  promoCodes: (
    args?: {
      where?: PromoCodeWhereInput;
      orderBy?: PromoCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PromoCode>;
  promoCodesConnection: (
    args?: {
      where?: PromoCodeWhereInput;
      orderBy?: PromoCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PromoCodeConnectionPromise;
  restoreCode: (where: RestoreCodeWhereUniqueInput) => RestoreCodePromise;
  restoreCodes: (
    args?: {
      where?: RestoreCodeWhereInput;
      orderBy?: RestoreCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<RestoreCode>;
  restoreCodesConnection: (
    args?: {
      where?: RestoreCodeWhereInput;
      orderBy?: RestoreCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RestoreCodeConnectionPromise;
  settings: (where: SettingsWhereUniqueInput) => SettingsPromise;
  settingses: (
    args?: {
      where?: SettingsWhereInput;
      orderBy?: SettingsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Settings>;
  settingsesConnection: (
    args?: {
      where?: SettingsWhereInput;
      orderBy?: SettingsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SettingsConnectionPromise;
  subscriptionHistory: (
    where: SubscriptionHistoryWhereUniqueInput
  ) => SubscriptionHistoryPromise;
  subscriptionHistories: (
    args?: {
      where?: SubscriptionHistoryWhereInput;
      orderBy?: SubscriptionHistoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SubscriptionHistory>;
  subscriptionHistoriesConnection: (
    args?: {
      where?: SubscriptionHistoryWhereInput;
      orderBy?: SubscriptionHistoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SubscriptionHistoryConnectionPromise;
  tag: (where: TagWhereUniqueInput) => TagPromise;
  tags: (
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Tag>;
  tagsConnection: (
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TagConnectionPromise;
  totalMinutesForArtist: (
    where: TotalMinutesForArtistWhereUniqueInput
  ) => TotalMinutesForArtistPromise;
  totalMinutesForArtists: (
    args?: {
      where?: TotalMinutesForArtistWhereInput;
      orderBy?: TotalMinutesForArtistOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<TotalMinutesForArtist>;
  totalMinutesForArtistsConnection: (
    args?: {
      where?: TotalMinutesForArtistWhereInput;
      orderBy?: TotalMinutesForArtistOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TotalMinutesForArtistConnectionPromise;
  transferPlan: (where: TransferPlanWhereUniqueInput) => TransferPlanPromise;
  transferPlans: (
    args?: {
      where?: TransferPlanWhereInput;
      orderBy?: TransferPlanOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<TransferPlan>;
  transferPlansConnection: (
    args?: {
      where?: TransferPlanWhereInput;
      orderBy?: TransferPlanOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TransferPlanConnectionPromise;
  transferTransaction: (
    where: TransferTransactionWhereUniqueInput
  ) => TransferTransactionPromise;
  transferTransactions: (
    args?: {
      where?: TransferTransactionWhereInput;
      orderBy?: TransferTransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<TransferTransaction>;
  transferTransactionsConnection: (
    args?: {
      where?: TransferTransactionWhereInput;
      orderBy?: TransferTransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TransferTransactionConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  video: (where: VideoWhereUniqueInput) => VideoPromise;
  videos: (
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Video>;
  videosConnection: (
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VideoConnectionPromise;
  videoDataForMonth: (
    where: VideoDataForMonthWhereUniqueInput
  ) => VideoDataForMonthPromise;
  videoDataForMonths: (
    args?: {
      where?: VideoDataForMonthWhereInput;
      orderBy?: VideoDataForMonthOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<VideoDataForMonth>;
  videoDataForMonthsConnection: (
    args?: {
      where?: VideoDataForMonthWhereInput;
      orderBy?: VideoDataForMonthOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VideoDataForMonthConnectionPromise;
  videoParameters: (
    where: VideoParametersWhereUniqueInput
  ) => VideoParametersPromise;
  videoParameterses: (
    args?: {
      where?: VideoParametersWhereInput;
      orderBy?: VideoParametersOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<VideoParameters>;
  videoParametersesConnection: (
    args?: {
      where?: VideoParametersWhereInput;
      orderBy?: VideoParametersOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VideoParametersConnectionPromise;
  videoParametersForMonth: (
    where: VideoParametersForMonthWhereUniqueInput
  ) => VideoParametersForMonthPromise;
  videoParametersForMonths: (
    args?: {
      where?: VideoParametersForMonthWhereInput;
      orderBy?: VideoParametersForMonthOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<VideoParametersForMonth>;
  videoParametersForMonthsConnection: (
    args?: {
      where?: VideoParametersForMonthWhereInput;
      orderBy?: VideoParametersForMonthOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VideoParametersForMonthConnectionPromise;
  videoTotalParameters: (
    where: VideoTotalParametersWhereUniqueInput
  ) => VideoTotalParametersPromise;
  videoTotalParameterses: (
    args?: {
      where?: VideoTotalParametersWhereInput;
      orderBy?: VideoTotalParametersOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<VideoTotalParameters>;
  videoTotalParametersesConnection: (
    args?: {
      where?: VideoTotalParametersWhereInput;
      orderBy?: VideoTotalParametersOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VideoTotalParametersConnectionPromise;
  watchedVideoUser: (
    where: WatchedVideoUserWhereUniqueInput
  ) => WatchedVideoUserPromise;
  watchedVideoUsers: (
    args?: {
      where?: WatchedVideoUserWhereInput;
      orderBy?: WatchedVideoUserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<WatchedVideoUser>;
  watchedVideoUsersConnection: (
    args?: {
      where?: WatchedVideoUserWhereInput;
      orderBy?: WatchedVideoUserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => WatchedVideoUserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createActivationCode: (
    data: ActivationCodeCreateInput
  ) => ActivationCodePromise;
  updateActivationCode: (
    args: {
      data: ActivationCodeUpdateInput;
      where: ActivationCodeWhereUniqueInput;
    }
  ) => ActivationCodePromise;
  updateManyActivationCodes: (
    args: {
      data: ActivationCodeUpdateManyMutationInput;
      where?: ActivationCodeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertActivationCode: (
    args: {
      where: ActivationCodeWhereUniqueInput;
      create: ActivationCodeCreateInput;
      update: ActivationCodeUpdateInput;
    }
  ) => ActivationCodePromise;
  deleteActivationCode: (
    where: ActivationCodeWhereUniqueInput
  ) => ActivationCodePromise;
  deleteManyActivationCodes: (
    where?: ActivationCodeWhereInput
  ) => BatchPayloadPromise;
  createArtistFactors: (data: ArtistFactorsCreateInput) => ArtistFactorsPromise;
  updateArtistFactors: (
    args: {
      data: ArtistFactorsUpdateInput;
      where: ArtistFactorsWhereUniqueInput;
    }
  ) => ArtistFactorsPromise;
  updateManyArtistFactorses: (
    args: {
      data: ArtistFactorsUpdateManyMutationInput;
      where?: ArtistFactorsWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertArtistFactors: (
    args: {
      where: ArtistFactorsWhereUniqueInput;
      create: ArtistFactorsCreateInput;
      update: ArtistFactorsUpdateInput;
    }
  ) => ArtistFactorsPromise;
  deleteArtistFactors: (
    where: ArtistFactorsWhereUniqueInput
  ) => ArtistFactorsPromise;
  deleteManyArtistFactorses: (
    where?: ArtistFactorsWhereInput
  ) => BatchPayloadPromise;
  createArtistFactorsSetting: (
    data: ArtistFactorsSettingCreateInput
  ) => ArtistFactorsSettingPromise;
  updateArtistFactorsSetting: (
    args: {
      data: ArtistFactorsSettingUpdateInput;
      where: ArtistFactorsSettingWhereUniqueInput;
    }
  ) => ArtistFactorsSettingPromise;
  updateManyArtistFactorsSettings: (
    args: {
      data: ArtistFactorsSettingUpdateManyMutationInput;
      where?: ArtistFactorsSettingWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertArtistFactorsSetting: (
    args: {
      where: ArtistFactorsSettingWhereUniqueInput;
      create: ArtistFactorsSettingCreateInput;
      update: ArtistFactorsSettingUpdateInput;
    }
  ) => ArtistFactorsSettingPromise;
  deleteArtistFactorsSetting: (
    where: ArtistFactorsSettingWhereUniqueInput
  ) => ArtistFactorsSettingPromise;
  deleteManyArtistFactorsSettings: (
    where?: ArtistFactorsSettingWhereInput
  ) => BatchPayloadPromise;
  createCategory: (data: CategoryCreateInput) => CategoryPromise;
  updateCategory: (
    args: { data: CategoryUpdateInput; where: CategoryWhereUniqueInput }
  ) => CategoryPromise;
  updateManyCategories: (
    args: { data: CategoryUpdateManyMutationInput; where?: CategoryWhereInput }
  ) => BatchPayloadPromise;
  upsertCategory: (
    args: {
      where: CategoryWhereUniqueInput;
      create: CategoryCreateInput;
      update: CategoryUpdateInput;
    }
  ) => CategoryPromise;
  deleteCategory: (where: CategoryWhereUniqueInput) => CategoryPromise;
  deleteManyCategories: (where?: CategoryWhereInput) => BatchPayloadPromise;
  createChargeHistory: (data: ChargeHistoryCreateInput) => ChargeHistoryPromise;
  updateChargeHistory: (
    args: {
      data: ChargeHistoryUpdateInput;
      where: ChargeHistoryWhereUniqueInput;
    }
  ) => ChargeHistoryPromise;
  updateManyChargeHistories: (
    args: {
      data: ChargeHistoryUpdateManyMutationInput;
      where?: ChargeHistoryWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertChargeHistory: (
    args: {
      where: ChargeHistoryWhereUniqueInput;
      create: ChargeHistoryCreateInput;
      update: ChargeHistoryUpdateInput;
    }
  ) => ChargeHistoryPromise;
  deleteChargeHistory: (
    where: ChargeHistoryWhereUniqueInput
  ) => ChargeHistoryPromise;
  deleteManyChargeHistories: (
    where?: ChargeHistoryWhereInput
  ) => BatchPayloadPromise;
  createCurriculum: (data: CurriculumCreateInput) => CurriculumPromise;
  updateCurriculum: (
    args: { data: CurriculumUpdateInput; where: CurriculumWhereUniqueInput }
  ) => CurriculumPromise;
  updateManyCurricula: (
    args: {
      data: CurriculumUpdateManyMutationInput;
      where?: CurriculumWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCurriculum: (
    args: {
      where: CurriculumWhereUniqueInput;
      create: CurriculumCreateInput;
      update: CurriculumUpdateInput;
    }
  ) => CurriculumPromise;
  deleteCurriculum: (where: CurriculumWhereUniqueInput) => CurriculumPromise;
  deleteManyCurricula: (where?: CurriculumWhereInput) => BatchPayloadPromise;
  createPlayHistory: (data: PlayHistoryCreateInput) => PlayHistoryPromise;
  updatePlayHistory: (
    args: { data: PlayHistoryUpdateInput; where: PlayHistoryWhereUniqueInput }
  ) => PlayHistoryPromise;
  updateManyPlayHistories: (
    args: {
      data: PlayHistoryUpdateManyMutationInput;
      where?: PlayHistoryWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPlayHistory: (
    args: {
      where: PlayHistoryWhereUniqueInput;
      create: PlayHistoryCreateInput;
      update: PlayHistoryUpdateInput;
    }
  ) => PlayHistoryPromise;
  deletePlayHistory: (where: PlayHistoryWhereUniqueInput) => PlayHistoryPromise;
  deleteManyPlayHistories: (
    where?: PlayHistoryWhereInput
  ) => BatchPayloadPromise;
  createPost: (data: PostCreateInput) => PostPromise;
  updatePost: (
    args: { data: PostUpdateInput; where: PostWhereUniqueInput }
  ) => PostPromise;
  updateManyPosts: (
    args: { data: PostUpdateManyMutationInput; where?: PostWhereInput }
  ) => BatchPayloadPromise;
  upsertPost: (
    args: {
      where: PostWhereUniqueInput;
      create: PostCreateInput;
      update: PostUpdateInput;
    }
  ) => PostPromise;
  deletePost: (where: PostWhereUniqueInput) => PostPromise;
  deleteManyPosts: (where?: PostWhereInput) => BatchPayloadPromise;
  createProfitPoolCalculation: (
    data: ProfitPoolCalculationCreateInput
  ) => ProfitPoolCalculationPromise;
  updateProfitPoolCalculation: (
    args: {
      data: ProfitPoolCalculationUpdateInput;
      where: ProfitPoolCalculationWhereUniqueInput;
    }
  ) => ProfitPoolCalculationPromise;
  updateManyProfitPoolCalculations: (
    args: {
      data: ProfitPoolCalculationUpdateManyMutationInput;
      where?: ProfitPoolCalculationWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertProfitPoolCalculation: (
    args: {
      where: ProfitPoolCalculationWhereUniqueInput;
      create: ProfitPoolCalculationCreateInput;
      update: ProfitPoolCalculationUpdateInput;
    }
  ) => ProfitPoolCalculationPromise;
  deleteProfitPoolCalculation: (
    where: ProfitPoolCalculationWhereUniqueInput
  ) => ProfitPoolCalculationPromise;
  deleteManyProfitPoolCalculations: (
    where?: ProfitPoolCalculationWhereInput
  ) => BatchPayloadPromise;
  createProfitPoolFactor: (
    data: ProfitPoolFactorCreateInput
  ) => ProfitPoolFactorPromise;
  updateProfitPoolFactor: (
    args: {
      data: ProfitPoolFactorUpdateInput;
      where: ProfitPoolFactorWhereUniqueInput;
    }
  ) => ProfitPoolFactorPromise;
  updateManyProfitPoolFactors: (
    args: {
      data: ProfitPoolFactorUpdateManyMutationInput;
      where?: ProfitPoolFactorWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertProfitPoolFactor: (
    args: {
      where: ProfitPoolFactorWhereUniqueInput;
      create: ProfitPoolFactorCreateInput;
      update: ProfitPoolFactorUpdateInput;
    }
  ) => ProfitPoolFactorPromise;
  deleteProfitPoolFactor: (
    where: ProfitPoolFactorWhereUniqueInput
  ) => ProfitPoolFactorPromise;
  deleteManyProfitPoolFactors: (
    where?: ProfitPoolFactorWhereInput
  ) => BatchPayloadPromise;
  createPromoCode: (data: PromoCodeCreateInput) => PromoCodePromise;
  updatePromoCode: (
    args: { data: PromoCodeUpdateInput; where: PromoCodeWhereUniqueInput }
  ) => PromoCodePromise;
  updateManyPromoCodes: (
    args: {
      data: PromoCodeUpdateManyMutationInput;
      where?: PromoCodeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPromoCode: (
    args: {
      where: PromoCodeWhereUniqueInput;
      create: PromoCodeCreateInput;
      update: PromoCodeUpdateInput;
    }
  ) => PromoCodePromise;
  deletePromoCode: (where: PromoCodeWhereUniqueInput) => PromoCodePromise;
  deleteManyPromoCodes: (where?: PromoCodeWhereInput) => BatchPayloadPromise;
  createRestoreCode: (data: RestoreCodeCreateInput) => RestoreCodePromise;
  updateRestoreCode: (
    args: { data: RestoreCodeUpdateInput; where: RestoreCodeWhereUniqueInput }
  ) => RestoreCodePromise;
  updateManyRestoreCodes: (
    args: {
      data: RestoreCodeUpdateManyMutationInput;
      where?: RestoreCodeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertRestoreCode: (
    args: {
      where: RestoreCodeWhereUniqueInput;
      create: RestoreCodeCreateInput;
      update: RestoreCodeUpdateInput;
    }
  ) => RestoreCodePromise;
  deleteRestoreCode: (where: RestoreCodeWhereUniqueInput) => RestoreCodePromise;
  deleteManyRestoreCodes: (
    where?: RestoreCodeWhereInput
  ) => BatchPayloadPromise;
  createSettings: (data: SettingsCreateInput) => SettingsPromise;
  updateSettings: (
    args: { data: SettingsUpdateInput; where: SettingsWhereUniqueInput }
  ) => SettingsPromise;
  updateManySettingses: (
    args: { data: SettingsUpdateManyMutationInput; where?: SettingsWhereInput }
  ) => BatchPayloadPromise;
  upsertSettings: (
    args: {
      where: SettingsWhereUniqueInput;
      create: SettingsCreateInput;
      update: SettingsUpdateInput;
    }
  ) => SettingsPromise;
  deleteSettings: (where: SettingsWhereUniqueInput) => SettingsPromise;
  deleteManySettingses: (where?: SettingsWhereInput) => BatchPayloadPromise;
  createSubscriptionHistory: (
    data: SubscriptionHistoryCreateInput
  ) => SubscriptionHistoryPromise;
  updateSubscriptionHistory: (
    args: {
      data: SubscriptionHistoryUpdateInput;
      where: SubscriptionHistoryWhereUniqueInput;
    }
  ) => SubscriptionHistoryPromise;
  updateManySubscriptionHistories: (
    args: {
      data: SubscriptionHistoryUpdateManyMutationInput;
      where?: SubscriptionHistoryWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSubscriptionHistory: (
    args: {
      where: SubscriptionHistoryWhereUniqueInput;
      create: SubscriptionHistoryCreateInput;
      update: SubscriptionHistoryUpdateInput;
    }
  ) => SubscriptionHistoryPromise;
  deleteSubscriptionHistory: (
    where: SubscriptionHistoryWhereUniqueInput
  ) => SubscriptionHistoryPromise;
  deleteManySubscriptionHistories: (
    where?: SubscriptionHistoryWhereInput
  ) => BatchPayloadPromise;
  createTag: (data: TagCreateInput) => TagPromise;
  updateTag: (
    args: { data: TagUpdateInput; where: TagWhereUniqueInput }
  ) => TagPromise;
  updateManyTags: (
    args: { data: TagUpdateManyMutationInput; where?: TagWhereInput }
  ) => BatchPayloadPromise;
  upsertTag: (
    args: {
      where: TagWhereUniqueInput;
      create: TagCreateInput;
      update: TagUpdateInput;
    }
  ) => TagPromise;
  deleteTag: (where: TagWhereUniqueInput) => TagPromise;
  deleteManyTags: (where?: TagWhereInput) => BatchPayloadPromise;
  createTotalMinutesForArtist: (
    data: TotalMinutesForArtistCreateInput
  ) => TotalMinutesForArtistPromise;
  updateTotalMinutesForArtist: (
    args: {
      data: TotalMinutesForArtistUpdateInput;
      where: TotalMinutesForArtistWhereUniqueInput;
    }
  ) => TotalMinutesForArtistPromise;
  updateManyTotalMinutesForArtists: (
    args: {
      data: TotalMinutesForArtistUpdateManyMutationInput;
      where?: TotalMinutesForArtistWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertTotalMinutesForArtist: (
    args: {
      where: TotalMinutesForArtistWhereUniqueInput;
      create: TotalMinutesForArtistCreateInput;
      update: TotalMinutesForArtistUpdateInput;
    }
  ) => TotalMinutesForArtistPromise;
  deleteTotalMinutesForArtist: (
    where: TotalMinutesForArtistWhereUniqueInput
  ) => TotalMinutesForArtistPromise;
  deleteManyTotalMinutesForArtists: (
    where?: TotalMinutesForArtistWhereInput
  ) => BatchPayloadPromise;
  createTransferPlan: (data: TransferPlanCreateInput) => TransferPlanPromise;
  updateTransferPlan: (
    args: { data: TransferPlanUpdateInput; where: TransferPlanWhereUniqueInput }
  ) => TransferPlanPromise;
  updateManyTransferPlans: (
    args: {
      data: TransferPlanUpdateManyMutationInput;
      where?: TransferPlanWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertTransferPlan: (
    args: {
      where: TransferPlanWhereUniqueInput;
      create: TransferPlanCreateInput;
      update: TransferPlanUpdateInput;
    }
  ) => TransferPlanPromise;
  deleteTransferPlan: (
    where: TransferPlanWhereUniqueInput
  ) => TransferPlanPromise;
  deleteManyTransferPlans: (
    where?: TransferPlanWhereInput
  ) => BatchPayloadPromise;
  createTransferTransaction: (
    data: TransferTransactionCreateInput
  ) => TransferTransactionPromise;
  updateTransferTransaction: (
    args: {
      data: TransferTransactionUpdateInput;
      where: TransferTransactionWhereUniqueInput;
    }
  ) => TransferTransactionPromise;
  updateManyTransferTransactions: (
    args: {
      data: TransferTransactionUpdateManyMutationInput;
      where?: TransferTransactionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertTransferTransaction: (
    args: {
      where: TransferTransactionWhereUniqueInput;
      create: TransferTransactionCreateInput;
      update: TransferTransactionUpdateInput;
    }
  ) => TransferTransactionPromise;
  deleteTransferTransaction: (
    where: TransferTransactionWhereUniqueInput
  ) => TransferTransactionPromise;
  deleteManyTransferTransactions: (
    where?: TransferTransactionWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createVideo: (data: VideoCreateInput) => VideoPromise;
  updateVideo: (
    args: { data: VideoUpdateInput; where: VideoWhereUniqueInput }
  ) => VideoPromise;
  updateManyVideos: (
    args: { data: VideoUpdateManyMutationInput; where?: VideoWhereInput }
  ) => BatchPayloadPromise;
  upsertVideo: (
    args: {
      where: VideoWhereUniqueInput;
      create: VideoCreateInput;
      update: VideoUpdateInput;
    }
  ) => VideoPromise;
  deleteVideo: (where: VideoWhereUniqueInput) => VideoPromise;
  deleteManyVideos: (where?: VideoWhereInput) => BatchPayloadPromise;
  createVideoDataForMonth: (
    data: VideoDataForMonthCreateInput
  ) => VideoDataForMonthPromise;
  updateVideoDataForMonth: (
    args: {
      data: VideoDataForMonthUpdateInput;
      where: VideoDataForMonthWhereUniqueInput;
    }
  ) => VideoDataForMonthPromise;
  updateManyVideoDataForMonths: (
    args: {
      data: VideoDataForMonthUpdateManyMutationInput;
      where?: VideoDataForMonthWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertVideoDataForMonth: (
    args: {
      where: VideoDataForMonthWhereUniqueInput;
      create: VideoDataForMonthCreateInput;
      update: VideoDataForMonthUpdateInput;
    }
  ) => VideoDataForMonthPromise;
  deleteVideoDataForMonth: (
    where: VideoDataForMonthWhereUniqueInput
  ) => VideoDataForMonthPromise;
  deleteManyVideoDataForMonths: (
    where?: VideoDataForMonthWhereInput
  ) => BatchPayloadPromise;
  createVideoParameters: (
    data: VideoParametersCreateInput
  ) => VideoParametersPromise;
  updateVideoParameters: (
    args: {
      data: VideoParametersUpdateInput;
      where: VideoParametersWhereUniqueInput;
    }
  ) => VideoParametersPromise;
  updateManyVideoParameterses: (
    args: {
      data: VideoParametersUpdateManyMutationInput;
      where?: VideoParametersWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertVideoParameters: (
    args: {
      where: VideoParametersWhereUniqueInput;
      create: VideoParametersCreateInput;
      update: VideoParametersUpdateInput;
    }
  ) => VideoParametersPromise;
  deleteVideoParameters: (
    where: VideoParametersWhereUniqueInput
  ) => VideoParametersPromise;
  deleteManyVideoParameterses: (
    where?: VideoParametersWhereInput
  ) => BatchPayloadPromise;
  createVideoParametersForMonth: (
    data: VideoParametersForMonthCreateInput
  ) => VideoParametersForMonthPromise;
  updateVideoParametersForMonth: (
    args: {
      data: VideoParametersForMonthUpdateInput;
      where: VideoParametersForMonthWhereUniqueInput;
    }
  ) => VideoParametersForMonthPromise;
  updateManyVideoParametersForMonths: (
    args: {
      data: VideoParametersForMonthUpdateManyMutationInput;
      where?: VideoParametersForMonthWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertVideoParametersForMonth: (
    args: {
      where: VideoParametersForMonthWhereUniqueInput;
      create: VideoParametersForMonthCreateInput;
      update: VideoParametersForMonthUpdateInput;
    }
  ) => VideoParametersForMonthPromise;
  deleteVideoParametersForMonth: (
    where: VideoParametersForMonthWhereUniqueInput
  ) => VideoParametersForMonthPromise;
  deleteManyVideoParametersForMonths: (
    where?: VideoParametersForMonthWhereInput
  ) => BatchPayloadPromise;
  createVideoTotalParameters: (
    data: VideoTotalParametersCreateInput
  ) => VideoTotalParametersPromise;
  updateVideoTotalParameters: (
    args: {
      data: VideoTotalParametersUpdateInput;
      where: VideoTotalParametersWhereUniqueInput;
    }
  ) => VideoTotalParametersPromise;
  updateManyVideoTotalParameterses: (
    args: {
      data: VideoTotalParametersUpdateManyMutationInput;
      where?: VideoTotalParametersWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertVideoTotalParameters: (
    args: {
      where: VideoTotalParametersWhereUniqueInput;
      create: VideoTotalParametersCreateInput;
      update: VideoTotalParametersUpdateInput;
    }
  ) => VideoTotalParametersPromise;
  deleteVideoTotalParameters: (
    where: VideoTotalParametersWhereUniqueInput
  ) => VideoTotalParametersPromise;
  deleteManyVideoTotalParameterses: (
    where?: VideoTotalParametersWhereInput
  ) => BatchPayloadPromise;
  createWatchedVideoUser: (
    data: WatchedVideoUserCreateInput
  ) => WatchedVideoUserPromise;
  updateWatchedVideoUser: (
    args: {
      data: WatchedVideoUserUpdateInput;
      where: WatchedVideoUserWhereUniqueInput;
    }
  ) => WatchedVideoUserPromise;
  updateManyWatchedVideoUsers: (
    args: {
      data: WatchedVideoUserUpdateManyMutationInput;
      where?: WatchedVideoUserWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertWatchedVideoUser: (
    args: {
      where: WatchedVideoUserWhereUniqueInput;
      create: WatchedVideoUserCreateInput;
      update: WatchedVideoUserUpdateInput;
    }
  ) => WatchedVideoUserPromise;
  deleteWatchedVideoUser: (
    where: WatchedVideoUserWhereUniqueInput
  ) => WatchedVideoUserPromise;
  deleteManyWatchedVideoUsers: (
    where?: WatchedVideoUserWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  activationCode: (
    where?: ActivationCodeSubscriptionWhereInput
  ) => ActivationCodeSubscriptionPayloadSubscription;
  artistFactors: (
    where?: ArtistFactorsSubscriptionWhereInput
  ) => ArtistFactorsSubscriptionPayloadSubscription;
  artistFactorsSetting: (
    where?: ArtistFactorsSettingSubscriptionWhereInput
  ) => ArtistFactorsSettingSubscriptionPayloadSubscription;
  category: (
    where?: CategorySubscriptionWhereInput
  ) => CategorySubscriptionPayloadSubscription;
  chargeHistory: (
    where?: ChargeHistorySubscriptionWhereInput
  ) => ChargeHistorySubscriptionPayloadSubscription;
  curriculum: (
    where?: CurriculumSubscriptionWhereInput
  ) => CurriculumSubscriptionPayloadSubscription;
  playHistory: (
    where?: PlayHistorySubscriptionWhereInput
  ) => PlayHistorySubscriptionPayloadSubscription;
  post: (
    where?: PostSubscriptionWhereInput
  ) => PostSubscriptionPayloadSubscription;
  profitPoolCalculation: (
    where?: ProfitPoolCalculationSubscriptionWhereInput
  ) => ProfitPoolCalculationSubscriptionPayloadSubscription;
  profitPoolFactor: (
    where?: ProfitPoolFactorSubscriptionWhereInput
  ) => ProfitPoolFactorSubscriptionPayloadSubscription;
  promoCode: (
    where?: PromoCodeSubscriptionWhereInput
  ) => PromoCodeSubscriptionPayloadSubscription;
  restoreCode: (
    where?: RestoreCodeSubscriptionWhereInput
  ) => RestoreCodeSubscriptionPayloadSubscription;
  settings: (
    where?: SettingsSubscriptionWhereInput
  ) => SettingsSubscriptionPayloadSubscription;
  subscriptionHistory: (
    where?: SubscriptionHistorySubscriptionWhereInput
  ) => SubscriptionHistorySubscriptionPayloadSubscription;
  tag: (
    where?: TagSubscriptionWhereInput
  ) => TagSubscriptionPayloadSubscription;
  totalMinutesForArtist: (
    where?: TotalMinutesForArtistSubscriptionWhereInput
  ) => TotalMinutesForArtistSubscriptionPayloadSubscription;
  transferPlan: (
    where?: TransferPlanSubscriptionWhereInput
  ) => TransferPlanSubscriptionPayloadSubscription;
  transferTransaction: (
    where?: TransferTransactionSubscriptionWhereInput
  ) => TransferTransactionSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  video: (
    where?: VideoSubscriptionWhereInput
  ) => VideoSubscriptionPayloadSubscription;
  videoDataForMonth: (
    where?: VideoDataForMonthSubscriptionWhereInput
  ) => VideoDataForMonthSubscriptionPayloadSubscription;
  videoParameters: (
    where?: VideoParametersSubscriptionWhereInput
  ) => VideoParametersSubscriptionPayloadSubscription;
  videoParametersForMonth: (
    where?: VideoParametersForMonthSubscriptionWhereInput
  ) => VideoParametersForMonthSubscriptionPayloadSubscription;
  videoTotalParameters: (
    where?: VideoTotalParametersSubscriptionWhereInput
  ) => VideoTotalParametersSubscriptionPayloadSubscription;
  watchedVideoUser: (
    where?: WatchedVideoUserSubscriptionWhereInput
  ) => WatchedVideoUserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ActivationCodeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "valid_until_ASC"
  | "valid_until_DESC"
  | "code_ASC"
  | "code_DESC";

export type UserRole =
  | "USER_VIEWER"
  | "USER_PUBLISHER"
  | "MODERATOR"
  | "ADMIN"
  | "MFA";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "firstname_ASC"
  | "firstname_DESC"
  | "lastname_ASC"
  | "lastname_DESC"
  | "username_ASC"
  | "username_DESC"
  | "email_ASC"
  | "email_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "role_ASC"
  | "role_DESC"
  | "approved_ASC"
  | "approved_DESC"
  | "password_hash_ASC"
  | "password_hash_DESC"
  | "password_salt_ASC"
  | "password_salt_DESC"
  | "avatar_ASC"
  | "avatar_DESC"
  | "background_image_ASC"
  | "background_image_DESC"
  | "about_text_ASC"
  | "about_text_DESC"
  | "payout_amount_ASC"
  | "payout_amount_DESC"
  | "payout_months_total_ASC"
  | "payout_months_total_DESC"
  | "payout_months_left_ASC"
  | "payout_months_left_DESC"
  | "payout_enabled_ASC"
  | "payout_enabled_DESC"
  | "front_id_scan_ASC"
  | "front_id_scan_DESC"
  | "back_id_scan_ASC"
  | "back_id_scan_DESC"
  | "billing_subscription_active_ASC"
  | "billing_subscription_active_DESC"
  | "stripe_customer_id_ASC"
  | "stripe_customer_id_DESC"
  | "stripe_subsciption_json_ASC"
  | "stripe_subsciption_json_DESC"
  | "last_login_date_ASC"
  | "last_login_date_DESC";

export type VideoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "publish_date_ASC"
  | "publish_date_DESC"
  | "file_url_ASC"
  | "file_url_DESC"
  | "video_duration_ASC"
  | "video_duration_DESC"
  | "preview_url_ASC"
  | "preview_url_DESC"
  | "preview_video_url_ASC"
  | "preview_video_url_DESC"
  | "preview_video_duration_ASC"
  | "preview_video_duration_DESC"
  | "deleted_ASC"
  | "deleted_DESC";

export type CategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC";

export type WatchedVideoUserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "watched_seconds_ASC"
  | "watched_seconds_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TagOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "text_ASC"
  | "text_DESC";

export type PromoCodeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "promo_code_ASC"
  | "promo_code_DESC"
  | "current_promo_code_ASC"
  | "current_promo_code_DESC";

export type ArtistFactorsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "promotion_factor_ASC"
  | "promotion_factor_DESC"
  | "minutes_exponent_ASC"
  | "minutes_exponent_DESC"
  | "finder_fee_factor_ASC"
  | "finder_fee_factor_DESC"
  | "monthly_fee_duration_ASC"
  | "monthly_fee_duration_DESC"
  | "monthly_fee_amount_per_month_ASC"
  | "monthly_fee_amount_per_month_DESC"
  | "annual_fee_amount_per_month_ASC"
  | "annual_fee_amount_per_month_DESC";

export type ArtistFactorsSettingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "promotion_factor_ASC"
  | "promotion_factor_DESC"
  | "minutes_exponent_ASC"
  | "minutes_exponent_DESC"
  | "finder_fee_factor_ASC"
  | "finder_fee_factor_DESC"
  | "monthly_fee_duration_ASC"
  | "monthly_fee_duration_DESC"
  | "monthly_fee_amount_per_month_ASC"
  | "monthly_fee_amount_per_month_DESC"
  | "annual_fee_amount_per_month_ASC"
  | "annual_fee_amount_per_month_DESC";

export type ChargeHistoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "chargeDate_ASC"
  | "chargeDate_DESC"
  | "chargeId_ASC"
  | "chargeId_DESC"
  | "refunded_ASC"
  | "refunded_DESC";

export type CurriculumOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "text_ASC"
  | "text_DESC"
  | "order_ASC"
  | "order_DESC";

export type PlayHistoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "playSeconds_ASC"
  | "playSeconds_DESC"
  | "realPlaySeconds_ASC"
  | "realPlaySeconds_DESC";

export type PostOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "mainImageUrl_ASC"
  | "mainImageUrl_DESC"
  | "text_ASC"
  | "text_DESC";

export type ProfitPoolCalculationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "year_ASC"
  | "year_DESC"
  | "month_ASC"
  | "month_DESC"
  | "annual_active_subscribers_ASC"
  | "annual_active_subscribers_DESC"
  | "monthly_active_subscribers_ASC"
  | "monthly_active_subscribers_DESC"
  | "annual_subscription_rate_ASC"
  | "annual_subscription_rate_DESC"
  | "monthly_subscription_rate_ASC"
  | "monthly_subscription_rate_DESC"
  | "annual_pool_revenue_ASC"
  | "annual_pool_revenue_DESC"
  | "monthly_pool_revenue_ASC"
  | "monthly_pool_revenue_DESC"
  | "total_revenue_ASC"
  | "total_revenue_DESC"
  | "total_payment_to_artists_ASC"
  | "total_payment_to_artists_DESC"
  | "net_revenue_ASC"
  | "net_revenue_DESC";

export type ProfitPoolFactorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "overhead_ASC"
  | "overhead_DESC"
  | "monthly_multiplier_ASC"
  | "monthly_multiplier_DESC"
  | "finder_fee_multiplier_ASC"
  | "finder_fee_multiplier_DESC"
  | "profit_pool_option1_variable_ASC"
  | "profit_pool_option1_variable_DESC"
  | "profit_pool_option1_multiplier_ASC"
  | "profit_pool_option1_multiplier_DESC"
  | "profit_pool_option2_variable_ASC"
  | "profit_pool_option2_variable_DESC"
  | "profit_pool_option2_multiplier_ASC"
  | "profit_pool_option2_multiplier_DESC"
  | "profit_pool_percentage_ASC"
  | "profit_pool_percentage_DESC"
  | "manual_change_ASC"
  | "manual_change_DESC";

export type RestoreCodeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "valid_until_ASC"
  | "valid_until_DESC"
  | "code_ASC"
  | "code_DESC";

export type SettingsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "int_val_ASC"
  | "int_val_DESC"
  | "str_val_ASC"
  | "str_val_DESC";

export type SubscriptionHistoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "interval_ASC"
  | "interval_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "subscriptionDate_ASC"
  | "subscriptionDate_DESC";

export type TotalMinutesForArtistOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "year_ASC"
  | "year_DESC"
  | "month_ASC"
  | "month_DESC"
  | "minutes_as_owner1_ASC"
  | "minutes_as_owner1_DESC"
  | "minutes_as_owner2_ASC"
  | "minutes_as_owner2_DESC"
  | "minutes_as_owner3_ASC"
  | "minutes_as_owner3_DESC"
  | "total_minutes_ASC"
  | "total_minutes_DESC"
  | "artist_rating_factor_ASC"
  | "artist_rating_factor_DESC"
  | "final_minutes_ASC"
  | "final_minutes_DESC"
  | "percent_of_profit_pool_ASC"
  | "percent_of_profit_pool_DESC"
  | "monthly_quantity_ASC"
  | "monthly_quantity_DESC"
  | "annual_quantity_ASC"
  | "annual_quantity_DESC"
  | "finder_fee_ASC"
  | "finder_fee_DESC"
  | "payment_from_profit_pool_ASC"
  | "payment_from_profit_pool_DESC"
  | "total_payment_ASC"
  | "total_payment_DESC";

export type TransferPlanOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "year_ASC"
  | "year_DESC"
  | "month_ASC"
  | "month_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "ignore_status_ASC"
  | "ignore_status_DESC"
  | "paid_status_ASC"
  | "paid_status_DESC"
  | "paid_date_ASC"
  | "paid_date_DESC";

export type TransferTransactionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "year_ASC"
  | "year_DESC"
  | "month_ASC"
  | "month_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "paid_status_ASC"
  | "paid_status_DESC"
  | "paid_date_ASC"
  | "paid_date_DESC";

export type VideoDataForMonthOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "year_ASC"
  | "year_DESC"
  | "month_ASC"
  | "month_DESC"
  | "video_length_ASC"
  | "video_length_DESC"
  | "unique_users_ASC"
  | "unique_users_DESC"
  | "real_minutes_watched_ASC"
  | "real_minutes_watched_DESC"
  | "avg_minutes_watched_ASC"
  | "avg_minutes_watched_DESC"
  | "exponent_applied_ASC"
  | "exponent_applied_DESC"
  | "minutes_after_exponent_ASC"
  | "minutes_after_exponent_DESC";

export type VideoParametersOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "owner1_percentage_ASC"
  | "owner1_percentage_DESC"
  | "owner2_percentage_ASC"
  | "owner2_percentage_DESC"
  | "owner3_percentage_ASC"
  | "owner3_percentage_DESC";

export type VideoParametersForMonthOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "year_ASC"
  | "year_DESC"
  | "month_ASC"
  | "month_DESC"
  | "owner1_percentage_ASC"
  | "owner1_percentage_DESC"
  | "owner2_percentage_ASC"
  | "owner2_percentage_DESC"
  | "owner3_percentage_ASC"
  | "owner3_percentage_DESC"
  | "total_minutes_ASC"
  | "total_minutes_DESC"
  | "owner1_minutes_ASC"
  | "owner1_minutes_DESC"
  | "owner2_minutes_ASC"
  | "owner2_minutes_DESC"
  | "owner3_minutes_ASC"
  | "owner3_minutes_DESC";

export type VideoTotalParametersOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "minutes_watched_multiplier_ASC"
  | "minutes_watched_multiplier_DESC"
  | "exponent_for_minutes_watched_ASC"
  | "exponent_for_minutes_watched_DESC"
  | "star_rating_multiplier_ASC"
  | "star_rating_multiplier_DESC"
  | "star_rating_on_off_ASC"
  | "star_rating_on_off_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ActivationCodeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface ActivationCodeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  valid_until?: DateTimeInput;
  valid_until_not?: DateTimeInput;
  valid_until_in?: DateTimeInput[] | DateTimeInput;
  valid_until_not_in?: DateTimeInput[] | DateTimeInput;
  valid_until_lt?: DateTimeInput;
  valid_until_lte?: DateTimeInput;
  valid_until_gt?: DateTimeInput;
  valid_until_gte?: DateTimeInput;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  AND?: ActivationCodeWhereInput[] | ActivationCodeWhereInput;
  OR?: ActivationCodeWhereInput[] | ActivationCodeWhereInput;
  NOT?: ActivationCodeWhereInput[] | ActivationCodeWhereInput;
}

export type ArtistFactorsWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  firstname?: String;
  firstname_not?: String;
  firstname_in?: String[] | String;
  firstname_not_in?: String[] | String;
  firstname_lt?: String;
  firstname_lte?: String;
  firstname_gt?: String;
  firstname_gte?: String;
  firstname_contains?: String;
  firstname_not_contains?: String;
  firstname_starts_with?: String;
  firstname_not_starts_with?: String;
  firstname_ends_with?: String;
  firstname_not_ends_with?: String;
  lastname?: String;
  lastname_not?: String;
  lastname_in?: String[] | String;
  lastname_not_in?: String[] | String;
  lastname_lt?: String;
  lastname_lte?: String;
  lastname_gt?: String;
  lastname_gte?: String;
  lastname_contains?: String;
  lastname_not_contains?: String;
  lastname_starts_with?: String;
  lastname_not_starts_with?: String;
  lastname_ends_with?: String;
  lastname_not_ends_with?: String;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  role?: UserRole;
  role_not?: UserRole;
  role_in?: UserRole[] | UserRole;
  role_not_in?: UserRole[] | UserRole;
  approved?: Boolean;
  approved_not?: Boolean;
  password_hash?: String;
  password_hash_not?: String;
  password_hash_in?: String[] | String;
  password_hash_not_in?: String[] | String;
  password_hash_lt?: String;
  password_hash_lte?: String;
  password_hash_gt?: String;
  password_hash_gte?: String;
  password_hash_contains?: String;
  password_hash_not_contains?: String;
  password_hash_starts_with?: String;
  password_hash_not_starts_with?: String;
  password_hash_ends_with?: String;
  password_hash_not_ends_with?: String;
  password_salt?: String;
  password_salt_not?: String;
  password_salt_in?: String[] | String;
  password_salt_not_in?: String[] | String;
  password_salt_lt?: String;
  password_salt_lte?: String;
  password_salt_gt?: String;
  password_salt_gte?: String;
  password_salt_contains?: String;
  password_salt_not_contains?: String;
  password_salt_starts_with?: String;
  password_salt_not_starts_with?: String;
  password_salt_ends_with?: String;
  password_salt_not_ends_with?: String;
  avatar?: String;
  avatar_not?: String;
  avatar_in?: String[] | String;
  avatar_not_in?: String[] | String;
  avatar_lt?: String;
  avatar_lte?: String;
  avatar_gt?: String;
  avatar_gte?: String;
  avatar_contains?: String;
  avatar_not_contains?: String;
  avatar_starts_with?: String;
  avatar_not_starts_with?: String;
  avatar_ends_with?: String;
  avatar_not_ends_with?: String;
  background_image?: String;
  background_image_not?: String;
  background_image_in?: String[] | String;
  background_image_not_in?: String[] | String;
  background_image_lt?: String;
  background_image_lte?: String;
  background_image_gt?: String;
  background_image_gte?: String;
  background_image_contains?: String;
  background_image_not_contains?: String;
  background_image_starts_with?: String;
  background_image_not_starts_with?: String;
  background_image_ends_with?: String;
  background_image_not_ends_with?: String;
  about_text?: String;
  about_text_not?: String;
  about_text_in?: String[] | String;
  about_text_not_in?: String[] | String;
  about_text_lt?: String;
  about_text_lte?: String;
  about_text_gt?: String;
  about_text_gte?: String;
  about_text_contains?: String;
  about_text_not_contains?: String;
  about_text_starts_with?: String;
  about_text_not_starts_with?: String;
  about_text_ends_with?: String;
  about_text_not_ends_with?: String;
  payout_amount?: Int;
  payout_amount_not?: Int;
  payout_amount_in?: Int[] | Int;
  payout_amount_not_in?: Int[] | Int;
  payout_amount_lt?: Int;
  payout_amount_lte?: Int;
  payout_amount_gt?: Int;
  payout_amount_gte?: Int;
  payout_months_total?: Int;
  payout_months_total_not?: Int;
  payout_months_total_in?: Int[] | Int;
  payout_months_total_not_in?: Int[] | Int;
  payout_months_total_lt?: Int;
  payout_months_total_lte?: Int;
  payout_months_total_gt?: Int;
  payout_months_total_gte?: Int;
  payout_months_left?: Int;
  payout_months_left_not?: Int;
  payout_months_left_in?: Int[] | Int;
  payout_months_left_not_in?: Int[] | Int;
  payout_months_left_lt?: Int;
  payout_months_left_lte?: Int;
  payout_months_left_gt?: Int;
  payout_months_left_gte?: Int;
  payout_enabled?: Boolean;
  payout_enabled_not?: Boolean;
  artist?: UserWhereInput;
  users_every?: UserWhereInput;
  users_some?: UserWhereInput;
  users_none?: UserWhereInput;
  front_id_scan?: String;
  front_id_scan_not?: String;
  front_id_scan_in?: String[] | String;
  front_id_scan_not_in?: String[] | String;
  front_id_scan_lt?: String;
  front_id_scan_lte?: String;
  front_id_scan_gt?: String;
  front_id_scan_gte?: String;
  front_id_scan_contains?: String;
  front_id_scan_not_contains?: String;
  front_id_scan_starts_with?: String;
  front_id_scan_not_starts_with?: String;
  front_id_scan_ends_with?: String;
  front_id_scan_not_ends_with?: String;
  back_id_scan?: String;
  back_id_scan_not?: String;
  back_id_scan_in?: String[] | String;
  back_id_scan_not_in?: String[] | String;
  back_id_scan_lt?: String;
  back_id_scan_lte?: String;
  back_id_scan_gt?: String;
  back_id_scan_gte?: String;
  back_id_scan_contains?: String;
  back_id_scan_not_contains?: String;
  back_id_scan_starts_with?: String;
  back_id_scan_not_starts_with?: String;
  back_id_scan_ends_with?: String;
  back_id_scan_not_ends_with?: String;
  my_videos_every?: VideoWhereInput;
  my_videos_some?: VideoWhereInput;
  my_videos_none?: VideoWhereInput;
  liked_videos_every?: VideoWhereInput;
  liked_videos_some?: VideoWhereInput;
  liked_videos_none?: VideoWhereInput;
  watched_videos_every?: WatchedVideoUserWhereInput;
  watched_videos_some?: WatchedVideoUserWhereInput;
  watched_videos_none?: WatchedVideoUserWhereInput;
  my_subscription_users_every?: UserWhereInput;
  my_subscription_users_some?: UserWhereInput;
  my_subscription_users_none?: UserWhereInput;
  subscribed_users_every?: UserWhereInput;
  subscribed_users_some?: UserWhereInput;
  subscribed_users_none?: UserWhereInput;
  billing_subscription_active?: Boolean;
  billing_subscription_active_not?: Boolean;
  stripe_customer_id?: String;
  stripe_customer_id_not?: String;
  stripe_customer_id_in?: String[] | String;
  stripe_customer_id_not_in?: String[] | String;
  stripe_customer_id_lt?: String;
  stripe_customer_id_lte?: String;
  stripe_customer_id_gt?: String;
  stripe_customer_id_gte?: String;
  stripe_customer_id_contains?: String;
  stripe_customer_id_not_contains?: String;
  stripe_customer_id_starts_with?: String;
  stripe_customer_id_not_starts_with?: String;
  stripe_customer_id_ends_with?: String;
  stripe_customer_id_not_ends_with?: String;
  my_promo_codes_every?: PromoCodeWhereInput;
  my_promo_codes_some?: PromoCodeWhereInput;
  my_promo_codes_none?: PromoCodeWhereInput;
  last_login_date?: DateTimeInput;
  last_login_date_not?: DateTimeInput;
  last_login_date_in?: DateTimeInput[] | DateTimeInput;
  last_login_date_not_in?: DateTimeInput[] | DateTimeInput;
  last_login_date_lt?: DateTimeInput;
  last_login_date_lte?: DateTimeInput;
  last_login_date_gt?: DateTimeInput;
  last_login_date_gte?: DateTimeInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface VideoWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  publish_date?: DateTimeInput;
  publish_date_not?: DateTimeInput;
  publish_date_in?: DateTimeInput[] | DateTimeInput;
  publish_date_not_in?: DateTimeInput[] | DateTimeInput;
  publish_date_lt?: DateTimeInput;
  publish_date_lte?: DateTimeInput;
  publish_date_gt?: DateTimeInput;
  publish_date_gte?: DateTimeInput;
  file_url?: String;
  file_url_not?: String;
  file_url_in?: String[] | String;
  file_url_not_in?: String[] | String;
  file_url_lt?: String;
  file_url_lte?: String;
  file_url_gt?: String;
  file_url_gte?: String;
  file_url_contains?: String;
  file_url_not_contains?: String;
  file_url_starts_with?: String;
  file_url_not_starts_with?: String;
  file_url_ends_with?: String;
  file_url_not_ends_with?: String;
  video_duration?: Int;
  video_duration_not?: Int;
  video_duration_in?: Int[] | Int;
  video_duration_not_in?: Int[] | Int;
  video_duration_lt?: Int;
  video_duration_lte?: Int;
  video_duration_gt?: Int;
  video_duration_gte?: Int;
  preview_url?: String;
  preview_url_not?: String;
  preview_url_in?: String[] | String;
  preview_url_not_in?: String[] | String;
  preview_url_lt?: String;
  preview_url_lte?: String;
  preview_url_gt?: String;
  preview_url_gte?: String;
  preview_url_contains?: String;
  preview_url_not_contains?: String;
  preview_url_starts_with?: String;
  preview_url_not_starts_with?: String;
  preview_url_ends_with?: String;
  preview_url_not_ends_with?: String;
  preview_video_url?: String;
  preview_video_url_not?: String;
  preview_video_url_in?: String[] | String;
  preview_video_url_not_in?: String[] | String;
  preview_video_url_lt?: String;
  preview_video_url_lte?: String;
  preview_video_url_gt?: String;
  preview_video_url_gte?: String;
  preview_video_url_contains?: String;
  preview_video_url_not_contains?: String;
  preview_video_url_starts_with?: String;
  preview_video_url_not_starts_with?: String;
  preview_video_url_ends_with?: String;
  preview_video_url_not_ends_with?: String;
  preview_video_duration?: String;
  preview_video_duration_not?: String;
  preview_video_duration_in?: String[] | String;
  preview_video_duration_not_in?: String[] | String;
  preview_video_duration_lt?: String;
  preview_video_duration_lte?: String;
  preview_video_duration_gt?: String;
  preview_video_duration_gte?: String;
  preview_video_duration_contains?: String;
  preview_video_duration_not_contains?: String;
  preview_video_duration_starts_with?: String;
  preview_video_duration_not_starts_with?: String;
  preview_video_duration_ends_with?: String;
  preview_video_duration_not_ends_with?: String;
  author?: UserWhereInput;
  categories_every?: CategoryWhereInput;
  categories_some?: CategoryWhereInput;
  categories_none?: CategoryWhereInput;
  like_users_every?: UserWhereInput;
  like_users_some?: UserWhereInput;
  like_users_none?: UserWhereInput;
  watched_users_every?: WatchedVideoUserWhereInput;
  watched_users_some?: WatchedVideoUserWhereInput;
  watched_users_none?: WatchedVideoUserWhereInput;
  tags_every?: TagWhereInput;
  tags_some?: TagWhereInput;
  tags_none?: TagWhereInput;
  deleted?: Boolean;
  deleted_not?: Boolean;
  AND?: VideoWhereInput[] | VideoWhereInput;
  OR?: VideoWhereInput[] | VideoWhereInput;
  NOT?: VideoWhereInput[] | VideoWhereInput;
}

export interface CategoryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  videos_every?: VideoWhereInput;
  videos_some?: VideoWhereInput;
  videos_none?: VideoWhereInput;
  AND?: CategoryWhereInput[] | CategoryWhereInput;
  OR?: CategoryWhereInput[] | CategoryWhereInput;
  NOT?: CategoryWhereInput[] | CategoryWhereInput;
}

export interface WatchedVideoUserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  video?: VideoWhereInput;
  user?: UserWhereInput;
  watched_seconds?: Int;
  watched_seconds_not?: Int;
  watched_seconds_in?: Int[] | Int;
  watched_seconds_not_in?: Int[] | Int;
  watched_seconds_lt?: Int;
  watched_seconds_lte?: Int;
  watched_seconds_gt?: Int;
  watched_seconds_gte?: Int;
  AND?: WatchedVideoUserWhereInput[] | WatchedVideoUserWhereInput;
  OR?: WatchedVideoUserWhereInput[] | WatchedVideoUserWhereInput;
  NOT?: WatchedVideoUserWhereInput[] | WatchedVideoUserWhereInput;
}

export interface TagWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  videos_every?: VideoWhereInput;
  videos_some?: VideoWhereInput;
  videos_none?: VideoWhereInput;
  AND?: TagWhereInput[] | TagWhereInput;
  OR?: TagWhereInput[] | TagWhereInput;
  NOT?: TagWhereInput[] | TagWhereInput;
}

export interface PromoCodeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  user?: UserWhereInput;
  promo_code?: String;
  promo_code_not?: String;
  promo_code_in?: String[] | String;
  promo_code_not_in?: String[] | String;
  promo_code_lt?: String;
  promo_code_lte?: String;
  promo_code_gt?: String;
  promo_code_gte?: String;
  promo_code_contains?: String;
  promo_code_not_contains?: String;
  promo_code_starts_with?: String;
  promo_code_not_starts_with?: String;
  promo_code_ends_with?: String;
  promo_code_not_ends_with?: String;
  current_promo_code?: Boolean;
  current_promo_code_not?: Boolean;
  AND?: PromoCodeWhereInput[] | PromoCodeWhereInput;
  OR?: PromoCodeWhereInput[] | PromoCodeWhereInput;
  NOT?: PromoCodeWhereInput[] | PromoCodeWhereInput;
}

export interface ArtistFactorsWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  artist?: UserWhereInput;
  promotion_factor?: Float;
  promotion_factor_not?: Float;
  promotion_factor_in?: Float[] | Float;
  promotion_factor_not_in?: Float[] | Float;
  promotion_factor_lt?: Float;
  promotion_factor_lte?: Float;
  promotion_factor_gt?: Float;
  promotion_factor_gte?: Float;
  minutes_exponent?: Float;
  minutes_exponent_not?: Float;
  minutes_exponent_in?: Float[] | Float;
  minutes_exponent_not_in?: Float[] | Float;
  minutes_exponent_lt?: Float;
  minutes_exponent_lte?: Float;
  minutes_exponent_gt?: Float;
  minutes_exponent_gte?: Float;
  finder_fee_factor?: Float;
  finder_fee_factor_not?: Float;
  finder_fee_factor_in?: Float[] | Float;
  finder_fee_factor_not_in?: Float[] | Float;
  finder_fee_factor_lt?: Float;
  finder_fee_factor_lte?: Float;
  finder_fee_factor_gt?: Float;
  finder_fee_factor_gte?: Float;
  monthly_fee_duration?: Int;
  monthly_fee_duration_not?: Int;
  monthly_fee_duration_in?: Int[] | Int;
  monthly_fee_duration_not_in?: Int[] | Int;
  monthly_fee_duration_lt?: Int;
  monthly_fee_duration_lte?: Int;
  monthly_fee_duration_gt?: Int;
  monthly_fee_duration_gte?: Int;
  monthly_fee_amount_per_month?: Int;
  monthly_fee_amount_per_month_not?: Int;
  monthly_fee_amount_per_month_in?: Int[] | Int;
  monthly_fee_amount_per_month_not_in?: Int[] | Int;
  monthly_fee_amount_per_month_lt?: Int;
  monthly_fee_amount_per_month_lte?: Int;
  monthly_fee_amount_per_month_gt?: Int;
  monthly_fee_amount_per_month_gte?: Int;
  annual_fee_amount_per_month?: Int;
  annual_fee_amount_per_month_not?: Int;
  annual_fee_amount_per_month_in?: Int[] | Int;
  annual_fee_amount_per_month_not_in?: Int[] | Int;
  annual_fee_amount_per_month_lt?: Int;
  annual_fee_amount_per_month_lte?: Int;
  annual_fee_amount_per_month_gt?: Int;
  annual_fee_amount_per_month_gte?: Int;
  AND?: ArtistFactorsWhereInput[] | ArtistFactorsWhereInput;
  OR?: ArtistFactorsWhereInput[] | ArtistFactorsWhereInput;
  NOT?: ArtistFactorsWhereInput[] | ArtistFactorsWhereInput;
}

export type ArtistFactorsSettingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ArtistFactorsSettingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  promotion_factor?: Float;
  promotion_factor_not?: Float;
  promotion_factor_in?: Float[] | Float;
  promotion_factor_not_in?: Float[] | Float;
  promotion_factor_lt?: Float;
  promotion_factor_lte?: Float;
  promotion_factor_gt?: Float;
  promotion_factor_gte?: Float;
  minutes_exponent?: Float;
  minutes_exponent_not?: Float;
  minutes_exponent_in?: Float[] | Float;
  minutes_exponent_not_in?: Float[] | Float;
  minutes_exponent_lt?: Float;
  minutes_exponent_lte?: Float;
  minutes_exponent_gt?: Float;
  minutes_exponent_gte?: Float;
  finder_fee_factor?: Float;
  finder_fee_factor_not?: Float;
  finder_fee_factor_in?: Float[] | Float;
  finder_fee_factor_not_in?: Float[] | Float;
  finder_fee_factor_lt?: Float;
  finder_fee_factor_lte?: Float;
  finder_fee_factor_gt?: Float;
  finder_fee_factor_gte?: Float;
  monthly_fee_duration?: Int;
  monthly_fee_duration_not?: Int;
  monthly_fee_duration_in?: Int[] | Int;
  monthly_fee_duration_not_in?: Int[] | Int;
  monthly_fee_duration_lt?: Int;
  monthly_fee_duration_lte?: Int;
  monthly_fee_duration_gt?: Int;
  monthly_fee_duration_gte?: Int;
  monthly_fee_amount_per_month?: Int;
  monthly_fee_amount_per_month_not?: Int;
  monthly_fee_amount_per_month_in?: Int[] | Int;
  monthly_fee_amount_per_month_not_in?: Int[] | Int;
  monthly_fee_amount_per_month_lt?: Int;
  monthly_fee_amount_per_month_lte?: Int;
  monthly_fee_amount_per_month_gt?: Int;
  monthly_fee_amount_per_month_gte?: Int;
  annual_fee_amount_per_month?: Int;
  annual_fee_amount_per_month_not?: Int;
  annual_fee_amount_per_month_in?: Int[] | Int;
  annual_fee_amount_per_month_not_in?: Int[] | Int;
  annual_fee_amount_per_month_lt?: Int;
  annual_fee_amount_per_month_lte?: Int;
  annual_fee_amount_per_month_gt?: Int;
  annual_fee_amount_per_month_gte?: Int;
  AND?: ArtistFactorsSettingWhereInput[] | ArtistFactorsSettingWhereInput;
  OR?: ArtistFactorsSettingWhereInput[] | ArtistFactorsSettingWhereInput;
  NOT?: ArtistFactorsSettingWhereInput[] | ArtistFactorsSettingWhereInput;
}

export type CategoryWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ChargeHistoryWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ChargeHistoryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  user?: UserWhereInput;
  amount?: Int;
  amount_not?: Int;
  amount_in?: Int[] | Int;
  amount_not_in?: Int[] | Int;
  amount_lt?: Int;
  amount_lte?: Int;
  amount_gt?: Int;
  amount_gte?: Int;
  chargeDate?: DateTimeInput;
  chargeDate_not?: DateTimeInput;
  chargeDate_in?: DateTimeInput[] | DateTimeInput;
  chargeDate_not_in?: DateTimeInput[] | DateTimeInput;
  chargeDate_lt?: DateTimeInput;
  chargeDate_lte?: DateTimeInput;
  chargeDate_gt?: DateTimeInput;
  chargeDate_gte?: DateTimeInput;
  chargeId?: String;
  chargeId_not?: String;
  chargeId_in?: String[] | String;
  chargeId_not_in?: String[] | String;
  chargeId_lt?: String;
  chargeId_lte?: String;
  chargeId_gt?: String;
  chargeId_gte?: String;
  chargeId_contains?: String;
  chargeId_not_contains?: String;
  chargeId_starts_with?: String;
  chargeId_not_starts_with?: String;
  chargeId_ends_with?: String;
  chargeId_not_ends_with?: String;
  refunded?: Boolean;
  refunded_not?: Boolean;
  AND?: ChargeHistoryWhereInput[] | ChargeHistoryWhereInput;
  OR?: ChargeHistoryWhereInput[] | ChargeHistoryWhereInput;
  NOT?: ChargeHistoryWhereInput[] | ChargeHistoryWhereInput;
}

export type CurriculumWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CurriculumWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  author?: UserWhereInput;
  AND?: CurriculumWhereInput[] | CurriculumWhereInput;
  OR?: CurriculumWhereInput[] | CurriculumWhereInput;
  NOT?: CurriculumWhereInput[] | CurriculumWhereInput;
}

export type PlayHistoryWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PlayHistoryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  user?: UserWhereInput;
  video?: VideoWhereInput;
  playSeconds?: Int;
  playSeconds_not?: Int;
  playSeconds_in?: Int[] | Int;
  playSeconds_not_in?: Int[] | Int;
  playSeconds_lt?: Int;
  playSeconds_lte?: Int;
  playSeconds_gt?: Int;
  playSeconds_gte?: Int;
  realPlaySeconds?: Int;
  realPlaySeconds_not?: Int;
  realPlaySeconds_in?: Int[] | Int;
  realPlaySeconds_not_in?: Int[] | Int;
  realPlaySeconds_lt?: Int;
  realPlaySeconds_lte?: Int;
  realPlaySeconds_gt?: Int;
  realPlaySeconds_gte?: Int;
  AND?: PlayHistoryWhereInput[] | PlayHistoryWhereInput;
  OR?: PlayHistoryWhereInput[] | PlayHistoryWhereInput;
  NOT?: PlayHistoryWhereInput[] | PlayHistoryWhereInput;
}

export type PostWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PostWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  mainImageUrl?: String;
  mainImageUrl_not?: String;
  mainImageUrl_in?: String[] | String;
  mainImageUrl_not_in?: String[] | String;
  mainImageUrl_lt?: String;
  mainImageUrl_lte?: String;
  mainImageUrl_gt?: String;
  mainImageUrl_gte?: String;
  mainImageUrl_contains?: String;
  mainImageUrl_not_contains?: String;
  mainImageUrl_starts_with?: String;
  mainImageUrl_not_starts_with?: String;
  mainImageUrl_ends_with?: String;
  mainImageUrl_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  author?: UserWhereInput;
  AND?: PostWhereInput[] | PostWhereInput;
  OR?: PostWhereInput[] | PostWhereInput;
  NOT?: PostWhereInput[] | PostWhereInput;
}

export type ProfitPoolCalculationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProfitPoolCalculationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  year?: Int;
  year_not?: Int;
  year_in?: Int[] | Int;
  year_not_in?: Int[] | Int;
  year_lt?: Int;
  year_lte?: Int;
  year_gt?: Int;
  year_gte?: Int;
  month?: Int;
  month_not?: Int;
  month_in?: Int[] | Int;
  month_not_in?: Int[] | Int;
  month_lt?: Int;
  month_lte?: Int;
  month_gt?: Int;
  month_gte?: Int;
  annual_active_subscribers?: Int;
  annual_active_subscribers_not?: Int;
  annual_active_subscribers_in?: Int[] | Int;
  annual_active_subscribers_not_in?: Int[] | Int;
  annual_active_subscribers_lt?: Int;
  annual_active_subscribers_lte?: Int;
  annual_active_subscribers_gt?: Int;
  annual_active_subscribers_gte?: Int;
  monthly_active_subscribers?: Int;
  monthly_active_subscribers_not?: Int;
  monthly_active_subscribers_in?: Int[] | Int;
  monthly_active_subscribers_not_in?: Int[] | Int;
  monthly_active_subscribers_lt?: Int;
  monthly_active_subscribers_lte?: Int;
  monthly_active_subscribers_gt?: Int;
  monthly_active_subscribers_gte?: Int;
  annual_subscription_rate?: Int;
  annual_subscription_rate_not?: Int;
  annual_subscription_rate_in?: Int[] | Int;
  annual_subscription_rate_not_in?: Int[] | Int;
  annual_subscription_rate_lt?: Int;
  annual_subscription_rate_lte?: Int;
  annual_subscription_rate_gt?: Int;
  annual_subscription_rate_gte?: Int;
  monthly_subscription_rate?: Int;
  monthly_subscription_rate_not?: Int;
  monthly_subscription_rate_in?: Int[] | Int;
  monthly_subscription_rate_not_in?: Int[] | Int;
  monthly_subscription_rate_lt?: Int;
  monthly_subscription_rate_lte?: Int;
  monthly_subscription_rate_gt?: Int;
  monthly_subscription_rate_gte?: Int;
  annual_pool_revenue?: Int;
  annual_pool_revenue_not?: Int;
  annual_pool_revenue_in?: Int[] | Int;
  annual_pool_revenue_not_in?: Int[] | Int;
  annual_pool_revenue_lt?: Int;
  annual_pool_revenue_lte?: Int;
  annual_pool_revenue_gt?: Int;
  annual_pool_revenue_gte?: Int;
  monthly_pool_revenue?: Int;
  monthly_pool_revenue_not?: Int;
  monthly_pool_revenue_in?: Int[] | Int;
  monthly_pool_revenue_not_in?: Int[] | Int;
  monthly_pool_revenue_lt?: Int;
  monthly_pool_revenue_lte?: Int;
  monthly_pool_revenue_gt?: Int;
  monthly_pool_revenue_gte?: Int;
  total_revenue?: Int;
  total_revenue_not?: Int;
  total_revenue_in?: Int[] | Int;
  total_revenue_not_in?: Int[] | Int;
  total_revenue_lt?: Int;
  total_revenue_lte?: Int;
  total_revenue_gt?: Int;
  total_revenue_gte?: Int;
  total_payment_to_artists?: Float;
  total_payment_to_artists_not?: Float;
  total_payment_to_artists_in?: Float[] | Float;
  total_payment_to_artists_not_in?: Float[] | Float;
  total_payment_to_artists_lt?: Float;
  total_payment_to_artists_lte?: Float;
  total_payment_to_artists_gt?: Float;
  total_payment_to_artists_gte?: Float;
  net_revenue?: Float;
  net_revenue_not?: Float;
  net_revenue_in?: Float[] | Float;
  net_revenue_not_in?: Float[] | Float;
  net_revenue_lt?: Float;
  net_revenue_lte?: Float;
  net_revenue_gt?: Float;
  net_revenue_gte?: Float;
  AND?: ProfitPoolCalculationWhereInput[] | ProfitPoolCalculationWhereInput;
  OR?: ProfitPoolCalculationWhereInput[] | ProfitPoolCalculationWhereInput;
  NOT?: ProfitPoolCalculationWhereInput[] | ProfitPoolCalculationWhereInput;
}

export type ProfitPoolFactorWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProfitPoolFactorWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  overhead?: Int;
  overhead_not?: Int;
  overhead_in?: Int[] | Int;
  overhead_not_in?: Int[] | Int;
  overhead_lt?: Int;
  overhead_lte?: Int;
  overhead_gt?: Int;
  overhead_gte?: Int;
  monthly_multiplier?: Float;
  monthly_multiplier_not?: Float;
  monthly_multiplier_in?: Float[] | Float;
  monthly_multiplier_not_in?: Float[] | Float;
  monthly_multiplier_lt?: Float;
  monthly_multiplier_lte?: Float;
  monthly_multiplier_gt?: Float;
  monthly_multiplier_gte?: Float;
  finder_fee_multiplier?: Float;
  finder_fee_multiplier_not?: Float;
  finder_fee_multiplier_in?: Float[] | Float;
  finder_fee_multiplier_not_in?: Float[] | Float;
  finder_fee_multiplier_lt?: Float;
  finder_fee_multiplier_lte?: Float;
  finder_fee_multiplier_gt?: Float;
  finder_fee_multiplier_gte?: Float;
  profit_pool_option1_variable?: Int;
  profit_pool_option1_variable_not?: Int;
  profit_pool_option1_variable_in?: Int[] | Int;
  profit_pool_option1_variable_not_in?: Int[] | Int;
  profit_pool_option1_variable_lt?: Int;
  profit_pool_option1_variable_lte?: Int;
  profit_pool_option1_variable_gt?: Int;
  profit_pool_option1_variable_gte?: Int;
  profit_pool_option1_multiplier?: Float;
  profit_pool_option1_multiplier_not?: Float;
  profit_pool_option1_multiplier_in?: Float[] | Float;
  profit_pool_option1_multiplier_not_in?: Float[] | Float;
  profit_pool_option1_multiplier_lt?: Float;
  profit_pool_option1_multiplier_lte?: Float;
  profit_pool_option1_multiplier_gt?: Float;
  profit_pool_option1_multiplier_gte?: Float;
  profit_pool_option2_variable?: Int;
  profit_pool_option2_variable_not?: Int;
  profit_pool_option2_variable_in?: Int[] | Int;
  profit_pool_option2_variable_not_in?: Int[] | Int;
  profit_pool_option2_variable_lt?: Int;
  profit_pool_option2_variable_lte?: Int;
  profit_pool_option2_variable_gt?: Int;
  profit_pool_option2_variable_gte?: Int;
  profit_pool_option2_multiplier?: Float;
  profit_pool_option2_multiplier_not?: Float;
  profit_pool_option2_multiplier_in?: Float[] | Float;
  profit_pool_option2_multiplier_not_in?: Float[] | Float;
  profit_pool_option2_multiplier_lt?: Float;
  profit_pool_option2_multiplier_lte?: Float;
  profit_pool_option2_multiplier_gt?: Float;
  profit_pool_option2_multiplier_gte?: Float;
  profit_pool_percentage?: Float;
  profit_pool_percentage_not?: Float;
  profit_pool_percentage_in?: Float[] | Float;
  profit_pool_percentage_not_in?: Float[] | Float;
  profit_pool_percentage_lt?: Float;
  profit_pool_percentage_lte?: Float;
  profit_pool_percentage_gt?: Float;
  profit_pool_percentage_gte?: Float;
  manual_change?: Int;
  manual_change_not?: Int;
  manual_change_in?: Int[] | Int;
  manual_change_not_in?: Int[] | Int;
  manual_change_lt?: Int;
  manual_change_lte?: Int;
  manual_change_gt?: Int;
  manual_change_gte?: Int;
  AND?: ProfitPoolFactorWhereInput[] | ProfitPoolFactorWhereInput;
  OR?: ProfitPoolFactorWhereInput[] | ProfitPoolFactorWhereInput;
  NOT?: ProfitPoolFactorWhereInput[] | ProfitPoolFactorWhereInput;
}

export type PromoCodeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  promo_code?: String;
}>;

export type RestoreCodeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface RestoreCodeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  valid_until?: DateTimeInput;
  valid_until_not?: DateTimeInput;
  valid_until_in?: DateTimeInput[] | DateTimeInput;
  valid_until_not_in?: DateTimeInput[] | DateTimeInput;
  valid_until_lt?: DateTimeInput;
  valid_until_lte?: DateTimeInput;
  valid_until_gt?: DateTimeInput;
  valid_until_gte?: DateTimeInput;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  AND?: RestoreCodeWhereInput[] | RestoreCodeWhereInput;
  OR?: RestoreCodeWhereInput[] | RestoreCodeWhereInput;
  NOT?: RestoreCodeWhereInput[] | RestoreCodeWhereInput;
}

export type SettingsWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface SettingsWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  int_val?: Int;
  int_val_not?: Int;
  int_val_in?: Int[] | Int;
  int_val_not_in?: Int[] | Int;
  int_val_lt?: Int;
  int_val_lte?: Int;
  int_val_gt?: Int;
  int_val_gte?: Int;
  str_val?: String;
  str_val_not?: String;
  str_val_in?: String[] | String;
  str_val_not_in?: String[] | String;
  str_val_lt?: String;
  str_val_lte?: String;
  str_val_gt?: String;
  str_val_gte?: String;
  str_val_contains?: String;
  str_val_not_contains?: String;
  str_val_starts_with?: String;
  str_val_not_starts_with?: String;
  str_val_ends_with?: String;
  str_val_not_ends_with?: String;
  AND?: SettingsWhereInput[] | SettingsWhereInput;
  OR?: SettingsWhereInput[] | SettingsWhereInput;
  NOT?: SettingsWhereInput[] | SettingsWhereInput;
}

export type SubscriptionHistoryWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SubscriptionHistoryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  user?: UserWhereInput;
  interval?: String;
  interval_not?: String;
  interval_in?: String[] | String;
  interval_not_in?: String[] | String;
  interval_lt?: String;
  interval_lte?: String;
  interval_gt?: String;
  interval_gte?: String;
  interval_contains?: String;
  interval_not_contains?: String;
  interval_starts_with?: String;
  interval_not_starts_with?: String;
  interval_ends_with?: String;
  interval_not_ends_with?: String;
  amount?: Int;
  amount_not?: Int;
  amount_in?: Int[] | Int;
  amount_not_in?: Int[] | Int;
  amount_lt?: Int;
  amount_lte?: Int;
  amount_gt?: Int;
  amount_gte?: Int;
  subscriptionDate?: DateTimeInput;
  subscriptionDate_not?: DateTimeInput;
  subscriptionDate_in?: DateTimeInput[] | DateTimeInput;
  subscriptionDate_not_in?: DateTimeInput[] | DateTimeInput;
  subscriptionDate_lt?: DateTimeInput;
  subscriptionDate_lte?: DateTimeInput;
  subscriptionDate_gt?: DateTimeInput;
  subscriptionDate_gte?: DateTimeInput;
  AND?: SubscriptionHistoryWhereInput[] | SubscriptionHistoryWhereInput;
  OR?: SubscriptionHistoryWhereInput[] | SubscriptionHistoryWhereInput;
  NOT?: SubscriptionHistoryWhereInput[] | SubscriptionHistoryWhereInput;
}

export type TagWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type TotalMinutesForArtistWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface TotalMinutesForArtistWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  year?: Int;
  year_not?: Int;
  year_in?: Int[] | Int;
  year_not_in?: Int[] | Int;
  year_lt?: Int;
  year_lte?: Int;
  year_gt?: Int;
  year_gte?: Int;
  month?: Int;
  month_not?: Int;
  month_in?: Int[] | Int;
  month_not_in?: Int[] | Int;
  month_lt?: Int;
  month_lte?: Int;
  month_gt?: Int;
  month_gte?: Int;
  artist?: UserWhereInput;
  minutes_as_owner1?: Float;
  minutes_as_owner1_not?: Float;
  minutes_as_owner1_in?: Float[] | Float;
  minutes_as_owner1_not_in?: Float[] | Float;
  minutes_as_owner1_lt?: Float;
  minutes_as_owner1_lte?: Float;
  minutes_as_owner1_gt?: Float;
  minutes_as_owner1_gte?: Float;
  minutes_as_owner2?: Float;
  minutes_as_owner2_not?: Float;
  minutes_as_owner2_in?: Float[] | Float;
  minutes_as_owner2_not_in?: Float[] | Float;
  minutes_as_owner2_lt?: Float;
  minutes_as_owner2_lte?: Float;
  minutes_as_owner2_gt?: Float;
  minutes_as_owner2_gte?: Float;
  minutes_as_owner3?: Float;
  minutes_as_owner3_not?: Float;
  minutes_as_owner3_in?: Float[] | Float;
  minutes_as_owner3_not_in?: Float[] | Float;
  minutes_as_owner3_lt?: Float;
  minutes_as_owner3_lte?: Float;
  minutes_as_owner3_gt?: Float;
  minutes_as_owner3_gte?: Float;
  total_minutes?: Float;
  total_minutes_not?: Float;
  total_minutes_in?: Float[] | Float;
  total_minutes_not_in?: Float[] | Float;
  total_minutes_lt?: Float;
  total_minutes_lte?: Float;
  total_minutes_gt?: Float;
  total_minutes_gte?: Float;
  artist_rating_factor?: Float;
  artist_rating_factor_not?: Float;
  artist_rating_factor_in?: Float[] | Float;
  artist_rating_factor_not_in?: Float[] | Float;
  artist_rating_factor_lt?: Float;
  artist_rating_factor_lte?: Float;
  artist_rating_factor_gt?: Float;
  artist_rating_factor_gte?: Float;
  final_minutes?: Float;
  final_minutes_not?: Float;
  final_minutes_in?: Float[] | Float;
  final_minutes_not_in?: Float[] | Float;
  final_minutes_lt?: Float;
  final_minutes_lte?: Float;
  final_minutes_gt?: Float;
  final_minutes_gte?: Float;
  percent_of_profit_pool?: Float;
  percent_of_profit_pool_not?: Float;
  percent_of_profit_pool_in?: Float[] | Float;
  percent_of_profit_pool_not_in?: Float[] | Float;
  percent_of_profit_pool_lt?: Float;
  percent_of_profit_pool_lte?: Float;
  percent_of_profit_pool_gt?: Float;
  percent_of_profit_pool_gte?: Float;
  monthly_quantity?: Int;
  monthly_quantity_not?: Int;
  monthly_quantity_in?: Int[] | Int;
  monthly_quantity_not_in?: Int[] | Int;
  monthly_quantity_lt?: Int;
  monthly_quantity_lte?: Int;
  monthly_quantity_gt?: Int;
  monthly_quantity_gte?: Int;
  annual_quantity?: Int;
  annual_quantity_not?: Int;
  annual_quantity_in?: Int[] | Int;
  annual_quantity_not_in?: Int[] | Int;
  annual_quantity_lt?: Int;
  annual_quantity_lte?: Int;
  annual_quantity_gt?: Int;
  annual_quantity_gte?: Int;
  finder_fee?: Int;
  finder_fee_not?: Int;
  finder_fee_in?: Int[] | Int;
  finder_fee_not_in?: Int[] | Int;
  finder_fee_lt?: Int;
  finder_fee_lte?: Int;
  finder_fee_gt?: Int;
  finder_fee_gte?: Int;
  payment_from_profit_pool?: Float;
  payment_from_profit_pool_not?: Float;
  payment_from_profit_pool_in?: Float[] | Float;
  payment_from_profit_pool_not_in?: Float[] | Float;
  payment_from_profit_pool_lt?: Float;
  payment_from_profit_pool_lte?: Float;
  payment_from_profit_pool_gt?: Float;
  payment_from_profit_pool_gte?: Float;
  total_payment?: Float;
  total_payment_not?: Float;
  total_payment_in?: Float[] | Float;
  total_payment_not_in?: Float[] | Float;
  total_payment_lt?: Float;
  total_payment_lte?: Float;
  total_payment_gt?: Float;
  total_payment_gte?: Float;
  AND?: TotalMinutesForArtistWhereInput[] | TotalMinutesForArtistWhereInput;
  OR?: TotalMinutesForArtistWhereInput[] | TotalMinutesForArtistWhereInput;
  NOT?: TotalMinutesForArtistWhereInput[] | TotalMinutesForArtistWhereInput;
}

export type TransferPlanWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface TransferPlanWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  artist?: UserWhereInput;
  subscriber?: UserWhereInput;
  year?: Int;
  year_not?: Int;
  year_in?: Int[] | Int;
  year_not_in?: Int[] | Int;
  year_lt?: Int;
  year_lte?: Int;
  year_gt?: Int;
  year_gte?: Int;
  month?: Int;
  month_not?: Int;
  month_in?: Int[] | Int;
  month_not_in?: Int[] | Int;
  month_lt?: Int;
  month_lte?: Int;
  month_gt?: Int;
  month_gte?: Int;
  amount?: Int;
  amount_not?: Int;
  amount_in?: Int[] | Int;
  amount_not_in?: Int[] | Int;
  amount_lt?: Int;
  amount_lte?: Int;
  amount_gt?: Int;
  amount_gte?: Int;
  ignore_status?: Boolean;
  ignore_status_not?: Boolean;
  paid_status?: Boolean;
  paid_status_not?: Boolean;
  paid_date?: DateTimeInput;
  paid_date_not?: DateTimeInput;
  paid_date_in?: DateTimeInput[] | DateTimeInput;
  paid_date_not_in?: DateTimeInput[] | DateTimeInput;
  paid_date_lt?: DateTimeInput;
  paid_date_lte?: DateTimeInput;
  paid_date_gt?: DateTimeInput;
  paid_date_gte?: DateTimeInput;
  AND?: TransferPlanWhereInput[] | TransferPlanWhereInput;
  OR?: TransferPlanWhereInput[] | TransferPlanWhereInput;
  NOT?: TransferPlanWhereInput[] | TransferPlanWhereInput;
}

export type TransferTransactionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface TransferTransactionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  artist?: UserWhereInput;
  year?: Int;
  year_not?: Int;
  year_in?: Int[] | Int;
  year_not_in?: Int[] | Int;
  year_lt?: Int;
  year_lte?: Int;
  year_gt?: Int;
  year_gte?: Int;
  month?: Int;
  month_not?: Int;
  month_in?: Int[] | Int;
  month_not_in?: Int[] | Int;
  month_lt?: Int;
  month_lte?: Int;
  month_gt?: Int;
  month_gte?: Int;
  amount?: Int;
  amount_not?: Int;
  amount_in?: Int[] | Int;
  amount_not_in?: Int[] | Int;
  amount_lt?: Int;
  amount_lte?: Int;
  amount_gt?: Int;
  amount_gte?: Int;
  paid_status?: Boolean;
  paid_status_not?: Boolean;
  paid_date?: DateTimeInput;
  paid_date_not?: DateTimeInput;
  paid_date_in?: DateTimeInput[] | DateTimeInput;
  paid_date_not_in?: DateTimeInput[] | DateTimeInput;
  paid_date_lt?: DateTimeInput;
  paid_date_lte?: DateTimeInput;
  paid_date_gt?: DateTimeInput;
  paid_date_gte?: DateTimeInput;
  AND?: TransferTransactionWhereInput[] | TransferTransactionWhereInput;
  OR?: TransferTransactionWhereInput[] | TransferTransactionWhereInput;
  NOT?: TransferTransactionWhereInput[] | TransferTransactionWhereInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
  phone?: String;
  password_salt?: String;
  stripe_customer_id?: String;
}>;

export type VideoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type VideoDataForMonthWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface VideoDataForMonthWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  year?: Int;
  year_not?: Int;
  year_in?: Int[] | Int;
  year_not_in?: Int[] | Int;
  year_lt?: Int;
  year_lte?: Int;
  year_gt?: Int;
  year_gte?: Int;
  month?: Int;
  month_not?: Int;
  month_in?: Int[] | Int;
  month_not_in?: Int[] | Int;
  month_lt?: Int;
  month_lte?: Int;
  month_gt?: Int;
  month_gte?: Int;
  video?: VideoWhereInput;
  video_length?: Int;
  video_length_not?: Int;
  video_length_in?: Int[] | Int;
  video_length_not_in?: Int[] | Int;
  video_length_lt?: Int;
  video_length_lte?: Int;
  video_length_gt?: Int;
  video_length_gte?: Int;
  unique_users?: Int;
  unique_users_not?: Int;
  unique_users_in?: Int[] | Int;
  unique_users_not_in?: Int[] | Int;
  unique_users_lt?: Int;
  unique_users_lte?: Int;
  unique_users_gt?: Int;
  unique_users_gte?: Int;
  real_minutes_watched?: Int;
  real_minutes_watched_not?: Int;
  real_minutes_watched_in?: Int[] | Int;
  real_minutes_watched_not_in?: Int[] | Int;
  real_minutes_watched_lt?: Int;
  real_minutes_watched_lte?: Int;
  real_minutes_watched_gt?: Int;
  real_minutes_watched_gte?: Int;
  avg_minutes_watched?: Int;
  avg_minutes_watched_not?: Int;
  avg_minutes_watched_in?: Int[] | Int;
  avg_minutes_watched_not_in?: Int[] | Int;
  avg_minutes_watched_lt?: Int;
  avg_minutes_watched_lte?: Int;
  avg_minutes_watched_gt?: Int;
  avg_minutes_watched_gte?: Int;
  exponent_applied?: Int;
  exponent_applied_not?: Int;
  exponent_applied_in?: Int[] | Int;
  exponent_applied_not_in?: Int[] | Int;
  exponent_applied_lt?: Int;
  exponent_applied_lte?: Int;
  exponent_applied_gt?: Int;
  exponent_applied_gte?: Int;
  minutes_after_exponent?: Int;
  minutes_after_exponent_not?: Int;
  minutes_after_exponent_in?: Int[] | Int;
  minutes_after_exponent_not_in?: Int[] | Int;
  minutes_after_exponent_lt?: Int;
  minutes_after_exponent_lte?: Int;
  minutes_after_exponent_gt?: Int;
  minutes_after_exponent_gte?: Int;
  AND?: VideoDataForMonthWhereInput[] | VideoDataForMonthWhereInput;
  OR?: VideoDataForMonthWhereInput[] | VideoDataForMonthWhereInput;
  NOT?: VideoDataForMonthWhereInput[] | VideoDataForMonthWhereInput;
}

export type VideoParametersWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface VideoParametersWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  video?: VideoWhereInput;
  owner1?: UserWhereInput;
  owner1_percentage?: Int;
  owner1_percentage_not?: Int;
  owner1_percentage_in?: Int[] | Int;
  owner1_percentage_not_in?: Int[] | Int;
  owner1_percentage_lt?: Int;
  owner1_percentage_lte?: Int;
  owner1_percentage_gt?: Int;
  owner1_percentage_gte?: Int;
  owner2?: UserWhereInput;
  owner2_percentage?: Int;
  owner2_percentage_not?: Int;
  owner2_percentage_in?: Int[] | Int;
  owner2_percentage_not_in?: Int[] | Int;
  owner2_percentage_lt?: Int;
  owner2_percentage_lte?: Int;
  owner2_percentage_gt?: Int;
  owner2_percentage_gte?: Int;
  owner3?: UserWhereInput;
  owner3_percentage?: Int;
  owner3_percentage_not?: Int;
  owner3_percentage_in?: Int[] | Int;
  owner3_percentage_not_in?: Int[] | Int;
  owner3_percentage_lt?: Int;
  owner3_percentage_lte?: Int;
  owner3_percentage_gt?: Int;
  owner3_percentage_gte?: Int;
  AND?: VideoParametersWhereInput[] | VideoParametersWhereInput;
  OR?: VideoParametersWhereInput[] | VideoParametersWhereInput;
  NOT?: VideoParametersWhereInput[] | VideoParametersWhereInput;
}

export type VideoParametersForMonthWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface VideoParametersForMonthWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  year?: Int;
  year_not?: Int;
  year_in?: Int[] | Int;
  year_not_in?: Int[] | Int;
  year_lt?: Int;
  year_lte?: Int;
  year_gt?: Int;
  year_gte?: Int;
  month?: Int;
  month_not?: Int;
  month_in?: Int[] | Int;
  month_not_in?: Int[] | Int;
  month_lt?: Int;
  month_lte?: Int;
  month_gt?: Int;
  month_gte?: Int;
  video?: VideoWhereInput;
  owner1?: UserWhereInput;
  owner1_percentage?: Int;
  owner1_percentage_not?: Int;
  owner1_percentage_in?: Int[] | Int;
  owner1_percentage_not_in?: Int[] | Int;
  owner1_percentage_lt?: Int;
  owner1_percentage_lte?: Int;
  owner1_percentage_gt?: Int;
  owner1_percentage_gte?: Int;
  owner2?: UserWhereInput;
  owner2_percentage?: Int;
  owner2_percentage_not?: Int;
  owner2_percentage_in?: Int[] | Int;
  owner2_percentage_not_in?: Int[] | Int;
  owner2_percentage_lt?: Int;
  owner2_percentage_lte?: Int;
  owner2_percentage_gt?: Int;
  owner2_percentage_gte?: Int;
  owner3?: UserWhereInput;
  owner3_percentage?: Int;
  owner3_percentage_not?: Int;
  owner3_percentage_in?: Int[] | Int;
  owner3_percentage_not_in?: Int[] | Int;
  owner3_percentage_lt?: Int;
  owner3_percentage_lte?: Int;
  owner3_percentage_gt?: Int;
  owner3_percentage_gte?: Int;
  total_minutes?: Float;
  total_minutes_not?: Float;
  total_minutes_in?: Float[] | Float;
  total_minutes_not_in?: Float[] | Float;
  total_minutes_lt?: Float;
  total_minutes_lte?: Float;
  total_minutes_gt?: Float;
  total_minutes_gte?: Float;
  owner1_minutes?: Float;
  owner1_minutes_not?: Float;
  owner1_minutes_in?: Float[] | Float;
  owner1_minutes_not_in?: Float[] | Float;
  owner1_minutes_lt?: Float;
  owner1_minutes_lte?: Float;
  owner1_minutes_gt?: Float;
  owner1_minutes_gte?: Float;
  owner2_minutes?: Float;
  owner2_minutes_not?: Float;
  owner2_minutes_in?: Float[] | Float;
  owner2_minutes_not_in?: Float[] | Float;
  owner2_minutes_lt?: Float;
  owner2_minutes_lte?: Float;
  owner2_minutes_gt?: Float;
  owner2_minutes_gte?: Float;
  owner3_minutes?: Float;
  owner3_minutes_not?: Float;
  owner3_minutes_in?: Float[] | Float;
  owner3_minutes_not_in?: Float[] | Float;
  owner3_minutes_lt?: Float;
  owner3_minutes_lte?: Float;
  owner3_minutes_gt?: Float;
  owner3_minutes_gte?: Float;
  AND?: VideoParametersForMonthWhereInput[] | VideoParametersForMonthWhereInput;
  OR?: VideoParametersForMonthWhereInput[] | VideoParametersForMonthWhereInput;
  NOT?: VideoParametersForMonthWhereInput[] | VideoParametersForMonthWhereInput;
}

export type VideoTotalParametersWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface VideoTotalParametersWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  minutes_watched_multiplier?: Float;
  minutes_watched_multiplier_not?: Float;
  minutes_watched_multiplier_in?: Float[] | Float;
  minutes_watched_multiplier_not_in?: Float[] | Float;
  minutes_watched_multiplier_lt?: Float;
  minutes_watched_multiplier_lte?: Float;
  minutes_watched_multiplier_gt?: Float;
  minutes_watched_multiplier_gte?: Float;
  exponent_for_minutes_watched?: Float;
  exponent_for_minutes_watched_not?: Float;
  exponent_for_minutes_watched_in?: Float[] | Float;
  exponent_for_minutes_watched_not_in?: Float[] | Float;
  exponent_for_minutes_watched_lt?: Float;
  exponent_for_minutes_watched_lte?: Float;
  exponent_for_minutes_watched_gt?: Float;
  exponent_for_minutes_watched_gte?: Float;
  star_rating_multiplier?: Float;
  star_rating_multiplier_not?: Float;
  star_rating_multiplier_in?: Float[] | Float;
  star_rating_multiplier_not_in?: Float[] | Float;
  star_rating_multiplier_lt?: Float;
  star_rating_multiplier_lte?: Float;
  star_rating_multiplier_gt?: Float;
  star_rating_multiplier_gte?: Float;
  star_rating_on_off?: Int;
  star_rating_on_off_not?: Int;
  star_rating_on_off_in?: Int[] | Int;
  star_rating_on_off_not_in?: Int[] | Int;
  star_rating_on_off_lt?: Int;
  star_rating_on_off_lte?: Int;
  star_rating_on_off_gt?: Int;
  star_rating_on_off_gte?: Int;
  AND?: VideoTotalParametersWhereInput[] | VideoTotalParametersWhereInput;
  OR?: VideoTotalParametersWhereInput[] | VideoTotalParametersWhereInput;
  NOT?: VideoTotalParametersWhereInput[] | VideoTotalParametersWhereInput;
}

export type WatchedVideoUserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ActivationCodeCreateInput {
  email: String;
  valid_until: DateTimeInput;
  code: String;
}

export interface ActivationCodeUpdateInput {
  email?: String;
  valid_until?: DateTimeInput;
  code?: String;
}

export interface ActivationCodeUpdateManyMutationInput {
  email?: String;
  valid_until?: DateTimeInput;
  code?: String;
}

export interface ArtistFactorsCreateInput {
  artist: UserCreateOneInput;
  promotion_factor?: Float;
  minutes_exponent?: Float;
  finder_fee_factor?: Float;
  monthly_fee_duration?: Int;
  monthly_fee_amount_per_month?: Int;
  annual_fee_amount_per_month?: Int;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email: String;
  phone?: String;
  role?: UserRole;
  approved?: Boolean;
  password_hash: String;
  password_salt: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  payout_amount?: Int;
  payout_months_total?: Int;
  payout_months_left?: Int;
  payout_enabled?: Boolean;
  artist?: UserCreateOneWithoutUsersInput;
  users?: UserCreateManyWithoutArtistInput;
  front_id_scan?: String;
  back_id_scan?: String;
  my_videos?: VideoCreateManyWithoutAuthorInput;
  liked_videos?: VideoCreateManyWithoutLike_usersInput;
  watched_videos?: WatchedVideoUserCreateManyWithoutUserInput;
  my_subscription_users?: UserCreateManyWithoutSubscribed_usersInput;
  subscribed_users?: UserCreateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  my_promo_codes?: PromoCodeCreateManyWithoutUserInput;
  last_login_date?: DateTimeInput;
}

export interface UserCreateOneWithoutUsersInput {
  create?: UserCreateWithoutUsersInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutUsersInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email: String;
  phone?: String;
  role?: UserRole;
  approved?: Boolean;
  password_hash: String;
  password_salt: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  payout_amount?: Int;
  payout_months_total?: Int;
  payout_months_left?: Int;
  payout_enabled?: Boolean;
  artist?: UserCreateOneWithoutUsersInput;
  front_id_scan?: String;
  back_id_scan?: String;
  my_videos?: VideoCreateManyWithoutAuthorInput;
  liked_videos?: VideoCreateManyWithoutLike_usersInput;
  watched_videos?: WatchedVideoUserCreateManyWithoutUserInput;
  my_subscription_users?: UserCreateManyWithoutSubscribed_usersInput;
  subscribed_users?: UserCreateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  my_promo_codes?: PromoCodeCreateManyWithoutUserInput;
  last_login_date?: DateTimeInput;
}

export interface VideoCreateManyWithoutAuthorInput {
  create?: VideoCreateWithoutAuthorInput[] | VideoCreateWithoutAuthorInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
}

export interface VideoCreateWithoutAuthorInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  categories?: CategoryCreateManyWithoutVideosInput;
  like_users?: UserCreateManyWithoutLiked_videosInput;
  watched_users?: WatchedVideoUserCreateManyWithoutVideoInput;
  tags?: TagCreateManyWithoutVideosInput;
  deleted?: Boolean;
}

export interface CategoryCreateManyWithoutVideosInput {
  create?:
    | CategoryCreateWithoutVideosInput[]
    | CategoryCreateWithoutVideosInput;
  connect?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
}

export interface CategoryCreateWithoutVideosInput {
  title: String;
  description?: String;
}

export interface UserCreateManyWithoutLiked_videosInput {
  create?:
    | UserCreateWithoutLiked_videosInput[]
    | UserCreateWithoutLiked_videosInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutLiked_videosInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email: String;
  phone?: String;
  role?: UserRole;
  approved?: Boolean;
  password_hash: String;
  password_salt: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  payout_amount?: Int;
  payout_months_total?: Int;
  payout_months_left?: Int;
  payout_enabled?: Boolean;
  artist?: UserCreateOneWithoutUsersInput;
  users?: UserCreateManyWithoutArtistInput;
  front_id_scan?: String;
  back_id_scan?: String;
  my_videos?: VideoCreateManyWithoutAuthorInput;
  watched_videos?: WatchedVideoUserCreateManyWithoutUserInput;
  my_subscription_users?: UserCreateManyWithoutSubscribed_usersInput;
  subscribed_users?: UserCreateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  my_promo_codes?: PromoCodeCreateManyWithoutUserInput;
  last_login_date?: DateTimeInput;
}

export interface UserCreateManyWithoutArtistInput {
  create?: UserCreateWithoutArtistInput[] | UserCreateWithoutArtistInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutArtistInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email: String;
  phone?: String;
  role?: UserRole;
  approved?: Boolean;
  password_hash: String;
  password_salt: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  payout_amount?: Int;
  payout_months_total?: Int;
  payout_months_left?: Int;
  payout_enabled?: Boolean;
  users?: UserCreateManyWithoutArtistInput;
  front_id_scan?: String;
  back_id_scan?: String;
  my_videos?: VideoCreateManyWithoutAuthorInput;
  liked_videos?: VideoCreateManyWithoutLike_usersInput;
  watched_videos?: WatchedVideoUserCreateManyWithoutUserInput;
  my_subscription_users?: UserCreateManyWithoutSubscribed_usersInput;
  subscribed_users?: UserCreateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  my_promo_codes?: PromoCodeCreateManyWithoutUserInput;
  last_login_date?: DateTimeInput;
}

export interface VideoCreateManyWithoutLike_usersInput {
  create?:
    | VideoCreateWithoutLike_usersInput[]
    | VideoCreateWithoutLike_usersInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
}

export interface VideoCreateWithoutLike_usersInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  author: UserCreateOneWithoutMy_videosInput;
  categories?: CategoryCreateManyWithoutVideosInput;
  watched_users?: WatchedVideoUserCreateManyWithoutVideoInput;
  tags?: TagCreateManyWithoutVideosInput;
  deleted?: Boolean;
}

export interface UserCreateOneWithoutMy_videosInput {
  create?: UserCreateWithoutMy_videosInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutMy_videosInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email: String;
  phone?: String;
  role?: UserRole;
  approved?: Boolean;
  password_hash: String;
  password_salt: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  payout_amount?: Int;
  payout_months_total?: Int;
  payout_months_left?: Int;
  payout_enabled?: Boolean;
  artist?: UserCreateOneWithoutUsersInput;
  users?: UserCreateManyWithoutArtistInput;
  front_id_scan?: String;
  back_id_scan?: String;
  liked_videos?: VideoCreateManyWithoutLike_usersInput;
  watched_videos?: WatchedVideoUserCreateManyWithoutUserInput;
  my_subscription_users?: UserCreateManyWithoutSubscribed_usersInput;
  subscribed_users?: UserCreateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  my_promo_codes?: PromoCodeCreateManyWithoutUserInput;
  last_login_date?: DateTimeInput;
}

export interface WatchedVideoUserCreateManyWithoutUserInput {
  create?:
    | WatchedVideoUserCreateWithoutUserInput[]
    | WatchedVideoUserCreateWithoutUserInput;
  connect?:
    | WatchedVideoUserWhereUniqueInput[]
    | WatchedVideoUserWhereUniqueInput;
}

export interface WatchedVideoUserCreateWithoutUserInput {
  video?: VideoCreateOneWithoutWatched_usersInput;
  watched_seconds?: Int;
}

export interface VideoCreateOneWithoutWatched_usersInput {
  create?: VideoCreateWithoutWatched_usersInput;
  connect?: VideoWhereUniqueInput;
}

export interface VideoCreateWithoutWatched_usersInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  author: UserCreateOneWithoutMy_videosInput;
  categories?: CategoryCreateManyWithoutVideosInput;
  like_users?: UserCreateManyWithoutLiked_videosInput;
  tags?: TagCreateManyWithoutVideosInput;
  deleted?: Boolean;
}

export interface TagCreateManyWithoutVideosInput {
  create?: TagCreateWithoutVideosInput[] | TagCreateWithoutVideosInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
}

export interface TagCreateWithoutVideosInput {
  text: String;
}

export interface UserCreateManyWithoutSubscribed_usersInput {
  create?:
    | UserCreateWithoutSubscribed_usersInput[]
    | UserCreateWithoutSubscribed_usersInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutSubscribed_usersInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email: String;
  phone?: String;
  role?: UserRole;
  approved?: Boolean;
  password_hash: String;
  password_salt: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  payout_amount?: Int;
  payout_months_total?: Int;
  payout_months_left?: Int;
  payout_enabled?: Boolean;
  artist?: UserCreateOneWithoutUsersInput;
  users?: UserCreateManyWithoutArtistInput;
  front_id_scan?: String;
  back_id_scan?: String;
  my_videos?: VideoCreateManyWithoutAuthorInput;
  liked_videos?: VideoCreateManyWithoutLike_usersInput;
  watched_videos?: WatchedVideoUserCreateManyWithoutUserInput;
  my_subscription_users?: UserCreateManyWithoutSubscribed_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  my_promo_codes?: PromoCodeCreateManyWithoutUserInput;
  last_login_date?: DateTimeInput;
}

export interface PromoCodeCreateManyWithoutUserInput {
  create?: PromoCodeCreateWithoutUserInput[] | PromoCodeCreateWithoutUserInput;
  connect?: PromoCodeWhereUniqueInput[] | PromoCodeWhereUniqueInput;
}

export interface PromoCodeCreateWithoutUserInput {
  promo_code?: String;
  current_promo_code?: Boolean;
}

export interface UserCreateManyWithoutMy_subscription_usersInput {
  create?:
    | UserCreateWithoutMy_subscription_usersInput[]
    | UserCreateWithoutMy_subscription_usersInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutMy_subscription_usersInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email: String;
  phone?: String;
  role?: UserRole;
  approved?: Boolean;
  password_hash: String;
  password_salt: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  payout_amount?: Int;
  payout_months_total?: Int;
  payout_months_left?: Int;
  payout_enabled?: Boolean;
  artist?: UserCreateOneWithoutUsersInput;
  users?: UserCreateManyWithoutArtistInput;
  front_id_scan?: String;
  back_id_scan?: String;
  my_videos?: VideoCreateManyWithoutAuthorInput;
  liked_videos?: VideoCreateManyWithoutLike_usersInput;
  watched_videos?: WatchedVideoUserCreateManyWithoutUserInput;
  subscribed_users?: UserCreateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  my_promo_codes?: PromoCodeCreateManyWithoutUserInput;
  last_login_date?: DateTimeInput;
}

export interface WatchedVideoUserCreateManyWithoutVideoInput {
  create?:
    | WatchedVideoUserCreateWithoutVideoInput[]
    | WatchedVideoUserCreateWithoutVideoInput;
  connect?:
    | WatchedVideoUserWhereUniqueInput[]
    | WatchedVideoUserWhereUniqueInput;
}

export interface WatchedVideoUserCreateWithoutVideoInput {
  user: UserCreateOneWithoutWatched_videosInput;
  watched_seconds?: Int;
}

export interface UserCreateOneWithoutWatched_videosInput {
  create?: UserCreateWithoutWatched_videosInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutWatched_videosInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email: String;
  phone?: String;
  role?: UserRole;
  approved?: Boolean;
  password_hash: String;
  password_salt: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  payout_amount?: Int;
  payout_months_total?: Int;
  payout_months_left?: Int;
  payout_enabled?: Boolean;
  artist?: UserCreateOneWithoutUsersInput;
  users?: UserCreateManyWithoutArtistInput;
  front_id_scan?: String;
  back_id_scan?: String;
  my_videos?: VideoCreateManyWithoutAuthorInput;
  liked_videos?: VideoCreateManyWithoutLike_usersInput;
  my_subscription_users?: UserCreateManyWithoutSubscribed_usersInput;
  subscribed_users?: UserCreateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  my_promo_codes?: PromoCodeCreateManyWithoutUserInput;
  last_login_date?: DateTimeInput;
}

export interface ArtistFactorsUpdateInput {
  artist?: UserUpdateOneRequiredInput;
  promotion_factor?: Float;
  minutes_exponent?: Float;
  finder_fee_factor?: Float;
  monthly_fee_duration?: Int;
  monthly_fee_amount_per_month?: Int;
  annual_fee_amount_per_month?: Int;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateDataInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email?: String;
  phone?: String;
  role?: UserRole;
  approved?: Boolean;
  password_hash?: String;
  password_salt?: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  payout_amount?: Int;
  payout_months_total?: Int;
  payout_months_left?: Int;
  payout_enabled?: Boolean;
  artist?: UserUpdateOneWithoutUsersInput;
  users?: UserUpdateManyWithoutArtistInput;
  front_id_scan?: String;
  back_id_scan?: String;
  my_videos?: VideoUpdateManyWithoutAuthorInput;
  liked_videos?: VideoUpdateManyWithoutLike_usersInput;
  watched_videos?: WatchedVideoUserUpdateManyWithoutUserInput;
  my_subscription_users?: UserUpdateManyWithoutSubscribed_usersInput;
  subscribed_users?: UserUpdateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  my_promo_codes?: PromoCodeUpdateManyWithoutUserInput;
  last_login_date?: DateTimeInput;
}

export interface UserUpdateOneWithoutUsersInput {
  create?: UserCreateWithoutUsersInput;
  update?: UserUpdateWithoutUsersDataInput;
  upsert?: UserUpsertWithoutUsersInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutUsersDataInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email?: String;
  phone?: String;
  role?: UserRole;
  approved?: Boolean;
  password_hash?: String;
  password_salt?: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  payout_amount?: Int;
  payout_months_total?: Int;
  payout_months_left?: Int;
  payout_enabled?: Boolean;
  artist?: UserUpdateOneWithoutUsersInput;
  front_id_scan?: String;
  back_id_scan?: String;
  my_videos?: VideoUpdateManyWithoutAuthorInput;
  liked_videos?: VideoUpdateManyWithoutLike_usersInput;
  watched_videos?: WatchedVideoUserUpdateManyWithoutUserInput;
  my_subscription_users?: UserUpdateManyWithoutSubscribed_usersInput;
  subscribed_users?: UserUpdateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  my_promo_codes?: PromoCodeUpdateManyWithoutUserInput;
  last_login_date?: DateTimeInput;
}

export interface VideoUpdateManyWithoutAuthorInput {
  create?: VideoCreateWithoutAuthorInput[] | VideoCreateWithoutAuthorInput;
  delete?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  set?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  disconnect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  update?:
    | VideoUpdateWithWhereUniqueWithoutAuthorInput[]
    | VideoUpdateWithWhereUniqueWithoutAuthorInput;
  upsert?:
    | VideoUpsertWithWhereUniqueWithoutAuthorInput[]
    | VideoUpsertWithWhereUniqueWithoutAuthorInput;
  deleteMany?: VideoScalarWhereInput[] | VideoScalarWhereInput;
  updateMany?:
    | VideoUpdateManyWithWhereNestedInput[]
    | VideoUpdateManyWithWhereNestedInput;
}

export interface VideoUpdateWithWhereUniqueWithoutAuthorInput {
  where: VideoWhereUniqueInput;
  data: VideoUpdateWithoutAuthorDataInput;
}

export interface VideoUpdateWithoutAuthorDataInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  categories?: CategoryUpdateManyWithoutVideosInput;
  like_users?: UserUpdateManyWithoutLiked_videosInput;
  watched_users?: WatchedVideoUserUpdateManyWithoutVideoInput;
  tags?: TagUpdateManyWithoutVideosInput;
  deleted?: Boolean;
}

export interface CategoryUpdateManyWithoutVideosInput {
  create?:
    | CategoryCreateWithoutVideosInput[]
    | CategoryCreateWithoutVideosInput;
  delete?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
  connect?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
  set?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
  disconnect?: CategoryWhereUniqueInput[] | CategoryWhereUniqueInput;
  update?:
    | CategoryUpdateWithWhereUniqueWithoutVideosInput[]
    | CategoryUpdateWithWhereUniqueWithoutVideosInput;
  upsert?:
    | CategoryUpsertWithWhereUniqueWithoutVideosInput[]
    | CategoryUpsertWithWhereUniqueWithoutVideosInput;
  deleteMany?: CategoryScalarWhereInput[] | CategoryScalarWhereInput;
  updateMany?:
    | CategoryUpdateManyWithWhereNestedInput[]
    | CategoryUpdateManyWithWhereNestedInput;
}

export interface CategoryUpdateWithWhereUniqueWithoutVideosInput {
  where: CategoryWhereUniqueInput;
  data: CategoryUpdateWithoutVideosDataInput;
}

export interface CategoryUpdateWithoutVideosDataInput {
  title?: String;
  description?: String;
}

export interface CategoryUpsertWithWhereUniqueWithoutVideosInput {
  where: CategoryWhereUniqueInput;
  update: CategoryUpdateWithoutVideosDataInput;
  create: CategoryCreateWithoutVideosInput;
}

export interface CategoryScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: CategoryScalarWhereInput[] | CategoryScalarWhereInput;
  OR?: CategoryScalarWhereInput[] | CategoryScalarWhereInput;
  NOT?: CategoryScalarWhereInput[] | CategoryScalarWhereInput;
}

export interface CategoryUpdateManyWithWhereNestedInput {
  where: CategoryScalarWhereInput;
  data: CategoryUpdateManyDataInput;
}

export interface CategoryUpdateManyDataInput {
  title?: String;
  description?: String;
}

export interface UserUpdateManyWithoutLiked_videosInput {
  create?:
    | UserCreateWithoutLiked_videosInput[]
    | UserCreateWithoutLiked_videosInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutLiked_videosInput[]
    | UserUpdateWithWhereUniqueWithoutLiked_videosInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutLiked_videosInput[]
    | UserUpsertWithWhereUniqueWithoutLiked_videosInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutLiked_videosInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutLiked_videosDataInput;
}

export interface UserUpdateWithoutLiked_videosDataInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email?: String;
  phone?: String;
  role?: UserRole;
  approved?: Boolean;
  password_hash?: String;
  password_salt?: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  payout_amount?: Int;
  payout_months_total?: Int;
  payout_months_left?: Int;
  payout_enabled?: Boolean;
  artist?: UserUpdateOneWithoutUsersInput;
  users?: UserUpdateManyWithoutArtistInput;
  front_id_scan?: String;
  back_id_scan?: String;
  my_videos?: VideoUpdateManyWithoutAuthorInput;
  watched_videos?: WatchedVideoUserUpdateManyWithoutUserInput;
  my_subscription_users?: UserUpdateManyWithoutSubscribed_usersInput;
  subscribed_users?: UserUpdateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  my_promo_codes?: PromoCodeUpdateManyWithoutUserInput;
  last_login_date?: DateTimeInput;
}

export interface UserUpdateManyWithoutArtistInput {
  create?: UserCreateWithoutArtistInput[] | UserCreateWithoutArtistInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutArtistInput[]
    | UserUpdateWithWhereUniqueWithoutArtistInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutArtistInput[]
    | UserUpsertWithWhereUniqueWithoutArtistInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutArtistInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutArtistDataInput;
}

export interface UserUpdateWithoutArtistDataInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email?: String;
  phone?: String;
  role?: UserRole;
  approved?: Boolean;
  password_hash?: String;
  password_salt?: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  payout_amount?: Int;
  payout_months_total?: Int;
  payout_months_left?: Int;
  payout_enabled?: Boolean;
  users?: UserUpdateManyWithoutArtistInput;
  front_id_scan?: String;
  back_id_scan?: String;
  my_videos?: VideoUpdateManyWithoutAuthorInput;
  liked_videos?: VideoUpdateManyWithoutLike_usersInput;
  watched_videos?: WatchedVideoUserUpdateManyWithoutUserInput;
  my_subscription_users?: UserUpdateManyWithoutSubscribed_usersInput;
  subscribed_users?: UserUpdateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  my_promo_codes?: PromoCodeUpdateManyWithoutUserInput;
  last_login_date?: DateTimeInput;
}

export interface VideoUpdateManyWithoutLike_usersInput {
  create?:
    | VideoCreateWithoutLike_usersInput[]
    | VideoCreateWithoutLike_usersInput;
  delete?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  set?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  disconnect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  update?:
    | VideoUpdateWithWhereUniqueWithoutLike_usersInput[]
    | VideoUpdateWithWhereUniqueWithoutLike_usersInput;
  upsert?:
    | VideoUpsertWithWhereUniqueWithoutLike_usersInput[]
    | VideoUpsertWithWhereUniqueWithoutLike_usersInput;
  deleteMany?: VideoScalarWhereInput[] | VideoScalarWhereInput;
  updateMany?:
    | VideoUpdateManyWithWhereNestedInput[]
    | VideoUpdateManyWithWhereNestedInput;
}

export interface VideoUpdateWithWhereUniqueWithoutLike_usersInput {
  where: VideoWhereUniqueInput;
  data: VideoUpdateWithoutLike_usersDataInput;
}

export interface VideoUpdateWithoutLike_usersDataInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  author?: UserUpdateOneRequiredWithoutMy_videosInput;
  categories?: CategoryUpdateManyWithoutVideosInput;
  watched_users?: WatchedVideoUserUpdateManyWithoutVideoInput;
  tags?: TagUpdateManyWithoutVideosInput;
  deleted?: Boolean;
}

export interface UserUpdateOneRequiredWithoutMy_videosInput {
  create?: UserCreateWithoutMy_videosInput;
  update?: UserUpdateWithoutMy_videosDataInput;
  upsert?: UserUpsertWithoutMy_videosInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutMy_videosDataInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email?: String;
  phone?: String;
  role?: UserRole;
  approved?: Boolean;
  password_hash?: String;
  password_salt?: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  payout_amount?: Int;
  payout_months_total?: Int;
  payout_months_left?: Int;
  payout_enabled?: Boolean;
  artist?: UserUpdateOneWithoutUsersInput;
  users?: UserUpdateManyWithoutArtistInput;
  front_id_scan?: String;
  back_id_scan?: String;
  liked_videos?: VideoUpdateManyWithoutLike_usersInput;
  watched_videos?: WatchedVideoUserUpdateManyWithoutUserInput;
  my_subscription_users?: UserUpdateManyWithoutSubscribed_usersInput;
  subscribed_users?: UserUpdateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  my_promo_codes?: PromoCodeUpdateManyWithoutUserInput;
  last_login_date?: DateTimeInput;
}

export interface WatchedVideoUserUpdateManyWithoutUserInput {
  create?:
    | WatchedVideoUserCreateWithoutUserInput[]
    | WatchedVideoUserCreateWithoutUserInput;
  delete?:
    | WatchedVideoUserWhereUniqueInput[]
    | WatchedVideoUserWhereUniqueInput;
  connect?:
    | WatchedVideoUserWhereUniqueInput[]
    | WatchedVideoUserWhereUniqueInput;
  set?: WatchedVideoUserWhereUniqueInput[] | WatchedVideoUserWhereUniqueInput;
  disconnect?:
    | WatchedVideoUserWhereUniqueInput[]
    | WatchedVideoUserWhereUniqueInput;
  update?:
    | WatchedVideoUserUpdateWithWhereUniqueWithoutUserInput[]
    | WatchedVideoUserUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | WatchedVideoUserUpsertWithWhereUniqueWithoutUserInput[]
    | WatchedVideoUserUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?:
    | WatchedVideoUserScalarWhereInput[]
    | WatchedVideoUserScalarWhereInput;
  updateMany?:
    | WatchedVideoUserUpdateManyWithWhereNestedInput[]
    | WatchedVideoUserUpdateManyWithWhereNestedInput;
}

export interface WatchedVideoUserUpdateWithWhereUniqueWithoutUserInput {
  where: WatchedVideoUserWhereUniqueInput;
  data: WatchedVideoUserUpdateWithoutUserDataInput;
}

export interface WatchedVideoUserUpdateWithoutUserDataInput {
  video?: VideoUpdateOneWithoutWatched_usersInput;
  watched_seconds?: Int;
}

export interface VideoUpdateOneWithoutWatched_usersInput {
  create?: VideoCreateWithoutWatched_usersInput;
  update?: VideoUpdateWithoutWatched_usersDataInput;
  upsert?: VideoUpsertWithoutWatched_usersInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: VideoWhereUniqueInput;
}

export interface VideoUpdateWithoutWatched_usersDataInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  author?: UserUpdateOneRequiredWithoutMy_videosInput;
  categories?: CategoryUpdateManyWithoutVideosInput;
  like_users?: UserUpdateManyWithoutLiked_videosInput;
  tags?: TagUpdateManyWithoutVideosInput;
  deleted?: Boolean;
}

export interface TagUpdateManyWithoutVideosInput {
  create?: TagCreateWithoutVideosInput[] | TagCreateWithoutVideosInput;
  delete?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  set?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  disconnect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  update?:
    | TagUpdateWithWhereUniqueWithoutVideosInput[]
    | TagUpdateWithWhereUniqueWithoutVideosInput;
  upsert?:
    | TagUpsertWithWhereUniqueWithoutVideosInput[]
    | TagUpsertWithWhereUniqueWithoutVideosInput;
  deleteMany?: TagScalarWhereInput[] | TagScalarWhereInput;
  updateMany?:
    | TagUpdateManyWithWhereNestedInput[]
    | TagUpdateManyWithWhereNestedInput;
}

export interface TagUpdateWithWhereUniqueWithoutVideosInput {
  where: TagWhereUniqueInput;
  data: TagUpdateWithoutVideosDataInput;
}

export interface TagUpdateWithoutVideosDataInput {
  text?: String;
}

export interface TagUpsertWithWhereUniqueWithoutVideosInput {
  where: TagWhereUniqueInput;
  update: TagUpdateWithoutVideosDataInput;
  create: TagCreateWithoutVideosInput;
}

export interface TagScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  AND?: TagScalarWhereInput[] | TagScalarWhereInput;
  OR?: TagScalarWhereInput[] | TagScalarWhereInput;
  NOT?: TagScalarWhereInput[] | TagScalarWhereInput;
}

export interface TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput;
  data: TagUpdateManyDataInput;
}

export interface TagUpdateManyDataInput {
  text?: String;
}

export interface VideoUpsertWithoutWatched_usersInput {
  update: VideoUpdateWithoutWatched_usersDataInput;
  create: VideoCreateWithoutWatched_usersInput;
}

export interface WatchedVideoUserUpsertWithWhereUniqueWithoutUserInput {
  where: WatchedVideoUserWhereUniqueInput;
  update: WatchedVideoUserUpdateWithoutUserDataInput;
  create: WatchedVideoUserCreateWithoutUserInput;
}

export interface WatchedVideoUserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  watched_seconds?: Int;
  watched_seconds_not?: Int;
  watched_seconds_in?: Int[] | Int;
  watched_seconds_not_in?: Int[] | Int;
  watched_seconds_lt?: Int;
  watched_seconds_lte?: Int;
  watched_seconds_gt?: Int;
  watched_seconds_gte?: Int;
  AND?: WatchedVideoUserScalarWhereInput[] | WatchedVideoUserScalarWhereInput;
  OR?: WatchedVideoUserScalarWhereInput[] | WatchedVideoUserScalarWhereInput;
  NOT?: WatchedVideoUserScalarWhereInput[] | WatchedVideoUserScalarWhereInput;
}

export interface WatchedVideoUserUpdateManyWithWhereNestedInput {
  where: WatchedVideoUserScalarWhereInput;
  data: WatchedVideoUserUpdateManyDataInput;
}

export interface WatchedVideoUserUpdateManyDataInput {
  watched_seconds?: Int;
}

export interface UserUpdateManyWithoutSubscribed_usersInput {
  create?:
    | UserCreateWithoutSubscribed_usersInput[]
    | UserCreateWithoutSubscribed_usersInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutSubscribed_usersInput[]
    | UserUpdateWithWhereUniqueWithoutSubscribed_usersInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutSubscribed_usersInput[]
    | UserUpsertWithWhereUniqueWithoutSubscribed_usersInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutSubscribed_usersInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutSubscribed_usersDataInput;
}

export interface UserUpdateWithoutSubscribed_usersDataInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email?: String;
  phone?: String;
  role?: UserRole;
  approved?: Boolean;
  password_hash?: String;
  password_salt?: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  payout_amount?: Int;
  payout_months_total?: Int;
  payout_months_left?: Int;
  payout_enabled?: Boolean;
  artist?: UserUpdateOneWithoutUsersInput;
  users?: UserUpdateManyWithoutArtistInput;
  front_id_scan?: String;
  back_id_scan?: String;
  my_videos?: VideoUpdateManyWithoutAuthorInput;
  liked_videos?: VideoUpdateManyWithoutLike_usersInput;
  watched_videos?: WatchedVideoUserUpdateManyWithoutUserInput;
  my_subscription_users?: UserUpdateManyWithoutSubscribed_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  my_promo_codes?: PromoCodeUpdateManyWithoutUserInput;
  last_login_date?: DateTimeInput;
}

export interface PromoCodeUpdateManyWithoutUserInput {
  create?: PromoCodeCreateWithoutUserInput[] | PromoCodeCreateWithoutUserInput;
  delete?: PromoCodeWhereUniqueInput[] | PromoCodeWhereUniqueInput;
  connect?: PromoCodeWhereUniqueInput[] | PromoCodeWhereUniqueInput;
  set?: PromoCodeWhereUniqueInput[] | PromoCodeWhereUniqueInput;
  disconnect?: PromoCodeWhereUniqueInput[] | PromoCodeWhereUniqueInput;
  update?:
    | PromoCodeUpdateWithWhereUniqueWithoutUserInput[]
    | PromoCodeUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | PromoCodeUpsertWithWhereUniqueWithoutUserInput[]
    | PromoCodeUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: PromoCodeScalarWhereInput[] | PromoCodeScalarWhereInput;
  updateMany?:
    | PromoCodeUpdateManyWithWhereNestedInput[]
    | PromoCodeUpdateManyWithWhereNestedInput;
}

export interface PromoCodeUpdateWithWhereUniqueWithoutUserInput {
  where: PromoCodeWhereUniqueInput;
  data: PromoCodeUpdateWithoutUserDataInput;
}

export interface PromoCodeUpdateWithoutUserDataInput {
  promo_code?: String;
  current_promo_code?: Boolean;
}

export interface PromoCodeUpsertWithWhereUniqueWithoutUserInput {
  where: PromoCodeWhereUniqueInput;
  update: PromoCodeUpdateWithoutUserDataInput;
  create: PromoCodeCreateWithoutUserInput;
}

export interface PromoCodeScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  promo_code?: String;
  promo_code_not?: String;
  promo_code_in?: String[] | String;
  promo_code_not_in?: String[] | String;
  promo_code_lt?: String;
  promo_code_lte?: String;
  promo_code_gt?: String;
  promo_code_gte?: String;
  promo_code_contains?: String;
  promo_code_not_contains?: String;
  promo_code_starts_with?: String;
  promo_code_not_starts_with?: String;
  promo_code_ends_with?: String;
  promo_code_not_ends_with?: String;
  current_promo_code?: Boolean;
  current_promo_code_not?: Boolean;
  AND?: PromoCodeScalarWhereInput[] | PromoCodeScalarWhereInput;
  OR?: PromoCodeScalarWhereInput[] | PromoCodeScalarWhereInput;
  NOT?: PromoCodeScalarWhereInput[] | PromoCodeScalarWhereInput;
}

export interface PromoCodeUpdateManyWithWhereNestedInput {
  where: PromoCodeScalarWhereInput;
  data: PromoCodeUpdateManyDataInput;
}

export interface PromoCodeUpdateManyDataInput {
  promo_code?: String;
  current_promo_code?: Boolean;
}

export interface UserUpsertWithWhereUniqueWithoutSubscribed_usersInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutSubscribed_usersDataInput;
  create: UserCreateWithoutSubscribed_usersInput;
}

export interface UserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  firstname?: String;
  firstname_not?: String;
  firstname_in?: String[] | String;
  firstname_not_in?: String[] | String;
  firstname_lt?: String;
  firstname_lte?: String;
  firstname_gt?: String;
  firstname_gte?: String;
  firstname_contains?: String;
  firstname_not_contains?: String;
  firstname_starts_with?: String;
  firstname_not_starts_with?: String;
  firstname_ends_with?: String;
  firstname_not_ends_with?: String;
  lastname?: String;
  lastname_not?: String;
  lastname_in?: String[] | String;
  lastname_not_in?: String[] | String;
  lastname_lt?: String;
  lastname_lte?: String;
  lastname_gt?: String;
  lastname_gte?: String;
  lastname_contains?: String;
  lastname_not_contains?: String;
  lastname_starts_with?: String;
  lastname_not_starts_with?: String;
  lastname_ends_with?: String;
  lastname_not_ends_with?: String;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  role?: UserRole;
  role_not?: UserRole;
  role_in?: UserRole[] | UserRole;
  role_not_in?: UserRole[] | UserRole;
  approved?: Boolean;
  approved_not?: Boolean;
  password_hash?: String;
  password_hash_not?: String;
  password_hash_in?: String[] | String;
  password_hash_not_in?: String[] | String;
  password_hash_lt?: String;
  password_hash_lte?: String;
  password_hash_gt?: String;
  password_hash_gte?: String;
  password_hash_contains?: String;
  password_hash_not_contains?: String;
  password_hash_starts_with?: String;
  password_hash_not_starts_with?: String;
  password_hash_ends_with?: String;
  password_hash_not_ends_with?: String;
  password_salt?: String;
  password_salt_not?: String;
  password_salt_in?: String[] | String;
  password_salt_not_in?: String[] | String;
  password_salt_lt?: String;
  password_salt_lte?: String;
  password_salt_gt?: String;
  password_salt_gte?: String;
  password_salt_contains?: String;
  password_salt_not_contains?: String;
  password_salt_starts_with?: String;
  password_salt_not_starts_with?: String;
  password_salt_ends_with?: String;
  password_salt_not_ends_with?: String;
  avatar?: String;
  avatar_not?: String;
  avatar_in?: String[] | String;
  avatar_not_in?: String[] | String;
  avatar_lt?: String;
  avatar_lte?: String;
  avatar_gt?: String;
  avatar_gte?: String;
  avatar_contains?: String;
  avatar_not_contains?: String;
  avatar_starts_with?: String;
  avatar_not_starts_with?: String;
  avatar_ends_with?: String;
  avatar_not_ends_with?: String;
  background_image?: String;
  background_image_not?: String;
  background_image_in?: String[] | String;
  background_image_not_in?: String[] | String;
  background_image_lt?: String;
  background_image_lte?: String;
  background_image_gt?: String;
  background_image_gte?: String;
  background_image_contains?: String;
  background_image_not_contains?: String;
  background_image_starts_with?: String;
  background_image_not_starts_with?: String;
  background_image_ends_with?: String;
  background_image_not_ends_with?: String;
  about_text?: String;
  about_text_not?: String;
  about_text_in?: String[] | String;
  about_text_not_in?: String[] | String;
  about_text_lt?: String;
  about_text_lte?: String;
  about_text_gt?: String;
  about_text_gte?: String;
  about_text_contains?: String;
  about_text_not_contains?: String;
  about_text_starts_with?: String;
  about_text_not_starts_with?: String;
  about_text_ends_with?: String;
  about_text_not_ends_with?: String;
  payout_amount?: Int;
  payout_amount_not?: Int;
  payout_amount_in?: Int[] | Int;
  payout_amount_not_in?: Int[] | Int;
  payout_amount_lt?: Int;
  payout_amount_lte?: Int;
  payout_amount_gt?: Int;
  payout_amount_gte?: Int;
  payout_months_total?: Int;
  payout_months_total_not?: Int;
  payout_months_total_in?: Int[] | Int;
  payout_months_total_not_in?: Int[] | Int;
  payout_months_total_lt?: Int;
  payout_months_total_lte?: Int;
  payout_months_total_gt?: Int;
  payout_months_total_gte?: Int;
  payout_months_left?: Int;
  payout_months_left_not?: Int;
  payout_months_left_in?: Int[] | Int;
  payout_months_left_not_in?: Int[] | Int;
  payout_months_left_lt?: Int;
  payout_months_left_lte?: Int;
  payout_months_left_gt?: Int;
  payout_months_left_gte?: Int;
  payout_enabled?: Boolean;
  payout_enabled_not?: Boolean;
  front_id_scan?: String;
  front_id_scan_not?: String;
  front_id_scan_in?: String[] | String;
  front_id_scan_not_in?: String[] | String;
  front_id_scan_lt?: String;
  front_id_scan_lte?: String;
  front_id_scan_gt?: String;
  front_id_scan_gte?: String;
  front_id_scan_contains?: String;
  front_id_scan_not_contains?: String;
  front_id_scan_starts_with?: String;
  front_id_scan_not_starts_with?: String;
  front_id_scan_ends_with?: String;
  front_id_scan_not_ends_with?: String;
  back_id_scan?: String;
  back_id_scan_not?: String;
  back_id_scan_in?: String[] | String;
  back_id_scan_not_in?: String[] | String;
  back_id_scan_lt?: String;
  back_id_scan_lte?: String;
  back_id_scan_gt?: String;
  back_id_scan_gte?: String;
  back_id_scan_contains?: String;
  back_id_scan_not_contains?: String;
  back_id_scan_starts_with?: String;
  back_id_scan_not_starts_with?: String;
  back_id_scan_ends_with?: String;
  back_id_scan_not_ends_with?: String;
  billing_subscription_active?: Boolean;
  billing_subscription_active_not?: Boolean;
  stripe_customer_id?: String;
  stripe_customer_id_not?: String;
  stripe_customer_id_in?: String[] | String;
  stripe_customer_id_not_in?: String[] | String;
  stripe_customer_id_lt?: String;
  stripe_customer_id_lte?: String;
  stripe_customer_id_gt?: String;
  stripe_customer_id_gte?: String;
  stripe_customer_id_contains?: String;
  stripe_customer_id_not_contains?: String;
  stripe_customer_id_starts_with?: String;
  stripe_customer_id_not_starts_with?: String;
  stripe_customer_id_ends_with?: String;
  stripe_customer_id_not_ends_with?: String;
  last_login_date?: DateTimeInput;
  last_login_date_not?: DateTimeInput;
  last_login_date_in?: DateTimeInput[] | DateTimeInput;
  last_login_date_not_in?: DateTimeInput[] | DateTimeInput;
  last_login_date_lt?: DateTimeInput;
  last_login_date_lte?: DateTimeInput;
  last_login_date_gt?: DateTimeInput;
  last_login_date_gte?: DateTimeInput;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email?: String;
  phone?: String;
  role?: UserRole;
  approved?: Boolean;
  password_hash?: String;
  password_salt?: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  payout_amount?: Int;
  payout_months_total?: Int;
  payout_months_left?: Int;
  payout_enabled?: Boolean;
  front_id_scan?: String;
  back_id_scan?: String;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  last_login_date?: DateTimeInput;
}

export interface UserUpdateManyWithoutMy_subscription_usersInput {
  create?:
    | UserCreateWithoutMy_subscription_usersInput[]
    | UserCreateWithoutMy_subscription_usersInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutMy_subscription_usersInput[]
    | UserUpdateWithWhereUniqueWithoutMy_subscription_usersInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutMy_subscription_usersInput[]
    | UserUpsertWithWhereUniqueWithoutMy_subscription_usersInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutMy_subscription_usersInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutMy_subscription_usersDataInput;
}

export interface UserUpdateWithoutMy_subscription_usersDataInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email?: String;
  phone?: String;
  role?: UserRole;
  approved?: Boolean;
  password_hash?: String;
  password_salt?: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  payout_amount?: Int;
  payout_months_total?: Int;
  payout_months_left?: Int;
  payout_enabled?: Boolean;
  artist?: UserUpdateOneWithoutUsersInput;
  users?: UserUpdateManyWithoutArtistInput;
  front_id_scan?: String;
  back_id_scan?: String;
  my_videos?: VideoUpdateManyWithoutAuthorInput;
  liked_videos?: VideoUpdateManyWithoutLike_usersInput;
  watched_videos?: WatchedVideoUserUpdateManyWithoutUserInput;
  subscribed_users?: UserUpdateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  my_promo_codes?: PromoCodeUpdateManyWithoutUserInput;
  last_login_date?: DateTimeInput;
}

export interface UserUpsertWithWhereUniqueWithoutMy_subscription_usersInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutMy_subscription_usersDataInput;
  create: UserCreateWithoutMy_subscription_usersInput;
}

export interface UserUpsertWithoutMy_videosInput {
  update: UserUpdateWithoutMy_videosDataInput;
  create: UserCreateWithoutMy_videosInput;
}

export interface WatchedVideoUserUpdateManyWithoutVideoInput {
  create?:
    | WatchedVideoUserCreateWithoutVideoInput[]
    | WatchedVideoUserCreateWithoutVideoInput;
  delete?:
    | WatchedVideoUserWhereUniqueInput[]
    | WatchedVideoUserWhereUniqueInput;
  connect?:
    | WatchedVideoUserWhereUniqueInput[]
    | WatchedVideoUserWhereUniqueInput;
  set?: WatchedVideoUserWhereUniqueInput[] | WatchedVideoUserWhereUniqueInput;
  disconnect?:
    | WatchedVideoUserWhereUniqueInput[]
    | WatchedVideoUserWhereUniqueInput;
  update?:
    | WatchedVideoUserUpdateWithWhereUniqueWithoutVideoInput[]
    | WatchedVideoUserUpdateWithWhereUniqueWithoutVideoInput;
  upsert?:
    | WatchedVideoUserUpsertWithWhereUniqueWithoutVideoInput[]
    | WatchedVideoUserUpsertWithWhereUniqueWithoutVideoInput;
  deleteMany?:
    | WatchedVideoUserScalarWhereInput[]
    | WatchedVideoUserScalarWhereInput;
  updateMany?:
    | WatchedVideoUserUpdateManyWithWhereNestedInput[]
    | WatchedVideoUserUpdateManyWithWhereNestedInput;
}

export interface WatchedVideoUserUpdateWithWhereUniqueWithoutVideoInput {
  where: WatchedVideoUserWhereUniqueInput;
  data: WatchedVideoUserUpdateWithoutVideoDataInput;
}

export interface WatchedVideoUserUpdateWithoutVideoDataInput {
  user?: UserUpdateOneRequiredWithoutWatched_videosInput;
  watched_seconds?: Int;
}

export interface UserUpdateOneRequiredWithoutWatched_videosInput {
  create?: UserCreateWithoutWatched_videosInput;
  update?: UserUpdateWithoutWatched_videosDataInput;
  upsert?: UserUpsertWithoutWatched_videosInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutWatched_videosDataInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email?: String;
  phone?: String;
  role?: UserRole;
  approved?: Boolean;
  password_hash?: String;
  password_salt?: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  payout_amount?: Int;
  payout_months_total?: Int;
  payout_months_left?: Int;
  payout_enabled?: Boolean;
  artist?: UserUpdateOneWithoutUsersInput;
  users?: UserUpdateManyWithoutArtistInput;
  front_id_scan?: String;
  back_id_scan?: String;
  my_videos?: VideoUpdateManyWithoutAuthorInput;
  liked_videos?: VideoUpdateManyWithoutLike_usersInput;
  my_subscription_users?: UserUpdateManyWithoutSubscribed_usersInput;
  subscribed_users?: UserUpdateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  my_promo_codes?: PromoCodeUpdateManyWithoutUserInput;
  last_login_date?: DateTimeInput;
}

export interface UserUpsertWithoutWatched_videosInput {
  update: UserUpdateWithoutWatched_videosDataInput;
  create: UserCreateWithoutWatched_videosInput;
}

export interface WatchedVideoUserUpsertWithWhereUniqueWithoutVideoInput {
  where: WatchedVideoUserWhereUniqueInput;
  update: WatchedVideoUserUpdateWithoutVideoDataInput;
  create: WatchedVideoUserCreateWithoutVideoInput;
}

export interface VideoUpsertWithWhereUniqueWithoutLike_usersInput {
  where: VideoWhereUniqueInput;
  update: VideoUpdateWithoutLike_usersDataInput;
  create: VideoCreateWithoutLike_usersInput;
}

export interface VideoScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  publish_date?: DateTimeInput;
  publish_date_not?: DateTimeInput;
  publish_date_in?: DateTimeInput[] | DateTimeInput;
  publish_date_not_in?: DateTimeInput[] | DateTimeInput;
  publish_date_lt?: DateTimeInput;
  publish_date_lte?: DateTimeInput;
  publish_date_gt?: DateTimeInput;
  publish_date_gte?: DateTimeInput;
  file_url?: String;
  file_url_not?: String;
  file_url_in?: String[] | String;
  file_url_not_in?: String[] | String;
  file_url_lt?: String;
  file_url_lte?: String;
  file_url_gt?: String;
  file_url_gte?: String;
  file_url_contains?: String;
  file_url_not_contains?: String;
  file_url_starts_with?: String;
  file_url_not_starts_with?: String;
  file_url_ends_with?: String;
  file_url_not_ends_with?: String;
  video_duration?: Int;
  video_duration_not?: Int;
  video_duration_in?: Int[] | Int;
  video_duration_not_in?: Int[] | Int;
  video_duration_lt?: Int;
  video_duration_lte?: Int;
  video_duration_gt?: Int;
  video_duration_gte?: Int;
  preview_url?: String;
  preview_url_not?: String;
  preview_url_in?: String[] | String;
  preview_url_not_in?: String[] | String;
  preview_url_lt?: String;
  preview_url_lte?: String;
  preview_url_gt?: String;
  preview_url_gte?: String;
  preview_url_contains?: String;
  preview_url_not_contains?: String;
  preview_url_starts_with?: String;
  preview_url_not_starts_with?: String;
  preview_url_ends_with?: String;
  preview_url_not_ends_with?: String;
  preview_video_url?: String;
  preview_video_url_not?: String;
  preview_video_url_in?: String[] | String;
  preview_video_url_not_in?: String[] | String;
  preview_video_url_lt?: String;
  preview_video_url_lte?: String;
  preview_video_url_gt?: String;
  preview_video_url_gte?: String;
  preview_video_url_contains?: String;
  preview_video_url_not_contains?: String;
  preview_video_url_starts_with?: String;
  preview_video_url_not_starts_with?: String;
  preview_video_url_ends_with?: String;
  preview_video_url_not_ends_with?: String;
  preview_video_duration?: String;
  preview_video_duration_not?: String;
  preview_video_duration_in?: String[] | String;
  preview_video_duration_not_in?: String[] | String;
  preview_video_duration_lt?: String;
  preview_video_duration_lte?: String;
  preview_video_duration_gt?: String;
  preview_video_duration_gte?: String;
  preview_video_duration_contains?: String;
  preview_video_duration_not_contains?: String;
  preview_video_duration_starts_with?: String;
  preview_video_duration_not_starts_with?: String;
  preview_video_duration_ends_with?: String;
  preview_video_duration_not_ends_with?: String;
  deleted?: Boolean;
  deleted_not?: Boolean;
  AND?: VideoScalarWhereInput[] | VideoScalarWhereInput;
  OR?: VideoScalarWhereInput[] | VideoScalarWhereInput;
  NOT?: VideoScalarWhereInput[] | VideoScalarWhereInput;
}

export interface VideoUpdateManyWithWhereNestedInput {
  where: VideoScalarWhereInput;
  data: VideoUpdateManyDataInput;
}

export interface VideoUpdateManyDataInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  deleted?: Boolean;
}

export interface UserUpsertWithWhereUniqueWithoutArtistInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutArtistDataInput;
  create: UserCreateWithoutArtistInput;
}

export interface UserUpsertWithWhereUniqueWithoutLiked_videosInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutLiked_videosDataInput;
  create: UserCreateWithoutLiked_videosInput;
}

export interface VideoUpsertWithWhereUniqueWithoutAuthorInput {
  where: VideoWhereUniqueInput;
  update: VideoUpdateWithoutAuthorDataInput;
  create: VideoCreateWithoutAuthorInput;
}

export interface UserUpsertWithoutUsersInput {
  update: UserUpdateWithoutUsersDataInput;
  create: UserCreateWithoutUsersInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface ArtistFactorsUpdateManyMutationInput {
  promotion_factor?: Float;
  minutes_exponent?: Float;
  finder_fee_factor?: Float;
  monthly_fee_duration?: Int;
  monthly_fee_amount_per_month?: Int;
  annual_fee_amount_per_month?: Int;
}

export interface ArtistFactorsSettingCreateInput {
  promotion_factor: Float;
  minutes_exponent: Float;
  finder_fee_factor: Float;
  monthly_fee_duration: Int;
  monthly_fee_amount_per_month: Int;
  annual_fee_amount_per_month: Int;
}

export interface ArtistFactorsSettingUpdateInput {
  promotion_factor?: Float;
  minutes_exponent?: Float;
  finder_fee_factor?: Float;
  monthly_fee_duration?: Int;
  monthly_fee_amount_per_month?: Int;
  annual_fee_amount_per_month?: Int;
}

export interface ArtistFactorsSettingUpdateManyMutationInput {
  promotion_factor?: Float;
  minutes_exponent?: Float;
  finder_fee_factor?: Float;
  monthly_fee_duration?: Int;
  monthly_fee_amount_per_month?: Int;
  annual_fee_amount_per_month?: Int;
}

export interface CategoryCreateInput {
  title: String;
  description?: String;
  videos?: VideoCreateManyWithoutCategoriesInput;
}

export interface VideoCreateManyWithoutCategoriesInput {
  create?:
    | VideoCreateWithoutCategoriesInput[]
    | VideoCreateWithoutCategoriesInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
}

export interface VideoCreateWithoutCategoriesInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  author: UserCreateOneWithoutMy_videosInput;
  like_users?: UserCreateManyWithoutLiked_videosInput;
  watched_users?: WatchedVideoUserCreateManyWithoutVideoInput;
  tags?: TagCreateManyWithoutVideosInput;
  deleted?: Boolean;
}

export interface CategoryUpdateInput {
  title?: String;
  description?: String;
  videos?: VideoUpdateManyWithoutCategoriesInput;
}

export interface VideoUpdateManyWithoutCategoriesInput {
  create?:
    | VideoCreateWithoutCategoriesInput[]
    | VideoCreateWithoutCategoriesInput;
  delete?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  set?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  disconnect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  update?:
    | VideoUpdateWithWhereUniqueWithoutCategoriesInput[]
    | VideoUpdateWithWhereUniqueWithoutCategoriesInput;
  upsert?:
    | VideoUpsertWithWhereUniqueWithoutCategoriesInput[]
    | VideoUpsertWithWhereUniqueWithoutCategoriesInput;
  deleteMany?: VideoScalarWhereInput[] | VideoScalarWhereInput;
  updateMany?:
    | VideoUpdateManyWithWhereNestedInput[]
    | VideoUpdateManyWithWhereNestedInput;
}

export interface VideoUpdateWithWhereUniqueWithoutCategoriesInput {
  where: VideoWhereUniqueInput;
  data: VideoUpdateWithoutCategoriesDataInput;
}

export interface VideoUpdateWithoutCategoriesDataInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  author?: UserUpdateOneRequiredWithoutMy_videosInput;
  like_users?: UserUpdateManyWithoutLiked_videosInput;
  watched_users?: WatchedVideoUserUpdateManyWithoutVideoInput;
  tags?: TagUpdateManyWithoutVideosInput;
  deleted?: Boolean;
}

export interface VideoUpsertWithWhereUniqueWithoutCategoriesInput {
  where: VideoWhereUniqueInput;
  update: VideoUpdateWithoutCategoriesDataInput;
  create: VideoCreateWithoutCategoriesInput;
}

export interface CategoryUpdateManyMutationInput {
  title?: String;
  description?: String;
}

export interface ChargeHistoryCreateInput {
  user: UserCreateOneInput;
  amount: Int;
  chargeDate?: DateTimeInput;
  chargeId?: String;
  refunded?: Boolean;
}

export interface ChargeHistoryUpdateInput {
  user?: UserUpdateOneRequiredInput;
  amount?: Int;
  chargeDate?: DateTimeInput;
  chargeId?: String;
  refunded?: Boolean;
}

export interface ChargeHistoryUpdateManyMutationInput {
  amount?: Int;
  chargeDate?: DateTimeInput;
  chargeId?: String;
  refunded?: Boolean;
}

export interface CurriculumCreateInput {
  title: String;
  text: String;
  order?: Int;
  author: UserCreateOneInput;
}

export interface CurriculumUpdateInput {
  title?: String;
  text?: String;
  order?: Int;
  author?: UserUpdateOneRequiredInput;
}

export interface CurriculumUpdateManyMutationInput {
  title?: String;
  text?: String;
  order?: Int;
}

export interface PlayHistoryCreateInput {
  user: UserCreateOneInput;
  video: VideoCreateOneInput;
  playSeconds: Int;
  realPlaySeconds: Int;
}

export interface VideoCreateOneInput {
  create?: VideoCreateInput;
  connect?: VideoWhereUniqueInput;
}

export interface VideoCreateInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  author: UserCreateOneWithoutMy_videosInput;
  categories?: CategoryCreateManyWithoutVideosInput;
  like_users?: UserCreateManyWithoutLiked_videosInput;
  watched_users?: WatchedVideoUserCreateManyWithoutVideoInput;
  tags?: TagCreateManyWithoutVideosInput;
  deleted?: Boolean;
}

export interface PlayHistoryUpdateInput {
  user?: UserUpdateOneRequiredInput;
  video?: VideoUpdateOneRequiredInput;
  playSeconds?: Int;
  realPlaySeconds?: Int;
}

export interface VideoUpdateOneRequiredInput {
  create?: VideoCreateInput;
  update?: VideoUpdateDataInput;
  upsert?: VideoUpsertNestedInput;
  connect?: VideoWhereUniqueInput;
}

export interface VideoUpdateDataInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  author?: UserUpdateOneRequiredWithoutMy_videosInput;
  categories?: CategoryUpdateManyWithoutVideosInput;
  like_users?: UserUpdateManyWithoutLiked_videosInput;
  watched_users?: WatchedVideoUserUpdateManyWithoutVideoInput;
  tags?: TagUpdateManyWithoutVideosInput;
  deleted?: Boolean;
}

export interface VideoUpsertNestedInput {
  update: VideoUpdateDataInput;
  create: VideoCreateInput;
}

export interface PlayHistoryUpdateManyMutationInput {
  playSeconds?: Int;
  realPlaySeconds?: Int;
}

export interface PostCreateInput {
  title: String;
  mainImageUrl?: String;
  text: String;
  author: UserCreateOneInput;
}

export interface PostUpdateInput {
  title?: String;
  mainImageUrl?: String;
  text?: String;
  author?: UserUpdateOneRequiredInput;
}

export interface PostUpdateManyMutationInput {
  title?: String;
  mainImageUrl?: String;
  text?: String;
}

export interface ProfitPoolCalculationCreateInput {
  year: Int;
  month: Int;
  annual_active_subscribers?: Int;
  monthly_active_subscribers?: Int;
  annual_subscription_rate?: Int;
  monthly_subscription_rate?: Int;
  annual_pool_revenue?: Int;
  monthly_pool_revenue?: Int;
  total_revenue?: Int;
  total_payment_to_artists?: Float;
  net_revenue?: Float;
}

export interface ProfitPoolCalculationUpdateInput {
  year?: Int;
  month?: Int;
  annual_active_subscribers?: Int;
  monthly_active_subscribers?: Int;
  annual_subscription_rate?: Int;
  monthly_subscription_rate?: Int;
  annual_pool_revenue?: Int;
  monthly_pool_revenue?: Int;
  total_revenue?: Int;
  total_payment_to_artists?: Float;
  net_revenue?: Float;
}

export interface ProfitPoolCalculationUpdateManyMutationInput {
  year?: Int;
  month?: Int;
  annual_active_subscribers?: Int;
  monthly_active_subscribers?: Int;
  annual_subscription_rate?: Int;
  monthly_subscription_rate?: Int;
  annual_pool_revenue?: Int;
  monthly_pool_revenue?: Int;
  total_revenue?: Int;
  total_payment_to_artists?: Float;
  net_revenue?: Float;
}

export interface ProfitPoolFactorCreateInput {
  overhead?: Int;
  monthly_multiplier?: Float;
  finder_fee_multiplier?: Float;
  profit_pool_option1_variable?: Int;
  profit_pool_option1_multiplier?: Float;
  profit_pool_option2_variable?: Int;
  profit_pool_option2_multiplier?: Float;
  profit_pool_percentage?: Float;
  manual_change?: Int;
}

export interface ProfitPoolFactorUpdateInput {
  overhead?: Int;
  monthly_multiplier?: Float;
  finder_fee_multiplier?: Float;
  profit_pool_option1_variable?: Int;
  profit_pool_option1_multiplier?: Float;
  profit_pool_option2_variable?: Int;
  profit_pool_option2_multiplier?: Float;
  profit_pool_percentage?: Float;
  manual_change?: Int;
}

export interface ProfitPoolFactorUpdateManyMutationInput {
  overhead?: Int;
  monthly_multiplier?: Float;
  finder_fee_multiplier?: Float;
  profit_pool_option1_variable?: Int;
  profit_pool_option1_multiplier?: Float;
  profit_pool_option2_variable?: Int;
  profit_pool_option2_multiplier?: Float;
  profit_pool_percentage?: Float;
  manual_change?: Int;
}

export interface PromoCodeCreateInput {
  user: UserCreateOneWithoutMy_promo_codesInput;
  promo_code?: String;
  current_promo_code?: Boolean;
}

export interface UserCreateOneWithoutMy_promo_codesInput {
  create?: UserCreateWithoutMy_promo_codesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutMy_promo_codesInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email: String;
  phone?: String;
  role?: UserRole;
  approved?: Boolean;
  password_hash: String;
  password_salt: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  payout_amount?: Int;
  payout_months_total?: Int;
  payout_months_left?: Int;
  payout_enabled?: Boolean;
  artist?: UserCreateOneWithoutUsersInput;
  users?: UserCreateManyWithoutArtistInput;
  front_id_scan?: String;
  back_id_scan?: String;
  my_videos?: VideoCreateManyWithoutAuthorInput;
  liked_videos?: VideoCreateManyWithoutLike_usersInput;
  watched_videos?: WatchedVideoUserCreateManyWithoutUserInput;
  my_subscription_users?: UserCreateManyWithoutSubscribed_usersInput;
  subscribed_users?: UserCreateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  last_login_date?: DateTimeInput;
}

export interface PromoCodeUpdateInput {
  user?: UserUpdateOneRequiredWithoutMy_promo_codesInput;
  promo_code?: String;
  current_promo_code?: Boolean;
}

export interface UserUpdateOneRequiredWithoutMy_promo_codesInput {
  create?: UserCreateWithoutMy_promo_codesInput;
  update?: UserUpdateWithoutMy_promo_codesDataInput;
  upsert?: UserUpsertWithoutMy_promo_codesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutMy_promo_codesDataInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email?: String;
  phone?: String;
  role?: UserRole;
  approved?: Boolean;
  password_hash?: String;
  password_salt?: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  payout_amount?: Int;
  payout_months_total?: Int;
  payout_months_left?: Int;
  payout_enabled?: Boolean;
  artist?: UserUpdateOneWithoutUsersInput;
  users?: UserUpdateManyWithoutArtistInput;
  front_id_scan?: String;
  back_id_scan?: String;
  my_videos?: VideoUpdateManyWithoutAuthorInput;
  liked_videos?: VideoUpdateManyWithoutLike_usersInput;
  watched_videos?: WatchedVideoUserUpdateManyWithoutUserInput;
  my_subscription_users?: UserUpdateManyWithoutSubscribed_usersInput;
  subscribed_users?: UserUpdateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  last_login_date?: DateTimeInput;
}

export interface UserUpsertWithoutMy_promo_codesInput {
  update: UserUpdateWithoutMy_promo_codesDataInput;
  create: UserCreateWithoutMy_promo_codesInput;
}

export interface PromoCodeUpdateManyMutationInput {
  promo_code?: String;
  current_promo_code?: Boolean;
}

export interface RestoreCodeCreateInput {
  email: String;
  valid_until: DateTimeInput;
  code: String;
}

export interface RestoreCodeUpdateInput {
  email?: String;
  valid_until?: DateTimeInput;
  code?: String;
}

export interface RestoreCodeUpdateManyMutationInput {
  email?: String;
  valid_until?: DateTimeInput;
  code?: String;
}

export interface SettingsCreateInput {
  name: String;
  int_val?: Int;
  str_val?: String;
}

export interface SettingsUpdateInput {
  name?: String;
  int_val?: Int;
  str_val?: String;
}

export interface SettingsUpdateManyMutationInput {
  name?: String;
  int_val?: Int;
  str_val?: String;
}

export interface SubscriptionHistoryCreateInput {
  user: UserCreateOneInput;
  interval: String;
  amount: Int;
  subscriptionDate?: DateTimeInput;
}

export interface SubscriptionHistoryUpdateInput {
  user?: UserUpdateOneRequiredInput;
  interval?: String;
  amount?: Int;
  subscriptionDate?: DateTimeInput;
}

export interface SubscriptionHistoryUpdateManyMutationInput {
  interval?: String;
  amount?: Int;
  subscriptionDate?: DateTimeInput;
}

export interface TagCreateInput {
  text: String;
  videos?: VideoCreateManyWithoutTagsInput;
}

export interface VideoCreateManyWithoutTagsInput {
  create?: VideoCreateWithoutTagsInput[] | VideoCreateWithoutTagsInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
}

export interface VideoCreateWithoutTagsInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  author: UserCreateOneWithoutMy_videosInput;
  categories?: CategoryCreateManyWithoutVideosInput;
  like_users?: UserCreateManyWithoutLiked_videosInput;
  watched_users?: WatchedVideoUserCreateManyWithoutVideoInput;
  deleted?: Boolean;
}

export interface TagUpdateInput {
  text?: String;
  videos?: VideoUpdateManyWithoutTagsInput;
}

export interface VideoUpdateManyWithoutTagsInput {
  create?: VideoCreateWithoutTagsInput[] | VideoCreateWithoutTagsInput;
  delete?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  set?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  disconnect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  update?:
    | VideoUpdateWithWhereUniqueWithoutTagsInput[]
    | VideoUpdateWithWhereUniqueWithoutTagsInput;
  upsert?:
    | VideoUpsertWithWhereUniqueWithoutTagsInput[]
    | VideoUpsertWithWhereUniqueWithoutTagsInput;
  deleteMany?: VideoScalarWhereInput[] | VideoScalarWhereInput;
  updateMany?:
    | VideoUpdateManyWithWhereNestedInput[]
    | VideoUpdateManyWithWhereNestedInput;
}

export interface VideoUpdateWithWhereUniqueWithoutTagsInput {
  where: VideoWhereUniqueInput;
  data: VideoUpdateWithoutTagsDataInput;
}

export interface VideoUpdateWithoutTagsDataInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  author?: UserUpdateOneRequiredWithoutMy_videosInput;
  categories?: CategoryUpdateManyWithoutVideosInput;
  like_users?: UserUpdateManyWithoutLiked_videosInput;
  watched_users?: WatchedVideoUserUpdateManyWithoutVideoInput;
  deleted?: Boolean;
}

export interface VideoUpsertWithWhereUniqueWithoutTagsInput {
  where: VideoWhereUniqueInput;
  update: VideoUpdateWithoutTagsDataInput;
  create: VideoCreateWithoutTagsInput;
}

export interface TagUpdateManyMutationInput {
  text?: String;
}

export interface TotalMinutesForArtistCreateInput {
  year: Int;
  month: Int;
  artist: UserCreateOneInput;
  minutes_as_owner1?: Float;
  minutes_as_owner2?: Float;
  minutes_as_owner3?: Float;
  total_minutes?: Float;
  artist_rating_factor: Float;
  final_minutes?: Float;
  percent_of_profit_pool?: Float;
  monthly_quantity: Int;
  annual_quantity: Int;
  finder_fee?: Int;
  payment_from_profit_pool?: Float;
  total_payment?: Float;
}

export interface TotalMinutesForArtistUpdateInput {
  year?: Int;
  month?: Int;
  artist?: UserUpdateOneRequiredInput;
  minutes_as_owner1?: Float;
  minutes_as_owner2?: Float;
  minutes_as_owner3?: Float;
  total_minutes?: Float;
  artist_rating_factor?: Float;
  final_minutes?: Float;
  percent_of_profit_pool?: Float;
  monthly_quantity?: Int;
  annual_quantity?: Int;
  finder_fee?: Int;
  payment_from_profit_pool?: Float;
  total_payment?: Float;
}

export interface TotalMinutesForArtistUpdateManyMutationInput {
  year?: Int;
  month?: Int;
  minutes_as_owner1?: Float;
  minutes_as_owner2?: Float;
  minutes_as_owner3?: Float;
  total_minutes?: Float;
  artist_rating_factor?: Float;
  final_minutes?: Float;
  percent_of_profit_pool?: Float;
  monthly_quantity?: Int;
  annual_quantity?: Int;
  finder_fee?: Int;
  payment_from_profit_pool?: Float;
  total_payment?: Float;
}

export interface TransferPlanCreateInput {
  artist: UserCreateOneInput;
  subscriber: UserCreateOneInput;
  year: Int;
  month: Int;
  amount: Int;
  ignore_status?: Boolean;
  paid_status?: Boolean;
  paid_date?: DateTimeInput;
}

export interface TransferPlanUpdateInput {
  artist?: UserUpdateOneRequiredInput;
  subscriber?: UserUpdateOneRequiredInput;
  year?: Int;
  month?: Int;
  amount?: Int;
  ignore_status?: Boolean;
  paid_status?: Boolean;
  paid_date?: DateTimeInput;
}

export interface TransferPlanUpdateManyMutationInput {
  year?: Int;
  month?: Int;
  amount?: Int;
  ignore_status?: Boolean;
  paid_status?: Boolean;
  paid_date?: DateTimeInput;
}

export interface TransferTransactionCreateInput {
  artist: UserCreateOneInput;
  year: Int;
  month: Int;
  amount: Int;
  paid_status?: Boolean;
  paid_date?: DateTimeInput;
}

export interface TransferTransactionUpdateInput {
  artist?: UserUpdateOneRequiredInput;
  year?: Int;
  month?: Int;
  amount?: Int;
  paid_status?: Boolean;
  paid_date?: DateTimeInput;
}

export interface TransferTransactionUpdateManyMutationInput {
  year?: Int;
  month?: Int;
  amount?: Int;
  paid_status?: Boolean;
  paid_date?: DateTimeInput;
}

export interface UserUpdateInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email?: String;
  phone?: String;
  role?: UserRole;
  approved?: Boolean;
  password_hash?: String;
  password_salt?: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  payout_amount?: Int;
  payout_months_total?: Int;
  payout_months_left?: Int;
  payout_enabled?: Boolean;
  artist?: UserUpdateOneWithoutUsersInput;
  users?: UserUpdateManyWithoutArtistInput;
  front_id_scan?: String;
  back_id_scan?: String;
  my_videos?: VideoUpdateManyWithoutAuthorInput;
  liked_videos?: VideoUpdateManyWithoutLike_usersInput;
  watched_videos?: WatchedVideoUserUpdateManyWithoutUserInput;
  my_subscription_users?: UserUpdateManyWithoutSubscribed_usersInput;
  subscribed_users?: UserUpdateManyWithoutMy_subscription_usersInput;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  my_promo_codes?: PromoCodeUpdateManyWithoutUserInput;
  last_login_date?: DateTimeInput;
}

export interface UserUpdateManyMutationInput {
  firstname?: String;
  lastname?: String;
  username?: String;
  email?: String;
  phone?: String;
  role?: UserRole;
  approved?: Boolean;
  password_hash?: String;
  password_salt?: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  payout_amount?: Int;
  payout_months_total?: Int;
  payout_months_left?: Int;
  payout_enabled?: Boolean;
  front_id_scan?: String;
  back_id_scan?: String;
  billing_subscription_active?: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  last_login_date?: DateTimeInput;
}

export interface VideoUpdateInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  author?: UserUpdateOneRequiredWithoutMy_videosInput;
  categories?: CategoryUpdateManyWithoutVideosInput;
  like_users?: UserUpdateManyWithoutLiked_videosInput;
  watched_users?: WatchedVideoUserUpdateManyWithoutVideoInput;
  tags?: TagUpdateManyWithoutVideosInput;
  deleted?: Boolean;
}

export interface VideoUpdateManyMutationInput {
  title?: String;
  description?: String;
  publish_date?: DateTimeInput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  deleted?: Boolean;
}

export interface VideoDataForMonthCreateInput {
  year: Int;
  month: Int;
  video: VideoCreateOneInput;
  video_length: Int;
  unique_users?: Int;
  real_minutes_watched?: Int;
  avg_minutes_watched?: Int;
  exponent_applied?: Int;
  minutes_after_exponent?: Int;
}

export interface VideoDataForMonthUpdateInput {
  year?: Int;
  month?: Int;
  video?: VideoUpdateOneRequiredInput;
  video_length?: Int;
  unique_users?: Int;
  real_minutes_watched?: Int;
  avg_minutes_watched?: Int;
  exponent_applied?: Int;
  minutes_after_exponent?: Int;
}

export interface VideoDataForMonthUpdateManyMutationInput {
  year?: Int;
  month?: Int;
  video_length?: Int;
  unique_users?: Int;
  real_minutes_watched?: Int;
  avg_minutes_watched?: Int;
  exponent_applied?: Int;
  minutes_after_exponent?: Int;
}

export interface VideoParametersCreateInput {
  video: VideoCreateOneInput;
  owner1?: UserCreateOneInput;
  owner1_percentage: Int;
  owner2?: UserCreateOneInput;
  owner2_percentage: Int;
  owner3?: UserCreateOneInput;
  owner3_percentage: Int;
}

export interface VideoParametersUpdateInput {
  video?: VideoUpdateOneRequiredInput;
  owner1?: UserUpdateOneInput;
  owner1_percentage?: Int;
  owner2?: UserUpdateOneInput;
  owner2_percentage?: Int;
  owner3?: UserUpdateOneInput;
  owner3_percentage?: Int;
}

export interface UserUpdateOneInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface VideoParametersUpdateManyMutationInput {
  owner1_percentage?: Int;
  owner2_percentage?: Int;
  owner3_percentage?: Int;
}

export interface VideoParametersForMonthCreateInput {
  year: Int;
  month: Int;
  video: VideoCreateOneInput;
  owner1?: UserCreateOneInput;
  owner1_percentage: Int;
  owner2?: UserCreateOneInput;
  owner2_percentage: Int;
  owner3?: UserCreateOneInput;
  owner3_percentage: Int;
  total_minutes?: Float;
  owner1_minutes?: Float;
  owner2_minutes?: Float;
  owner3_minutes?: Float;
}

export interface VideoParametersForMonthUpdateInput {
  year?: Int;
  month?: Int;
  video?: VideoUpdateOneRequiredInput;
  owner1?: UserUpdateOneInput;
  owner1_percentage?: Int;
  owner2?: UserUpdateOneInput;
  owner2_percentage?: Int;
  owner3?: UserUpdateOneInput;
  owner3_percentage?: Int;
  total_minutes?: Float;
  owner1_minutes?: Float;
  owner2_minutes?: Float;
  owner3_minutes?: Float;
}

export interface VideoParametersForMonthUpdateManyMutationInput {
  year?: Int;
  month?: Int;
  owner1_percentage?: Int;
  owner2_percentage?: Int;
  owner3_percentage?: Int;
  total_minutes?: Float;
  owner1_minutes?: Float;
  owner2_minutes?: Float;
  owner3_minutes?: Float;
}

export interface VideoTotalParametersCreateInput {
  minutes_watched_multiplier?: Float;
  exponent_for_minutes_watched?: Float;
  star_rating_multiplier?: Float;
  star_rating_on_off?: Int;
}

export interface VideoTotalParametersUpdateInput {
  minutes_watched_multiplier?: Float;
  exponent_for_minutes_watched?: Float;
  star_rating_multiplier?: Float;
  star_rating_on_off?: Int;
}

export interface VideoTotalParametersUpdateManyMutationInput {
  minutes_watched_multiplier?: Float;
  exponent_for_minutes_watched?: Float;
  star_rating_multiplier?: Float;
  star_rating_on_off?: Int;
}

export interface WatchedVideoUserCreateInput {
  video?: VideoCreateOneWithoutWatched_usersInput;
  user: UserCreateOneWithoutWatched_videosInput;
  watched_seconds?: Int;
}

export interface WatchedVideoUserUpdateInput {
  video?: VideoUpdateOneWithoutWatched_usersInput;
  user?: UserUpdateOneRequiredWithoutWatched_videosInput;
  watched_seconds?: Int;
}

export interface WatchedVideoUserUpdateManyMutationInput {
  watched_seconds?: Int;
}

export interface ActivationCodeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ActivationCodeWhereInput;
  AND?:
    | ActivationCodeSubscriptionWhereInput[]
    | ActivationCodeSubscriptionWhereInput;
  OR?:
    | ActivationCodeSubscriptionWhereInput[]
    | ActivationCodeSubscriptionWhereInput;
  NOT?:
    | ActivationCodeSubscriptionWhereInput[]
    | ActivationCodeSubscriptionWhereInput;
}

export interface ArtistFactorsSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ArtistFactorsWhereInput;
  AND?:
    | ArtistFactorsSubscriptionWhereInput[]
    | ArtistFactorsSubscriptionWhereInput;
  OR?:
    | ArtistFactorsSubscriptionWhereInput[]
    | ArtistFactorsSubscriptionWhereInput;
  NOT?:
    | ArtistFactorsSubscriptionWhereInput[]
    | ArtistFactorsSubscriptionWhereInput;
}

export interface ArtistFactorsSettingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ArtistFactorsSettingWhereInput;
  AND?:
    | ArtistFactorsSettingSubscriptionWhereInput[]
    | ArtistFactorsSettingSubscriptionWhereInput;
  OR?:
    | ArtistFactorsSettingSubscriptionWhereInput[]
    | ArtistFactorsSettingSubscriptionWhereInput;
  NOT?:
    | ArtistFactorsSettingSubscriptionWhereInput[]
    | ArtistFactorsSettingSubscriptionWhereInput;
}

export interface CategorySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CategoryWhereInput;
  AND?: CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput;
  OR?: CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput;
  NOT?: CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput;
}

export interface ChargeHistorySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ChargeHistoryWhereInput;
  AND?:
    | ChargeHistorySubscriptionWhereInput[]
    | ChargeHistorySubscriptionWhereInput;
  OR?:
    | ChargeHistorySubscriptionWhereInput[]
    | ChargeHistorySubscriptionWhereInput;
  NOT?:
    | ChargeHistorySubscriptionWhereInput[]
    | ChargeHistorySubscriptionWhereInput;
}

export interface CurriculumSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CurriculumWhereInput;
  AND?: CurriculumSubscriptionWhereInput[] | CurriculumSubscriptionWhereInput;
  OR?: CurriculumSubscriptionWhereInput[] | CurriculumSubscriptionWhereInput;
  NOT?: CurriculumSubscriptionWhereInput[] | CurriculumSubscriptionWhereInput;
}

export interface PlayHistorySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PlayHistoryWhereInput;
  AND?: PlayHistorySubscriptionWhereInput[] | PlayHistorySubscriptionWhereInput;
  OR?: PlayHistorySubscriptionWhereInput[] | PlayHistorySubscriptionWhereInput;
  NOT?: PlayHistorySubscriptionWhereInput[] | PlayHistorySubscriptionWhereInput;
}

export interface PostSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PostWhereInput;
  AND?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
  OR?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
  NOT?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
}

export interface ProfitPoolCalculationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProfitPoolCalculationWhereInput;
  AND?:
    | ProfitPoolCalculationSubscriptionWhereInput[]
    | ProfitPoolCalculationSubscriptionWhereInput;
  OR?:
    | ProfitPoolCalculationSubscriptionWhereInput[]
    | ProfitPoolCalculationSubscriptionWhereInput;
  NOT?:
    | ProfitPoolCalculationSubscriptionWhereInput[]
    | ProfitPoolCalculationSubscriptionWhereInput;
}

export interface ProfitPoolFactorSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProfitPoolFactorWhereInput;
  AND?:
    | ProfitPoolFactorSubscriptionWhereInput[]
    | ProfitPoolFactorSubscriptionWhereInput;
  OR?:
    | ProfitPoolFactorSubscriptionWhereInput[]
    | ProfitPoolFactorSubscriptionWhereInput;
  NOT?:
    | ProfitPoolFactorSubscriptionWhereInput[]
    | ProfitPoolFactorSubscriptionWhereInput;
}

export interface PromoCodeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PromoCodeWhereInput;
  AND?: PromoCodeSubscriptionWhereInput[] | PromoCodeSubscriptionWhereInput;
  OR?: PromoCodeSubscriptionWhereInput[] | PromoCodeSubscriptionWhereInput;
  NOT?: PromoCodeSubscriptionWhereInput[] | PromoCodeSubscriptionWhereInput;
}

export interface RestoreCodeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RestoreCodeWhereInput;
  AND?: RestoreCodeSubscriptionWhereInput[] | RestoreCodeSubscriptionWhereInput;
  OR?: RestoreCodeSubscriptionWhereInput[] | RestoreCodeSubscriptionWhereInput;
  NOT?: RestoreCodeSubscriptionWhereInput[] | RestoreCodeSubscriptionWhereInput;
}

export interface SettingsSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SettingsWhereInput;
  AND?: SettingsSubscriptionWhereInput[] | SettingsSubscriptionWhereInput;
  OR?: SettingsSubscriptionWhereInput[] | SettingsSubscriptionWhereInput;
  NOT?: SettingsSubscriptionWhereInput[] | SettingsSubscriptionWhereInput;
}

export interface SubscriptionHistorySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SubscriptionHistoryWhereInput;
  AND?:
    | SubscriptionHistorySubscriptionWhereInput[]
    | SubscriptionHistorySubscriptionWhereInput;
  OR?:
    | SubscriptionHistorySubscriptionWhereInput[]
    | SubscriptionHistorySubscriptionWhereInput;
  NOT?:
    | SubscriptionHistorySubscriptionWhereInput[]
    | SubscriptionHistorySubscriptionWhereInput;
}

export interface TagSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TagWhereInput;
  AND?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  OR?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  NOT?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
}

export interface TotalMinutesForArtistSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TotalMinutesForArtistWhereInput;
  AND?:
    | TotalMinutesForArtistSubscriptionWhereInput[]
    | TotalMinutesForArtistSubscriptionWhereInput;
  OR?:
    | TotalMinutesForArtistSubscriptionWhereInput[]
    | TotalMinutesForArtistSubscriptionWhereInput;
  NOT?:
    | TotalMinutesForArtistSubscriptionWhereInput[]
    | TotalMinutesForArtistSubscriptionWhereInput;
}

export interface TransferPlanSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TransferPlanWhereInput;
  AND?:
    | TransferPlanSubscriptionWhereInput[]
    | TransferPlanSubscriptionWhereInput;
  OR?:
    | TransferPlanSubscriptionWhereInput[]
    | TransferPlanSubscriptionWhereInput;
  NOT?:
    | TransferPlanSubscriptionWhereInput[]
    | TransferPlanSubscriptionWhereInput;
}

export interface TransferTransactionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TransferTransactionWhereInput;
  AND?:
    | TransferTransactionSubscriptionWhereInput[]
    | TransferTransactionSubscriptionWhereInput;
  OR?:
    | TransferTransactionSubscriptionWhereInput[]
    | TransferTransactionSubscriptionWhereInput;
  NOT?:
    | TransferTransactionSubscriptionWhereInput[]
    | TransferTransactionSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface VideoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VideoWhereInput;
  AND?: VideoSubscriptionWhereInput[] | VideoSubscriptionWhereInput;
  OR?: VideoSubscriptionWhereInput[] | VideoSubscriptionWhereInput;
  NOT?: VideoSubscriptionWhereInput[] | VideoSubscriptionWhereInput;
}

export interface VideoDataForMonthSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VideoDataForMonthWhereInput;
  AND?:
    | VideoDataForMonthSubscriptionWhereInput[]
    | VideoDataForMonthSubscriptionWhereInput;
  OR?:
    | VideoDataForMonthSubscriptionWhereInput[]
    | VideoDataForMonthSubscriptionWhereInput;
  NOT?:
    | VideoDataForMonthSubscriptionWhereInput[]
    | VideoDataForMonthSubscriptionWhereInput;
}

export interface VideoParametersSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VideoParametersWhereInput;
  AND?:
    | VideoParametersSubscriptionWhereInput[]
    | VideoParametersSubscriptionWhereInput;
  OR?:
    | VideoParametersSubscriptionWhereInput[]
    | VideoParametersSubscriptionWhereInput;
  NOT?:
    | VideoParametersSubscriptionWhereInput[]
    | VideoParametersSubscriptionWhereInput;
}

export interface VideoParametersForMonthSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VideoParametersForMonthWhereInput;
  AND?:
    | VideoParametersForMonthSubscriptionWhereInput[]
    | VideoParametersForMonthSubscriptionWhereInput;
  OR?:
    | VideoParametersForMonthSubscriptionWhereInput[]
    | VideoParametersForMonthSubscriptionWhereInput;
  NOT?:
    | VideoParametersForMonthSubscriptionWhereInput[]
    | VideoParametersForMonthSubscriptionWhereInput;
}

export interface VideoTotalParametersSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VideoTotalParametersWhereInput;
  AND?:
    | VideoTotalParametersSubscriptionWhereInput[]
    | VideoTotalParametersSubscriptionWhereInput;
  OR?:
    | VideoTotalParametersSubscriptionWhereInput[]
    | VideoTotalParametersSubscriptionWhereInput;
  NOT?:
    | VideoTotalParametersSubscriptionWhereInput[]
    | VideoTotalParametersSubscriptionWhereInput;
}

export interface WatchedVideoUserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: WatchedVideoUserWhereInput;
  AND?:
    | WatchedVideoUserSubscriptionWhereInput[]
    | WatchedVideoUserSubscriptionWhereInput;
  OR?:
    | WatchedVideoUserSubscriptionWhereInput[]
    | WatchedVideoUserSubscriptionWhereInput;
  NOT?:
    | WatchedVideoUserSubscriptionWhereInput[]
    | WatchedVideoUserSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface ActivationCode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  valid_until: DateTimeOutput;
  code: String;
}

export interface ActivationCodePromise
  extends Promise<ActivationCode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  valid_until: () => Promise<DateTimeOutput>;
  code: () => Promise<String>;
}

export interface ActivationCodeSubscription
  extends Promise<AsyncIterator<ActivationCode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  valid_until: () => Promise<AsyncIterator<DateTimeOutput>>;
  code: () => Promise<AsyncIterator<String>>;
}

export interface ActivationCodeConnection {
  pageInfo: PageInfo;
  edges: ActivationCodeEdge[];
}

export interface ActivationCodeConnectionPromise
  extends Promise<ActivationCodeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ActivationCodeEdge>>() => T;
  aggregate: <T = AggregateActivationCodePromise>() => T;
}

export interface ActivationCodeConnectionSubscription
  extends Promise<AsyncIterator<ActivationCodeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ActivationCodeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateActivationCodeSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ActivationCodeEdge {
  node: ActivationCode;
  cursor: String;
}

export interface ActivationCodeEdgePromise
  extends Promise<ActivationCodeEdge>,
    Fragmentable {
  node: <T = ActivationCodePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ActivationCodeEdgeSubscription
  extends Promise<AsyncIterator<ActivationCodeEdge>>,
    Fragmentable {
  node: <T = ActivationCodeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateActivationCode {
  count: Int;
}

export interface AggregateActivationCodePromise
  extends Promise<AggregateActivationCode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateActivationCodeSubscription
  extends Promise<AsyncIterator<AggregateActivationCode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ArtistFactors {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  promotion_factor: Float;
  minutes_exponent: Float;
  finder_fee_factor: Float;
  monthly_fee_duration: Int;
  monthly_fee_amount_per_month: Int;
  annual_fee_amount_per_month: Int;
}

export interface ArtistFactorsPromise
  extends Promise<ArtistFactors>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  artist: <T = UserPromise>() => T;
  promotion_factor: () => Promise<Float>;
  minutes_exponent: () => Promise<Float>;
  finder_fee_factor: () => Promise<Float>;
  monthly_fee_duration: () => Promise<Int>;
  monthly_fee_amount_per_month: () => Promise<Int>;
  annual_fee_amount_per_month: () => Promise<Int>;
}

export interface ArtistFactorsSubscription
  extends Promise<AsyncIterator<ArtistFactors>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  artist: <T = UserSubscription>() => T;
  promotion_factor: () => Promise<AsyncIterator<Float>>;
  minutes_exponent: () => Promise<AsyncIterator<Float>>;
  finder_fee_factor: () => Promise<AsyncIterator<Float>>;
  monthly_fee_duration: () => Promise<AsyncIterator<Int>>;
  monthly_fee_amount_per_month: () => Promise<AsyncIterator<Int>>;
  annual_fee_amount_per_month: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstname?: String;
  lastname?: String;
  username?: String;
  email: String;
  phone?: String;
  role: UserRole;
  approved?: Boolean;
  password_hash: String;
  password_salt: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  payout_amount?: Int;
  payout_months_total?: Int;
  payout_months_left?: Int;
  payout_enabled?: Boolean;
  front_id_scan?: String;
  back_id_scan?: String;
  billing_subscription_active: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  last_login_date?: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstname: () => Promise<String>;
  lastname: () => Promise<String>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  phone: () => Promise<String>;
  role: () => Promise<UserRole>;
  approved: () => Promise<Boolean>;
  password_hash: () => Promise<String>;
  password_salt: () => Promise<String>;
  avatar: () => Promise<String>;
  background_image: () => Promise<String>;
  about_text: () => Promise<String>;
  payout_amount: () => Promise<Int>;
  payout_months_total: () => Promise<Int>;
  payout_months_left: () => Promise<Int>;
  payout_enabled: () => Promise<Boolean>;
  artist: <T = UserPromise>() => T;
  users: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  front_id_scan: () => Promise<String>;
  back_id_scan: () => Promise<String>;
  my_videos: <T = FragmentableArray<Video>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  liked_videos: <T = FragmentableArray<Video>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  watched_videos: <T = FragmentableArray<WatchedVideoUser>>(
    args?: {
      where?: WatchedVideoUserWhereInput;
      orderBy?: WatchedVideoUserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  my_subscription_users: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  subscribed_users: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  billing_subscription_active: () => Promise<Boolean>;
  stripe_customer_id: () => Promise<String>;
  stripe_subsciption_json: () => Promise<Json>;
  my_promo_codes: <T = FragmentableArray<PromoCode>>(
    args?: {
      where?: PromoCodeWhereInput;
      orderBy?: PromoCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  last_login_date: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstname: () => Promise<AsyncIterator<String>>;
  lastname: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<UserRole>>;
  approved: () => Promise<AsyncIterator<Boolean>>;
  password_hash: () => Promise<AsyncIterator<String>>;
  password_salt: () => Promise<AsyncIterator<String>>;
  avatar: () => Promise<AsyncIterator<String>>;
  background_image: () => Promise<AsyncIterator<String>>;
  about_text: () => Promise<AsyncIterator<String>>;
  payout_amount: () => Promise<AsyncIterator<Int>>;
  payout_months_total: () => Promise<AsyncIterator<Int>>;
  payout_months_left: () => Promise<AsyncIterator<Int>>;
  payout_enabled: () => Promise<AsyncIterator<Boolean>>;
  artist: <T = UserSubscription>() => T;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  front_id_scan: () => Promise<AsyncIterator<String>>;
  back_id_scan: () => Promise<AsyncIterator<String>>;
  my_videos: <T = Promise<AsyncIterator<VideoSubscription>>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  liked_videos: <T = Promise<AsyncIterator<VideoSubscription>>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  watched_videos: <T = Promise<AsyncIterator<WatchedVideoUserSubscription>>>(
    args?: {
      where?: WatchedVideoUserWhereInput;
      orderBy?: WatchedVideoUserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  my_subscription_users: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  subscribed_users: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  billing_subscription_active: () => Promise<AsyncIterator<Boolean>>;
  stripe_customer_id: () => Promise<AsyncIterator<String>>;
  stripe_subsciption_json: () => Promise<AsyncIterator<Json>>;
  my_promo_codes: <T = Promise<AsyncIterator<PromoCodeSubscription>>>(
    args?: {
      where?: PromoCodeWhereInput;
      orderBy?: PromoCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  last_login_date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Video {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title?: String;
  description?: String;
  publish_date?: DateTimeOutput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  deleted: Boolean;
}

export interface VideoPromise extends Promise<Video>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  publish_date: () => Promise<DateTimeOutput>;
  file_url: () => Promise<String>;
  video_duration: () => Promise<Int>;
  preview_url: () => Promise<String>;
  preview_video_url: () => Promise<String>;
  preview_video_duration: () => Promise<String>;
  author: <T = UserPromise>() => T;
  categories: <T = FragmentableArray<Category>>(
    args?: {
      where?: CategoryWhereInput;
      orderBy?: CategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  like_users: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  watched_users: <T = FragmentableArray<WatchedVideoUser>>(
    args?: {
      where?: WatchedVideoUserWhereInput;
      orderBy?: WatchedVideoUserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tags: <T = FragmentableArray<Tag>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  deleted: () => Promise<Boolean>;
}

export interface VideoSubscription
  extends Promise<AsyncIterator<Video>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  publish_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  file_url: () => Promise<AsyncIterator<String>>;
  video_duration: () => Promise<AsyncIterator<Int>>;
  preview_url: () => Promise<AsyncIterator<String>>;
  preview_video_url: () => Promise<AsyncIterator<String>>;
  preview_video_duration: () => Promise<AsyncIterator<String>>;
  author: <T = UserSubscription>() => T;
  categories: <T = Promise<AsyncIterator<CategorySubscription>>>(
    args?: {
      where?: CategoryWhereInput;
      orderBy?: CategoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  like_users: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  watched_users: <T = Promise<AsyncIterator<WatchedVideoUserSubscription>>>(
    args?: {
      where?: WatchedVideoUserWhereInput;
      orderBy?: WatchedVideoUserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  deleted: () => Promise<AsyncIterator<Boolean>>;
}

export interface Category {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  description?: String;
}

export interface CategoryPromise extends Promise<Category>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  videos: <T = FragmentableArray<Video>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CategorySubscription
  extends Promise<AsyncIterator<Category>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  videos: <T = Promise<AsyncIterator<VideoSubscription>>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface WatchedVideoUser {
  id: ID_Output;
  watched_seconds: Int;
}

export interface WatchedVideoUserPromise
  extends Promise<WatchedVideoUser>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  video: <T = VideoPromise>() => T;
  user: <T = UserPromise>() => T;
  watched_seconds: () => Promise<Int>;
}

export interface WatchedVideoUserSubscription
  extends Promise<AsyncIterator<WatchedVideoUser>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  video: <T = VideoSubscription>() => T;
  user: <T = UserSubscription>() => T;
  watched_seconds: () => Promise<AsyncIterator<Int>>;
}

export interface Tag {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  text: String;
}

export interface TagPromise extends Promise<Tag>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
  videos: <T = FragmentableArray<Video>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface TagSubscription
  extends Promise<AsyncIterator<Tag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  text: () => Promise<AsyncIterator<String>>;
  videos: <T = Promise<AsyncIterator<VideoSubscription>>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface PromoCode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  promo_code?: String;
  current_promo_code: Boolean;
}

export interface PromoCodePromise extends Promise<PromoCode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  promo_code: () => Promise<String>;
  current_promo_code: () => Promise<Boolean>;
}

export interface PromoCodeSubscription
  extends Promise<AsyncIterator<PromoCode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  promo_code: () => Promise<AsyncIterator<String>>;
  current_promo_code: () => Promise<AsyncIterator<Boolean>>;
}

export interface ArtistFactorsConnection {
  pageInfo: PageInfo;
  edges: ArtistFactorsEdge[];
}

export interface ArtistFactorsConnectionPromise
  extends Promise<ArtistFactorsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ArtistFactorsEdge>>() => T;
  aggregate: <T = AggregateArtistFactorsPromise>() => T;
}

export interface ArtistFactorsConnectionSubscription
  extends Promise<AsyncIterator<ArtistFactorsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ArtistFactorsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateArtistFactorsSubscription>() => T;
}

export interface ArtistFactorsEdge {
  node: ArtistFactors;
  cursor: String;
}

export interface ArtistFactorsEdgePromise
  extends Promise<ArtistFactorsEdge>,
    Fragmentable {
  node: <T = ArtistFactorsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ArtistFactorsEdgeSubscription
  extends Promise<AsyncIterator<ArtistFactorsEdge>>,
    Fragmentable {
  node: <T = ArtistFactorsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateArtistFactors {
  count: Int;
}

export interface AggregateArtistFactorsPromise
  extends Promise<AggregateArtistFactors>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateArtistFactorsSubscription
  extends Promise<AsyncIterator<AggregateArtistFactors>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ArtistFactorsSetting {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  promotion_factor: Float;
  minutes_exponent: Float;
  finder_fee_factor: Float;
  monthly_fee_duration: Int;
  monthly_fee_amount_per_month: Int;
  annual_fee_amount_per_month: Int;
}

export interface ArtistFactorsSettingPromise
  extends Promise<ArtistFactorsSetting>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  promotion_factor: () => Promise<Float>;
  minutes_exponent: () => Promise<Float>;
  finder_fee_factor: () => Promise<Float>;
  monthly_fee_duration: () => Promise<Int>;
  monthly_fee_amount_per_month: () => Promise<Int>;
  annual_fee_amount_per_month: () => Promise<Int>;
}

export interface ArtistFactorsSettingSubscription
  extends Promise<AsyncIterator<ArtistFactorsSetting>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  promotion_factor: () => Promise<AsyncIterator<Float>>;
  minutes_exponent: () => Promise<AsyncIterator<Float>>;
  finder_fee_factor: () => Promise<AsyncIterator<Float>>;
  monthly_fee_duration: () => Promise<AsyncIterator<Int>>;
  monthly_fee_amount_per_month: () => Promise<AsyncIterator<Int>>;
  annual_fee_amount_per_month: () => Promise<AsyncIterator<Int>>;
}

export interface ArtistFactorsSettingConnection {
  pageInfo: PageInfo;
  edges: ArtistFactorsSettingEdge[];
}

export interface ArtistFactorsSettingConnectionPromise
  extends Promise<ArtistFactorsSettingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ArtistFactorsSettingEdge>>() => T;
  aggregate: <T = AggregateArtistFactorsSettingPromise>() => T;
}

export interface ArtistFactorsSettingConnectionSubscription
  extends Promise<AsyncIterator<ArtistFactorsSettingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ArtistFactorsSettingEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateArtistFactorsSettingSubscription>() => T;
}

export interface ArtistFactorsSettingEdge {
  node: ArtistFactorsSetting;
  cursor: String;
}

export interface ArtistFactorsSettingEdgePromise
  extends Promise<ArtistFactorsSettingEdge>,
    Fragmentable {
  node: <T = ArtistFactorsSettingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ArtistFactorsSettingEdgeSubscription
  extends Promise<AsyncIterator<ArtistFactorsSettingEdge>>,
    Fragmentable {
  node: <T = ArtistFactorsSettingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateArtistFactorsSetting {
  count: Int;
}

export interface AggregateArtistFactorsSettingPromise
  extends Promise<AggregateArtistFactorsSetting>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateArtistFactorsSettingSubscription
  extends Promise<AsyncIterator<AggregateArtistFactorsSetting>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CategoryConnection {
  pageInfo: PageInfo;
  edges: CategoryEdge[];
}

export interface CategoryConnectionPromise
  extends Promise<CategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CategoryEdge>>() => T;
  aggregate: <T = AggregateCategoryPromise>() => T;
}

export interface CategoryConnectionSubscription
  extends Promise<AsyncIterator<CategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCategorySubscription>() => T;
}

export interface CategoryEdge {
  node: Category;
  cursor: String;
}

export interface CategoryEdgePromise
  extends Promise<CategoryEdge>,
    Fragmentable {
  node: <T = CategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CategoryEdgeSubscription
  extends Promise<AsyncIterator<CategoryEdge>>,
    Fragmentable {
  node: <T = CategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCategory {
  count: Int;
}

export interface AggregateCategoryPromise
  extends Promise<AggregateCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCategorySubscription
  extends Promise<AsyncIterator<AggregateCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ChargeHistory {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  amount: Int;
  chargeDate?: DateTimeOutput;
  chargeId?: String;
  refunded: Boolean;
}

export interface ChargeHistoryPromise
  extends Promise<ChargeHistory>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  amount: () => Promise<Int>;
  chargeDate: () => Promise<DateTimeOutput>;
  chargeId: () => Promise<String>;
  refunded: () => Promise<Boolean>;
}

export interface ChargeHistorySubscription
  extends Promise<AsyncIterator<ChargeHistory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  amount: () => Promise<AsyncIterator<Int>>;
  chargeDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  chargeId: () => Promise<AsyncIterator<String>>;
  refunded: () => Promise<AsyncIterator<Boolean>>;
}

export interface ChargeHistoryConnection {
  pageInfo: PageInfo;
  edges: ChargeHistoryEdge[];
}

export interface ChargeHistoryConnectionPromise
  extends Promise<ChargeHistoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChargeHistoryEdge>>() => T;
  aggregate: <T = AggregateChargeHistoryPromise>() => T;
}

export interface ChargeHistoryConnectionSubscription
  extends Promise<AsyncIterator<ChargeHistoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ChargeHistoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateChargeHistorySubscription>() => T;
}

export interface ChargeHistoryEdge {
  node: ChargeHistory;
  cursor: String;
}

export interface ChargeHistoryEdgePromise
  extends Promise<ChargeHistoryEdge>,
    Fragmentable {
  node: <T = ChargeHistoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChargeHistoryEdgeSubscription
  extends Promise<AsyncIterator<ChargeHistoryEdge>>,
    Fragmentable {
  node: <T = ChargeHistorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateChargeHistory {
  count: Int;
}

export interface AggregateChargeHistoryPromise
  extends Promise<AggregateChargeHistory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChargeHistorySubscription
  extends Promise<AsyncIterator<AggregateChargeHistory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Curriculum {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  text: String;
  order?: Int;
}

export interface CurriculumPromise extends Promise<Curriculum>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  text: () => Promise<String>;
  order: () => Promise<Int>;
  author: <T = UserPromise>() => T;
}

export interface CurriculumSubscription
  extends Promise<AsyncIterator<Curriculum>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  author: <T = UserSubscription>() => T;
}

export interface CurriculumConnection {
  pageInfo: PageInfo;
  edges: CurriculumEdge[];
}

export interface CurriculumConnectionPromise
  extends Promise<CurriculumConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CurriculumEdge>>() => T;
  aggregate: <T = AggregateCurriculumPromise>() => T;
}

export interface CurriculumConnectionSubscription
  extends Promise<AsyncIterator<CurriculumConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CurriculumEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCurriculumSubscription>() => T;
}

export interface CurriculumEdge {
  node: Curriculum;
  cursor: String;
}

export interface CurriculumEdgePromise
  extends Promise<CurriculumEdge>,
    Fragmentable {
  node: <T = CurriculumPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CurriculumEdgeSubscription
  extends Promise<AsyncIterator<CurriculumEdge>>,
    Fragmentable {
  node: <T = CurriculumSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCurriculum {
  count: Int;
}

export interface AggregateCurriculumPromise
  extends Promise<AggregateCurriculum>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCurriculumSubscription
  extends Promise<AsyncIterator<AggregateCurriculum>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PlayHistory {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  playSeconds: Int;
  realPlaySeconds: Int;
}

export interface PlayHistoryPromise extends Promise<PlayHistory>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  video: <T = VideoPromise>() => T;
  playSeconds: () => Promise<Int>;
  realPlaySeconds: () => Promise<Int>;
}

export interface PlayHistorySubscription
  extends Promise<AsyncIterator<PlayHistory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  video: <T = VideoSubscription>() => T;
  playSeconds: () => Promise<AsyncIterator<Int>>;
  realPlaySeconds: () => Promise<AsyncIterator<Int>>;
}

export interface PlayHistoryConnection {
  pageInfo: PageInfo;
  edges: PlayHistoryEdge[];
}

export interface PlayHistoryConnectionPromise
  extends Promise<PlayHistoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlayHistoryEdge>>() => T;
  aggregate: <T = AggregatePlayHistoryPromise>() => T;
}

export interface PlayHistoryConnectionSubscription
  extends Promise<AsyncIterator<PlayHistoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlayHistoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlayHistorySubscription>() => T;
}

export interface PlayHistoryEdge {
  node: PlayHistory;
  cursor: String;
}

export interface PlayHistoryEdgePromise
  extends Promise<PlayHistoryEdge>,
    Fragmentable {
  node: <T = PlayHistoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlayHistoryEdgeSubscription
  extends Promise<AsyncIterator<PlayHistoryEdge>>,
    Fragmentable {
  node: <T = PlayHistorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePlayHistory {
  count: Int;
}

export interface AggregatePlayHistoryPromise
  extends Promise<AggregatePlayHistory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlayHistorySubscription
  extends Promise<AsyncIterator<AggregatePlayHistory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Post {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  mainImageUrl?: String;
  text: String;
}

export interface PostPromise extends Promise<Post>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  mainImageUrl: () => Promise<String>;
  text: () => Promise<String>;
  author: <T = UserPromise>() => T;
}

export interface PostSubscription
  extends Promise<AsyncIterator<Post>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  mainImageUrl: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  author: <T = UserSubscription>() => T;
}

export interface PostConnection {
  pageInfo: PageInfo;
  edges: PostEdge[];
}

export interface PostConnectionPromise
  extends Promise<PostConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostEdge>>() => T;
  aggregate: <T = AggregatePostPromise>() => T;
}

export interface PostConnectionSubscription
  extends Promise<AsyncIterator<PostConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostSubscription>() => T;
}

export interface PostEdge {
  node: Post;
  cursor: String;
}

export interface PostEdgePromise extends Promise<PostEdge>, Fragmentable {
  node: <T = PostPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostEdgeSubscription
  extends Promise<AsyncIterator<PostEdge>>,
    Fragmentable {
  node: <T = PostSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePost {
  count: Int;
}

export interface AggregatePostPromise
  extends Promise<AggregatePost>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostSubscription
  extends Promise<AsyncIterator<AggregatePost>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProfitPoolCalculation {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  year: Int;
  month: Int;
  annual_active_subscribers: Int;
  monthly_active_subscribers: Int;
  annual_subscription_rate?: Int;
  monthly_subscription_rate?: Int;
  annual_pool_revenue: Int;
  monthly_pool_revenue: Int;
  total_revenue: Int;
  total_payment_to_artists: Float;
  net_revenue: Float;
}

export interface ProfitPoolCalculationPromise
  extends Promise<ProfitPoolCalculation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  year: () => Promise<Int>;
  month: () => Promise<Int>;
  annual_active_subscribers: () => Promise<Int>;
  monthly_active_subscribers: () => Promise<Int>;
  annual_subscription_rate: () => Promise<Int>;
  monthly_subscription_rate: () => Promise<Int>;
  annual_pool_revenue: () => Promise<Int>;
  monthly_pool_revenue: () => Promise<Int>;
  total_revenue: () => Promise<Int>;
  total_payment_to_artists: () => Promise<Float>;
  net_revenue: () => Promise<Float>;
}

export interface ProfitPoolCalculationSubscription
  extends Promise<AsyncIterator<ProfitPoolCalculation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  year: () => Promise<AsyncIterator<Int>>;
  month: () => Promise<AsyncIterator<Int>>;
  annual_active_subscribers: () => Promise<AsyncIterator<Int>>;
  monthly_active_subscribers: () => Promise<AsyncIterator<Int>>;
  annual_subscription_rate: () => Promise<AsyncIterator<Int>>;
  monthly_subscription_rate: () => Promise<AsyncIterator<Int>>;
  annual_pool_revenue: () => Promise<AsyncIterator<Int>>;
  monthly_pool_revenue: () => Promise<AsyncIterator<Int>>;
  total_revenue: () => Promise<AsyncIterator<Int>>;
  total_payment_to_artists: () => Promise<AsyncIterator<Float>>;
  net_revenue: () => Promise<AsyncIterator<Float>>;
}

export interface ProfitPoolCalculationConnection {
  pageInfo: PageInfo;
  edges: ProfitPoolCalculationEdge[];
}

export interface ProfitPoolCalculationConnectionPromise
  extends Promise<ProfitPoolCalculationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProfitPoolCalculationEdge>>() => T;
  aggregate: <T = AggregateProfitPoolCalculationPromise>() => T;
}

export interface ProfitPoolCalculationConnectionSubscription
  extends Promise<AsyncIterator<ProfitPoolCalculationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ProfitPoolCalculationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateProfitPoolCalculationSubscription>() => T;
}

export interface ProfitPoolCalculationEdge {
  node: ProfitPoolCalculation;
  cursor: String;
}

export interface ProfitPoolCalculationEdgePromise
  extends Promise<ProfitPoolCalculationEdge>,
    Fragmentable {
  node: <T = ProfitPoolCalculationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProfitPoolCalculationEdgeSubscription
  extends Promise<AsyncIterator<ProfitPoolCalculationEdge>>,
    Fragmentable {
  node: <T = ProfitPoolCalculationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProfitPoolCalculation {
  count: Int;
}

export interface AggregateProfitPoolCalculationPromise
  extends Promise<AggregateProfitPoolCalculation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProfitPoolCalculationSubscription
  extends Promise<AsyncIterator<AggregateProfitPoolCalculation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProfitPoolFactor {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  overhead: Int;
  monthly_multiplier: Float;
  finder_fee_multiplier: Float;
  profit_pool_option1_variable: Int;
  profit_pool_option1_multiplier: Float;
  profit_pool_option2_variable: Int;
  profit_pool_option2_multiplier: Float;
  profit_pool_percentage: Float;
  manual_change: Int;
}

export interface ProfitPoolFactorPromise
  extends Promise<ProfitPoolFactor>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  overhead: () => Promise<Int>;
  monthly_multiplier: () => Promise<Float>;
  finder_fee_multiplier: () => Promise<Float>;
  profit_pool_option1_variable: () => Promise<Int>;
  profit_pool_option1_multiplier: () => Promise<Float>;
  profit_pool_option2_variable: () => Promise<Int>;
  profit_pool_option2_multiplier: () => Promise<Float>;
  profit_pool_percentage: () => Promise<Float>;
  manual_change: () => Promise<Int>;
}

export interface ProfitPoolFactorSubscription
  extends Promise<AsyncIterator<ProfitPoolFactor>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  overhead: () => Promise<AsyncIterator<Int>>;
  monthly_multiplier: () => Promise<AsyncIterator<Float>>;
  finder_fee_multiplier: () => Promise<AsyncIterator<Float>>;
  profit_pool_option1_variable: () => Promise<AsyncIterator<Int>>;
  profit_pool_option1_multiplier: () => Promise<AsyncIterator<Float>>;
  profit_pool_option2_variable: () => Promise<AsyncIterator<Int>>;
  profit_pool_option2_multiplier: () => Promise<AsyncIterator<Float>>;
  profit_pool_percentage: () => Promise<AsyncIterator<Float>>;
  manual_change: () => Promise<AsyncIterator<Int>>;
}

export interface ProfitPoolFactorConnection {
  pageInfo: PageInfo;
  edges: ProfitPoolFactorEdge[];
}

export interface ProfitPoolFactorConnectionPromise
  extends Promise<ProfitPoolFactorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProfitPoolFactorEdge>>() => T;
  aggregate: <T = AggregateProfitPoolFactorPromise>() => T;
}

export interface ProfitPoolFactorConnectionSubscription
  extends Promise<AsyncIterator<ProfitPoolFactorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProfitPoolFactorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProfitPoolFactorSubscription>() => T;
}

export interface ProfitPoolFactorEdge {
  node: ProfitPoolFactor;
  cursor: String;
}

export interface ProfitPoolFactorEdgePromise
  extends Promise<ProfitPoolFactorEdge>,
    Fragmentable {
  node: <T = ProfitPoolFactorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProfitPoolFactorEdgeSubscription
  extends Promise<AsyncIterator<ProfitPoolFactorEdge>>,
    Fragmentable {
  node: <T = ProfitPoolFactorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProfitPoolFactor {
  count: Int;
}

export interface AggregateProfitPoolFactorPromise
  extends Promise<AggregateProfitPoolFactor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProfitPoolFactorSubscription
  extends Promise<AsyncIterator<AggregateProfitPoolFactor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PromoCodeConnection {
  pageInfo: PageInfo;
  edges: PromoCodeEdge[];
}

export interface PromoCodeConnectionPromise
  extends Promise<PromoCodeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PromoCodeEdge>>() => T;
  aggregate: <T = AggregatePromoCodePromise>() => T;
}

export interface PromoCodeConnectionSubscription
  extends Promise<AsyncIterator<PromoCodeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PromoCodeEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePromoCodeSubscription>() => T;
}

export interface PromoCodeEdge {
  node: PromoCode;
  cursor: String;
}

export interface PromoCodeEdgePromise
  extends Promise<PromoCodeEdge>,
    Fragmentable {
  node: <T = PromoCodePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PromoCodeEdgeSubscription
  extends Promise<AsyncIterator<PromoCodeEdge>>,
    Fragmentable {
  node: <T = PromoCodeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePromoCode {
  count: Int;
}

export interface AggregatePromoCodePromise
  extends Promise<AggregatePromoCode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePromoCodeSubscription
  extends Promise<AsyncIterator<AggregatePromoCode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RestoreCode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  valid_until: DateTimeOutput;
  code: String;
}

export interface RestoreCodePromise extends Promise<RestoreCode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  valid_until: () => Promise<DateTimeOutput>;
  code: () => Promise<String>;
}

export interface RestoreCodeSubscription
  extends Promise<AsyncIterator<RestoreCode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  valid_until: () => Promise<AsyncIterator<DateTimeOutput>>;
  code: () => Promise<AsyncIterator<String>>;
}

export interface RestoreCodeConnection {
  pageInfo: PageInfo;
  edges: RestoreCodeEdge[];
}

export interface RestoreCodeConnectionPromise
  extends Promise<RestoreCodeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RestoreCodeEdge>>() => T;
  aggregate: <T = AggregateRestoreCodePromise>() => T;
}

export interface RestoreCodeConnectionSubscription
  extends Promise<AsyncIterator<RestoreCodeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RestoreCodeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRestoreCodeSubscription>() => T;
}

export interface RestoreCodeEdge {
  node: RestoreCode;
  cursor: String;
}

export interface RestoreCodeEdgePromise
  extends Promise<RestoreCodeEdge>,
    Fragmentable {
  node: <T = RestoreCodePromise>() => T;
  cursor: () => Promise<String>;
}

export interface RestoreCodeEdgeSubscription
  extends Promise<AsyncIterator<RestoreCodeEdge>>,
    Fragmentable {
  node: <T = RestoreCodeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRestoreCode {
  count: Int;
}

export interface AggregateRestoreCodePromise
  extends Promise<AggregateRestoreCode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRestoreCodeSubscription
  extends Promise<AsyncIterator<AggregateRestoreCode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Settings {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  int_val?: Int;
  str_val?: String;
}

export interface SettingsPromise extends Promise<Settings>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  int_val: () => Promise<Int>;
  str_val: () => Promise<String>;
}

export interface SettingsSubscription
  extends Promise<AsyncIterator<Settings>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  int_val: () => Promise<AsyncIterator<Int>>;
  str_val: () => Promise<AsyncIterator<String>>;
}

export interface SettingsConnection {
  pageInfo: PageInfo;
  edges: SettingsEdge[];
}

export interface SettingsConnectionPromise
  extends Promise<SettingsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SettingsEdge>>() => T;
  aggregate: <T = AggregateSettingsPromise>() => T;
}

export interface SettingsConnectionSubscription
  extends Promise<AsyncIterator<SettingsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SettingsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSettingsSubscription>() => T;
}

export interface SettingsEdge {
  node: Settings;
  cursor: String;
}

export interface SettingsEdgePromise
  extends Promise<SettingsEdge>,
    Fragmentable {
  node: <T = SettingsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SettingsEdgeSubscription
  extends Promise<AsyncIterator<SettingsEdge>>,
    Fragmentable {
  node: <T = SettingsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSettings {
  count: Int;
}

export interface AggregateSettingsPromise
  extends Promise<AggregateSettings>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSettingsSubscription
  extends Promise<AsyncIterator<AggregateSettings>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SubscriptionHistory {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  interval: String;
  amount: Int;
  subscriptionDate?: DateTimeOutput;
}

export interface SubscriptionHistoryPromise
  extends Promise<SubscriptionHistory>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  interval: () => Promise<String>;
  amount: () => Promise<Int>;
  subscriptionDate: () => Promise<DateTimeOutput>;
}

export interface SubscriptionHistorySubscription
  extends Promise<AsyncIterator<SubscriptionHistory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  interval: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Int>>;
  subscriptionDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SubscriptionHistoryConnection {
  pageInfo: PageInfo;
  edges: SubscriptionHistoryEdge[];
}

export interface SubscriptionHistoryConnectionPromise
  extends Promise<SubscriptionHistoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubscriptionHistoryEdge>>() => T;
  aggregate: <T = AggregateSubscriptionHistoryPromise>() => T;
}

export interface SubscriptionHistoryConnectionSubscription
  extends Promise<AsyncIterator<SubscriptionHistoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<SubscriptionHistoryEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateSubscriptionHistorySubscription>() => T;
}

export interface SubscriptionHistoryEdge {
  node: SubscriptionHistory;
  cursor: String;
}

export interface SubscriptionHistoryEdgePromise
  extends Promise<SubscriptionHistoryEdge>,
    Fragmentable {
  node: <T = SubscriptionHistoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubscriptionHistoryEdgeSubscription
  extends Promise<AsyncIterator<SubscriptionHistoryEdge>>,
    Fragmentable {
  node: <T = SubscriptionHistorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSubscriptionHistory {
  count: Int;
}

export interface AggregateSubscriptionHistoryPromise
  extends Promise<AggregateSubscriptionHistory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubscriptionHistorySubscription
  extends Promise<AsyncIterator<AggregateSubscriptionHistory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TagConnection {
  pageInfo: PageInfo;
  edges: TagEdge[];
}

export interface TagConnectionPromise
  extends Promise<TagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TagEdge>>() => T;
  aggregate: <T = AggregateTagPromise>() => T;
}

export interface TagConnectionSubscription
  extends Promise<AsyncIterator<TagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTagSubscription>() => T;
}

export interface TagEdge {
  node: Tag;
  cursor: String;
}

export interface TagEdgePromise extends Promise<TagEdge>, Fragmentable {
  node: <T = TagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TagEdgeSubscription
  extends Promise<AsyncIterator<TagEdge>>,
    Fragmentable {
  node: <T = TagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTag {
  count: Int;
}

export interface AggregateTagPromise
  extends Promise<AggregateTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagSubscription
  extends Promise<AsyncIterator<AggregateTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TotalMinutesForArtist {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  year: Int;
  month: Int;
  minutes_as_owner1: Float;
  minutes_as_owner2: Float;
  minutes_as_owner3: Float;
  total_minutes: Float;
  artist_rating_factor: Float;
  final_minutes: Float;
  percent_of_profit_pool: Float;
  monthly_quantity: Int;
  annual_quantity: Int;
  finder_fee: Int;
  payment_from_profit_pool: Float;
  total_payment: Float;
}

export interface TotalMinutesForArtistPromise
  extends Promise<TotalMinutesForArtist>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  year: () => Promise<Int>;
  month: () => Promise<Int>;
  artist: <T = UserPromise>() => T;
  minutes_as_owner1: () => Promise<Float>;
  minutes_as_owner2: () => Promise<Float>;
  minutes_as_owner3: () => Promise<Float>;
  total_minutes: () => Promise<Float>;
  artist_rating_factor: () => Promise<Float>;
  final_minutes: () => Promise<Float>;
  percent_of_profit_pool: () => Promise<Float>;
  monthly_quantity: () => Promise<Int>;
  annual_quantity: () => Promise<Int>;
  finder_fee: () => Promise<Int>;
  payment_from_profit_pool: () => Promise<Float>;
  total_payment: () => Promise<Float>;
}

export interface TotalMinutesForArtistSubscription
  extends Promise<AsyncIterator<TotalMinutesForArtist>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  year: () => Promise<AsyncIterator<Int>>;
  month: () => Promise<AsyncIterator<Int>>;
  artist: <T = UserSubscription>() => T;
  minutes_as_owner1: () => Promise<AsyncIterator<Float>>;
  minutes_as_owner2: () => Promise<AsyncIterator<Float>>;
  minutes_as_owner3: () => Promise<AsyncIterator<Float>>;
  total_minutes: () => Promise<AsyncIterator<Float>>;
  artist_rating_factor: () => Promise<AsyncIterator<Float>>;
  final_minutes: () => Promise<AsyncIterator<Float>>;
  percent_of_profit_pool: () => Promise<AsyncIterator<Float>>;
  monthly_quantity: () => Promise<AsyncIterator<Int>>;
  annual_quantity: () => Promise<AsyncIterator<Int>>;
  finder_fee: () => Promise<AsyncIterator<Int>>;
  payment_from_profit_pool: () => Promise<AsyncIterator<Float>>;
  total_payment: () => Promise<AsyncIterator<Float>>;
}

export interface TotalMinutesForArtistConnection {
  pageInfo: PageInfo;
  edges: TotalMinutesForArtistEdge[];
}

export interface TotalMinutesForArtistConnectionPromise
  extends Promise<TotalMinutesForArtistConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TotalMinutesForArtistEdge>>() => T;
  aggregate: <T = AggregateTotalMinutesForArtistPromise>() => T;
}

export interface TotalMinutesForArtistConnectionSubscription
  extends Promise<AsyncIterator<TotalMinutesForArtistConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<TotalMinutesForArtistEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateTotalMinutesForArtistSubscription>() => T;
}

export interface TotalMinutesForArtistEdge {
  node: TotalMinutesForArtist;
  cursor: String;
}

export interface TotalMinutesForArtistEdgePromise
  extends Promise<TotalMinutesForArtistEdge>,
    Fragmentable {
  node: <T = TotalMinutesForArtistPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TotalMinutesForArtistEdgeSubscription
  extends Promise<AsyncIterator<TotalMinutesForArtistEdge>>,
    Fragmentable {
  node: <T = TotalMinutesForArtistSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTotalMinutesForArtist {
  count: Int;
}

export interface AggregateTotalMinutesForArtistPromise
  extends Promise<AggregateTotalMinutesForArtist>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTotalMinutesForArtistSubscription
  extends Promise<AsyncIterator<AggregateTotalMinutesForArtist>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TransferPlan {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  year: Int;
  month: Int;
  amount: Int;
  ignore_status: Boolean;
  paid_status: Boolean;
  paid_date?: DateTimeOutput;
}

export interface TransferPlanPromise
  extends Promise<TransferPlan>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  artist: <T = UserPromise>() => T;
  subscriber: <T = UserPromise>() => T;
  year: () => Promise<Int>;
  month: () => Promise<Int>;
  amount: () => Promise<Int>;
  ignore_status: () => Promise<Boolean>;
  paid_status: () => Promise<Boolean>;
  paid_date: () => Promise<DateTimeOutput>;
}

export interface TransferPlanSubscription
  extends Promise<AsyncIterator<TransferPlan>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  artist: <T = UserSubscription>() => T;
  subscriber: <T = UserSubscription>() => T;
  year: () => Promise<AsyncIterator<Int>>;
  month: () => Promise<AsyncIterator<Int>>;
  amount: () => Promise<AsyncIterator<Int>>;
  ignore_status: () => Promise<AsyncIterator<Boolean>>;
  paid_status: () => Promise<AsyncIterator<Boolean>>;
  paid_date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TransferPlanConnection {
  pageInfo: PageInfo;
  edges: TransferPlanEdge[];
}

export interface TransferPlanConnectionPromise
  extends Promise<TransferPlanConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TransferPlanEdge>>() => T;
  aggregate: <T = AggregateTransferPlanPromise>() => T;
}

export interface TransferPlanConnectionSubscription
  extends Promise<AsyncIterator<TransferPlanConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TransferPlanEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTransferPlanSubscription>() => T;
}

export interface TransferPlanEdge {
  node: TransferPlan;
  cursor: String;
}

export interface TransferPlanEdgePromise
  extends Promise<TransferPlanEdge>,
    Fragmentable {
  node: <T = TransferPlanPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TransferPlanEdgeSubscription
  extends Promise<AsyncIterator<TransferPlanEdge>>,
    Fragmentable {
  node: <T = TransferPlanSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTransferPlan {
  count: Int;
}

export interface AggregateTransferPlanPromise
  extends Promise<AggregateTransferPlan>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTransferPlanSubscription
  extends Promise<AsyncIterator<AggregateTransferPlan>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TransferTransaction {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  year: Int;
  month: Int;
  amount: Int;
  paid_status: Boolean;
  paid_date?: DateTimeOutput;
}

export interface TransferTransactionPromise
  extends Promise<TransferTransaction>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  artist: <T = UserPromise>() => T;
  year: () => Promise<Int>;
  month: () => Promise<Int>;
  amount: () => Promise<Int>;
  paid_status: () => Promise<Boolean>;
  paid_date: () => Promise<DateTimeOutput>;
}

export interface TransferTransactionSubscription
  extends Promise<AsyncIterator<TransferTransaction>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  artist: <T = UserSubscription>() => T;
  year: () => Promise<AsyncIterator<Int>>;
  month: () => Promise<AsyncIterator<Int>>;
  amount: () => Promise<AsyncIterator<Int>>;
  paid_status: () => Promise<AsyncIterator<Boolean>>;
  paid_date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TransferTransactionConnection {
  pageInfo: PageInfo;
  edges: TransferTransactionEdge[];
}

export interface TransferTransactionConnectionPromise
  extends Promise<TransferTransactionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TransferTransactionEdge>>() => T;
  aggregate: <T = AggregateTransferTransactionPromise>() => T;
}

export interface TransferTransactionConnectionSubscription
  extends Promise<AsyncIterator<TransferTransactionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<TransferTransactionEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateTransferTransactionSubscription>() => T;
}

export interface TransferTransactionEdge {
  node: TransferTransaction;
  cursor: String;
}

export interface TransferTransactionEdgePromise
  extends Promise<TransferTransactionEdge>,
    Fragmentable {
  node: <T = TransferTransactionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TransferTransactionEdgeSubscription
  extends Promise<AsyncIterator<TransferTransactionEdge>>,
    Fragmentable {
  node: <T = TransferTransactionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTransferTransaction {
  count: Int;
}

export interface AggregateTransferTransactionPromise
  extends Promise<AggregateTransferTransaction>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTransferTransactionSubscription
  extends Promise<AsyncIterator<AggregateTransferTransaction>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VideoConnection {
  pageInfo: PageInfo;
  edges: VideoEdge[];
}

export interface VideoConnectionPromise
  extends Promise<VideoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VideoEdge>>() => T;
  aggregate: <T = AggregateVideoPromise>() => T;
}

export interface VideoConnectionSubscription
  extends Promise<AsyncIterator<VideoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VideoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVideoSubscription>() => T;
}

export interface VideoEdge {
  node: Video;
  cursor: String;
}

export interface VideoEdgePromise extends Promise<VideoEdge>, Fragmentable {
  node: <T = VideoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VideoEdgeSubscription
  extends Promise<AsyncIterator<VideoEdge>>,
    Fragmentable {
  node: <T = VideoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVideo {
  count: Int;
}

export interface AggregateVideoPromise
  extends Promise<AggregateVideo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVideoSubscription
  extends Promise<AsyncIterator<AggregateVideo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VideoDataForMonth {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  year: Int;
  month: Int;
  video_length: Int;
  unique_users: Int;
  real_minutes_watched: Int;
  avg_minutes_watched: Int;
  exponent_applied: Int;
  minutes_after_exponent: Int;
}

export interface VideoDataForMonthPromise
  extends Promise<VideoDataForMonth>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  year: () => Promise<Int>;
  month: () => Promise<Int>;
  video: <T = VideoPromise>() => T;
  video_length: () => Promise<Int>;
  unique_users: () => Promise<Int>;
  real_minutes_watched: () => Promise<Int>;
  avg_minutes_watched: () => Promise<Int>;
  exponent_applied: () => Promise<Int>;
  minutes_after_exponent: () => Promise<Int>;
}

export interface VideoDataForMonthSubscription
  extends Promise<AsyncIterator<VideoDataForMonth>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  year: () => Promise<AsyncIterator<Int>>;
  month: () => Promise<AsyncIterator<Int>>;
  video: <T = VideoSubscription>() => T;
  video_length: () => Promise<AsyncIterator<Int>>;
  unique_users: () => Promise<AsyncIterator<Int>>;
  real_minutes_watched: () => Promise<AsyncIterator<Int>>;
  avg_minutes_watched: () => Promise<AsyncIterator<Int>>;
  exponent_applied: () => Promise<AsyncIterator<Int>>;
  minutes_after_exponent: () => Promise<AsyncIterator<Int>>;
}

export interface VideoDataForMonthConnection {
  pageInfo: PageInfo;
  edges: VideoDataForMonthEdge[];
}

export interface VideoDataForMonthConnectionPromise
  extends Promise<VideoDataForMonthConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VideoDataForMonthEdge>>() => T;
  aggregate: <T = AggregateVideoDataForMonthPromise>() => T;
}

export interface VideoDataForMonthConnectionSubscription
  extends Promise<AsyncIterator<VideoDataForMonthConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VideoDataForMonthEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVideoDataForMonthSubscription>() => T;
}

export interface VideoDataForMonthEdge {
  node: VideoDataForMonth;
  cursor: String;
}

export interface VideoDataForMonthEdgePromise
  extends Promise<VideoDataForMonthEdge>,
    Fragmentable {
  node: <T = VideoDataForMonthPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VideoDataForMonthEdgeSubscription
  extends Promise<AsyncIterator<VideoDataForMonthEdge>>,
    Fragmentable {
  node: <T = VideoDataForMonthSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVideoDataForMonth {
  count: Int;
}

export interface AggregateVideoDataForMonthPromise
  extends Promise<AggregateVideoDataForMonth>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVideoDataForMonthSubscription
  extends Promise<AsyncIterator<AggregateVideoDataForMonth>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VideoParameters {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  owner1_percentage: Int;
  owner2_percentage: Int;
  owner3_percentage: Int;
}

export interface VideoParametersPromise
  extends Promise<VideoParameters>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  video: <T = VideoPromise>() => T;
  owner1: <T = UserPromise>() => T;
  owner1_percentage: () => Promise<Int>;
  owner2: <T = UserPromise>() => T;
  owner2_percentage: () => Promise<Int>;
  owner3: <T = UserPromise>() => T;
  owner3_percentage: () => Promise<Int>;
}

export interface VideoParametersSubscription
  extends Promise<AsyncIterator<VideoParameters>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  video: <T = VideoSubscription>() => T;
  owner1: <T = UserSubscription>() => T;
  owner1_percentage: () => Promise<AsyncIterator<Int>>;
  owner2: <T = UserSubscription>() => T;
  owner2_percentage: () => Promise<AsyncIterator<Int>>;
  owner3: <T = UserSubscription>() => T;
  owner3_percentage: () => Promise<AsyncIterator<Int>>;
}

export interface VideoParametersConnection {
  pageInfo: PageInfo;
  edges: VideoParametersEdge[];
}

export interface VideoParametersConnectionPromise
  extends Promise<VideoParametersConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VideoParametersEdge>>() => T;
  aggregate: <T = AggregateVideoParametersPromise>() => T;
}

export interface VideoParametersConnectionSubscription
  extends Promise<AsyncIterator<VideoParametersConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VideoParametersEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVideoParametersSubscription>() => T;
}

export interface VideoParametersEdge {
  node: VideoParameters;
  cursor: String;
}

export interface VideoParametersEdgePromise
  extends Promise<VideoParametersEdge>,
    Fragmentable {
  node: <T = VideoParametersPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VideoParametersEdgeSubscription
  extends Promise<AsyncIterator<VideoParametersEdge>>,
    Fragmentable {
  node: <T = VideoParametersSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVideoParameters {
  count: Int;
}

export interface AggregateVideoParametersPromise
  extends Promise<AggregateVideoParameters>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVideoParametersSubscription
  extends Promise<AsyncIterator<AggregateVideoParameters>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VideoParametersForMonth {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  year: Int;
  month: Int;
  owner1_percentage: Int;
  owner2_percentage: Int;
  owner3_percentage: Int;
  total_minutes: Float;
  owner1_minutes: Float;
  owner2_minutes: Float;
  owner3_minutes: Float;
}

export interface VideoParametersForMonthPromise
  extends Promise<VideoParametersForMonth>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  year: () => Promise<Int>;
  month: () => Promise<Int>;
  video: <T = VideoPromise>() => T;
  owner1: <T = UserPromise>() => T;
  owner1_percentage: () => Promise<Int>;
  owner2: <T = UserPromise>() => T;
  owner2_percentage: () => Promise<Int>;
  owner3: <T = UserPromise>() => T;
  owner3_percentage: () => Promise<Int>;
  total_minutes: () => Promise<Float>;
  owner1_minutes: () => Promise<Float>;
  owner2_minutes: () => Promise<Float>;
  owner3_minutes: () => Promise<Float>;
}

export interface VideoParametersForMonthSubscription
  extends Promise<AsyncIterator<VideoParametersForMonth>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  year: () => Promise<AsyncIterator<Int>>;
  month: () => Promise<AsyncIterator<Int>>;
  video: <T = VideoSubscription>() => T;
  owner1: <T = UserSubscription>() => T;
  owner1_percentage: () => Promise<AsyncIterator<Int>>;
  owner2: <T = UserSubscription>() => T;
  owner2_percentage: () => Promise<AsyncIterator<Int>>;
  owner3: <T = UserSubscription>() => T;
  owner3_percentage: () => Promise<AsyncIterator<Int>>;
  total_minutes: () => Promise<AsyncIterator<Float>>;
  owner1_minutes: () => Promise<AsyncIterator<Float>>;
  owner2_minutes: () => Promise<AsyncIterator<Float>>;
  owner3_minutes: () => Promise<AsyncIterator<Float>>;
}

export interface VideoParametersForMonthConnection {
  pageInfo: PageInfo;
  edges: VideoParametersForMonthEdge[];
}

export interface VideoParametersForMonthConnectionPromise
  extends Promise<VideoParametersForMonthConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VideoParametersForMonthEdge>>() => T;
  aggregate: <T = AggregateVideoParametersForMonthPromise>() => T;
}

export interface VideoParametersForMonthConnectionSubscription
  extends Promise<AsyncIterator<VideoParametersForMonthConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<VideoParametersForMonthEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateVideoParametersForMonthSubscription>() => T;
}

export interface VideoParametersForMonthEdge {
  node: VideoParametersForMonth;
  cursor: String;
}

export interface VideoParametersForMonthEdgePromise
  extends Promise<VideoParametersForMonthEdge>,
    Fragmentable {
  node: <T = VideoParametersForMonthPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VideoParametersForMonthEdgeSubscription
  extends Promise<AsyncIterator<VideoParametersForMonthEdge>>,
    Fragmentable {
  node: <T = VideoParametersForMonthSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVideoParametersForMonth {
  count: Int;
}

export interface AggregateVideoParametersForMonthPromise
  extends Promise<AggregateVideoParametersForMonth>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVideoParametersForMonthSubscription
  extends Promise<AsyncIterator<AggregateVideoParametersForMonth>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VideoTotalParameters {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  minutes_watched_multiplier: Float;
  exponent_for_minutes_watched: Float;
  star_rating_multiplier: Float;
  star_rating_on_off: Int;
}

export interface VideoTotalParametersPromise
  extends Promise<VideoTotalParameters>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  minutes_watched_multiplier: () => Promise<Float>;
  exponent_for_minutes_watched: () => Promise<Float>;
  star_rating_multiplier: () => Promise<Float>;
  star_rating_on_off: () => Promise<Int>;
}

export interface VideoTotalParametersSubscription
  extends Promise<AsyncIterator<VideoTotalParameters>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  minutes_watched_multiplier: () => Promise<AsyncIterator<Float>>;
  exponent_for_minutes_watched: () => Promise<AsyncIterator<Float>>;
  star_rating_multiplier: () => Promise<AsyncIterator<Float>>;
  star_rating_on_off: () => Promise<AsyncIterator<Int>>;
}

export interface VideoTotalParametersConnection {
  pageInfo: PageInfo;
  edges: VideoTotalParametersEdge[];
}

export interface VideoTotalParametersConnectionPromise
  extends Promise<VideoTotalParametersConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VideoTotalParametersEdge>>() => T;
  aggregate: <T = AggregateVideoTotalParametersPromise>() => T;
}

export interface VideoTotalParametersConnectionSubscription
  extends Promise<AsyncIterator<VideoTotalParametersConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<VideoTotalParametersEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateVideoTotalParametersSubscription>() => T;
}

export interface VideoTotalParametersEdge {
  node: VideoTotalParameters;
  cursor: String;
}

export interface VideoTotalParametersEdgePromise
  extends Promise<VideoTotalParametersEdge>,
    Fragmentable {
  node: <T = VideoTotalParametersPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VideoTotalParametersEdgeSubscription
  extends Promise<AsyncIterator<VideoTotalParametersEdge>>,
    Fragmentable {
  node: <T = VideoTotalParametersSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVideoTotalParameters {
  count: Int;
}

export interface AggregateVideoTotalParametersPromise
  extends Promise<AggregateVideoTotalParameters>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVideoTotalParametersSubscription
  extends Promise<AsyncIterator<AggregateVideoTotalParameters>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WatchedVideoUserConnection {
  pageInfo: PageInfo;
  edges: WatchedVideoUserEdge[];
}

export interface WatchedVideoUserConnectionPromise
  extends Promise<WatchedVideoUserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WatchedVideoUserEdge>>() => T;
  aggregate: <T = AggregateWatchedVideoUserPromise>() => T;
}

export interface WatchedVideoUserConnectionSubscription
  extends Promise<AsyncIterator<WatchedVideoUserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WatchedVideoUserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWatchedVideoUserSubscription>() => T;
}

export interface WatchedVideoUserEdge {
  node: WatchedVideoUser;
  cursor: String;
}

export interface WatchedVideoUserEdgePromise
  extends Promise<WatchedVideoUserEdge>,
    Fragmentable {
  node: <T = WatchedVideoUserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WatchedVideoUserEdgeSubscription
  extends Promise<AsyncIterator<WatchedVideoUserEdge>>,
    Fragmentable {
  node: <T = WatchedVideoUserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWatchedVideoUser {
  count: Int;
}

export interface AggregateWatchedVideoUserPromise
  extends Promise<AggregateWatchedVideoUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWatchedVideoUserSubscription
  extends Promise<AsyncIterator<AggregateWatchedVideoUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ActivationCodeSubscriptionPayload {
  mutation: MutationType;
  node: ActivationCode;
  updatedFields: String[];
  previousValues: ActivationCodePreviousValues;
}

export interface ActivationCodeSubscriptionPayloadPromise
  extends Promise<ActivationCodeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ActivationCodePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ActivationCodePreviousValuesPromise>() => T;
}

export interface ActivationCodeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ActivationCodeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ActivationCodeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ActivationCodePreviousValuesSubscription>() => T;
}

export interface ActivationCodePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  valid_until: DateTimeOutput;
  code: String;
}

export interface ActivationCodePreviousValuesPromise
  extends Promise<ActivationCodePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  valid_until: () => Promise<DateTimeOutput>;
  code: () => Promise<String>;
}

export interface ActivationCodePreviousValuesSubscription
  extends Promise<AsyncIterator<ActivationCodePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  valid_until: () => Promise<AsyncIterator<DateTimeOutput>>;
  code: () => Promise<AsyncIterator<String>>;
}

export interface ArtistFactorsSubscriptionPayload {
  mutation: MutationType;
  node: ArtistFactors;
  updatedFields: String[];
  previousValues: ArtistFactorsPreviousValues;
}

export interface ArtistFactorsSubscriptionPayloadPromise
  extends Promise<ArtistFactorsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ArtistFactorsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ArtistFactorsPreviousValuesPromise>() => T;
}

export interface ArtistFactorsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ArtistFactorsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ArtistFactorsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ArtistFactorsPreviousValuesSubscription>() => T;
}

export interface ArtistFactorsPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  promotion_factor: Float;
  minutes_exponent: Float;
  finder_fee_factor: Float;
  monthly_fee_duration: Int;
  monthly_fee_amount_per_month: Int;
  annual_fee_amount_per_month: Int;
}

export interface ArtistFactorsPreviousValuesPromise
  extends Promise<ArtistFactorsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  promotion_factor: () => Promise<Float>;
  minutes_exponent: () => Promise<Float>;
  finder_fee_factor: () => Promise<Float>;
  monthly_fee_duration: () => Promise<Int>;
  monthly_fee_amount_per_month: () => Promise<Int>;
  annual_fee_amount_per_month: () => Promise<Int>;
}

export interface ArtistFactorsPreviousValuesSubscription
  extends Promise<AsyncIterator<ArtistFactorsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  promotion_factor: () => Promise<AsyncIterator<Float>>;
  minutes_exponent: () => Promise<AsyncIterator<Float>>;
  finder_fee_factor: () => Promise<AsyncIterator<Float>>;
  monthly_fee_duration: () => Promise<AsyncIterator<Int>>;
  monthly_fee_amount_per_month: () => Promise<AsyncIterator<Int>>;
  annual_fee_amount_per_month: () => Promise<AsyncIterator<Int>>;
}

export interface ArtistFactorsSettingSubscriptionPayload {
  mutation: MutationType;
  node: ArtistFactorsSetting;
  updatedFields: String[];
  previousValues: ArtistFactorsSettingPreviousValues;
}

export interface ArtistFactorsSettingSubscriptionPayloadPromise
  extends Promise<ArtistFactorsSettingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ArtistFactorsSettingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ArtistFactorsSettingPreviousValuesPromise>() => T;
}

export interface ArtistFactorsSettingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ArtistFactorsSettingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ArtistFactorsSettingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ArtistFactorsSettingPreviousValuesSubscription>() => T;
}

export interface ArtistFactorsSettingPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  promotion_factor: Float;
  minutes_exponent: Float;
  finder_fee_factor: Float;
  monthly_fee_duration: Int;
  monthly_fee_amount_per_month: Int;
  annual_fee_amount_per_month: Int;
}

export interface ArtistFactorsSettingPreviousValuesPromise
  extends Promise<ArtistFactorsSettingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  promotion_factor: () => Promise<Float>;
  minutes_exponent: () => Promise<Float>;
  finder_fee_factor: () => Promise<Float>;
  monthly_fee_duration: () => Promise<Int>;
  monthly_fee_amount_per_month: () => Promise<Int>;
  annual_fee_amount_per_month: () => Promise<Int>;
}

export interface ArtistFactorsSettingPreviousValuesSubscription
  extends Promise<AsyncIterator<ArtistFactorsSettingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  promotion_factor: () => Promise<AsyncIterator<Float>>;
  minutes_exponent: () => Promise<AsyncIterator<Float>>;
  finder_fee_factor: () => Promise<AsyncIterator<Float>>;
  monthly_fee_duration: () => Promise<AsyncIterator<Int>>;
  monthly_fee_amount_per_month: () => Promise<AsyncIterator<Int>>;
  annual_fee_amount_per_month: () => Promise<AsyncIterator<Int>>;
}

export interface CategorySubscriptionPayload {
  mutation: MutationType;
  node: Category;
  updatedFields: String[];
  previousValues: CategoryPreviousValues;
}

export interface CategorySubscriptionPayloadPromise
  extends Promise<CategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CategoryPreviousValuesPromise>() => T;
}

export interface CategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CategoryPreviousValuesSubscription>() => T;
}

export interface CategoryPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  description?: String;
}

export interface CategoryPreviousValuesPromise
  extends Promise<CategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  description: () => Promise<String>;
}

export interface CategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<CategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface ChargeHistorySubscriptionPayload {
  mutation: MutationType;
  node: ChargeHistory;
  updatedFields: String[];
  previousValues: ChargeHistoryPreviousValues;
}

export interface ChargeHistorySubscriptionPayloadPromise
  extends Promise<ChargeHistorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChargeHistoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChargeHistoryPreviousValuesPromise>() => T;
}

export interface ChargeHistorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChargeHistorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChargeHistorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChargeHistoryPreviousValuesSubscription>() => T;
}

export interface ChargeHistoryPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  amount: Int;
  chargeDate?: DateTimeOutput;
  chargeId?: String;
  refunded: Boolean;
}

export interface ChargeHistoryPreviousValuesPromise
  extends Promise<ChargeHistoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  amount: () => Promise<Int>;
  chargeDate: () => Promise<DateTimeOutput>;
  chargeId: () => Promise<String>;
  refunded: () => Promise<Boolean>;
}

export interface ChargeHistoryPreviousValuesSubscription
  extends Promise<AsyncIterator<ChargeHistoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amount: () => Promise<AsyncIterator<Int>>;
  chargeDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  chargeId: () => Promise<AsyncIterator<String>>;
  refunded: () => Promise<AsyncIterator<Boolean>>;
}

export interface CurriculumSubscriptionPayload {
  mutation: MutationType;
  node: Curriculum;
  updatedFields: String[];
  previousValues: CurriculumPreviousValues;
}

export interface CurriculumSubscriptionPayloadPromise
  extends Promise<CurriculumSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CurriculumPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CurriculumPreviousValuesPromise>() => T;
}

export interface CurriculumSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CurriculumSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CurriculumSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CurriculumPreviousValuesSubscription>() => T;
}

export interface CurriculumPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  text: String;
  order?: Int;
}

export interface CurriculumPreviousValuesPromise
  extends Promise<CurriculumPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  text: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface CurriculumPreviousValuesSubscription
  extends Promise<AsyncIterator<CurriculumPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface PlayHistorySubscriptionPayload {
  mutation: MutationType;
  node: PlayHistory;
  updatedFields: String[];
  previousValues: PlayHistoryPreviousValues;
}

export interface PlayHistorySubscriptionPayloadPromise
  extends Promise<PlayHistorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlayHistoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlayHistoryPreviousValuesPromise>() => T;
}

export interface PlayHistorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlayHistorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlayHistorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlayHistoryPreviousValuesSubscription>() => T;
}

export interface PlayHistoryPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  playSeconds: Int;
  realPlaySeconds: Int;
}

export interface PlayHistoryPreviousValuesPromise
  extends Promise<PlayHistoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  playSeconds: () => Promise<Int>;
  realPlaySeconds: () => Promise<Int>;
}

export interface PlayHistoryPreviousValuesSubscription
  extends Promise<AsyncIterator<PlayHistoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  playSeconds: () => Promise<AsyncIterator<Int>>;
  realPlaySeconds: () => Promise<AsyncIterator<Int>>;
}

export interface PostSubscriptionPayload {
  mutation: MutationType;
  node: Post;
  updatedFields: String[];
  previousValues: PostPreviousValues;
}

export interface PostSubscriptionPayloadPromise
  extends Promise<PostSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostPreviousValuesPromise>() => T;
}

export interface PostSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostPreviousValuesSubscription>() => T;
}

export interface PostPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  mainImageUrl?: String;
  text: String;
}

export interface PostPreviousValuesPromise
  extends Promise<PostPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  mainImageUrl: () => Promise<String>;
  text: () => Promise<String>;
}

export interface PostPreviousValuesSubscription
  extends Promise<AsyncIterator<PostPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  mainImageUrl: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface ProfitPoolCalculationSubscriptionPayload {
  mutation: MutationType;
  node: ProfitPoolCalculation;
  updatedFields: String[];
  previousValues: ProfitPoolCalculationPreviousValues;
}

export interface ProfitPoolCalculationSubscriptionPayloadPromise
  extends Promise<ProfitPoolCalculationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProfitPoolCalculationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProfitPoolCalculationPreviousValuesPromise>() => T;
}

export interface ProfitPoolCalculationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProfitPoolCalculationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProfitPoolCalculationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProfitPoolCalculationPreviousValuesSubscription>() => T;
}

export interface ProfitPoolCalculationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  year: Int;
  month: Int;
  annual_active_subscribers: Int;
  monthly_active_subscribers: Int;
  annual_subscription_rate?: Int;
  monthly_subscription_rate?: Int;
  annual_pool_revenue: Int;
  monthly_pool_revenue: Int;
  total_revenue: Int;
  total_payment_to_artists: Float;
  net_revenue: Float;
}

export interface ProfitPoolCalculationPreviousValuesPromise
  extends Promise<ProfitPoolCalculationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  year: () => Promise<Int>;
  month: () => Promise<Int>;
  annual_active_subscribers: () => Promise<Int>;
  monthly_active_subscribers: () => Promise<Int>;
  annual_subscription_rate: () => Promise<Int>;
  monthly_subscription_rate: () => Promise<Int>;
  annual_pool_revenue: () => Promise<Int>;
  monthly_pool_revenue: () => Promise<Int>;
  total_revenue: () => Promise<Int>;
  total_payment_to_artists: () => Promise<Float>;
  net_revenue: () => Promise<Float>;
}

export interface ProfitPoolCalculationPreviousValuesSubscription
  extends Promise<AsyncIterator<ProfitPoolCalculationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  year: () => Promise<AsyncIterator<Int>>;
  month: () => Promise<AsyncIterator<Int>>;
  annual_active_subscribers: () => Promise<AsyncIterator<Int>>;
  monthly_active_subscribers: () => Promise<AsyncIterator<Int>>;
  annual_subscription_rate: () => Promise<AsyncIterator<Int>>;
  monthly_subscription_rate: () => Promise<AsyncIterator<Int>>;
  annual_pool_revenue: () => Promise<AsyncIterator<Int>>;
  monthly_pool_revenue: () => Promise<AsyncIterator<Int>>;
  total_revenue: () => Promise<AsyncIterator<Int>>;
  total_payment_to_artists: () => Promise<AsyncIterator<Float>>;
  net_revenue: () => Promise<AsyncIterator<Float>>;
}

export interface ProfitPoolFactorSubscriptionPayload {
  mutation: MutationType;
  node: ProfitPoolFactor;
  updatedFields: String[];
  previousValues: ProfitPoolFactorPreviousValues;
}

export interface ProfitPoolFactorSubscriptionPayloadPromise
  extends Promise<ProfitPoolFactorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProfitPoolFactorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProfitPoolFactorPreviousValuesPromise>() => T;
}

export interface ProfitPoolFactorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProfitPoolFactorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProfitPoolFactorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProfitPoolFactorPreviousValuesSubscription>() => T;
}

export interface ProfitPoolFactorPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  overhead: Int;
  monthly_multiplier: Float;
  finder_fee_multiplier: Float;
  profit_pool_option1_variable: Int;
  profit_pool_option1_multiplier: Float;
  profit_pool_option2_variable: Int;
  profit_pool_option2_multiplier: Float;
  profit_pool_percentage: Float;
  manual_change: Int;
}

export interface ProfitPoolFactorPreviousValuesPromise
  extends Promise<ProfitPoolFactorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  overhead: () => Promise<Int>;
  monthly_multiplier: () => Promise<Float>;
  finder_fee_multiplier: () => Promise<Float>;
  profit_pool_option1_variable: () => Promise<Int>;
  profit_pool_option1_multiplier: () => Promise<Float>;
  profit_pool_option2_variable: () => Promise<Int>;
  profit_pool_option2_multiplier: () => Promise<Float>;
  profit_pool_percentage: () => Promise<Float>;
  manual_change: () => Promise<Int>;
}

export interface ProfitPoolFactorPreviousValuesSubscription
  extends Promise<AsyncIterator<ProfitPoolFactorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  overhead: () => Promise<AsyncIterator<Int>>;
  monthly_multiplier: () => Promise<AsyncIterator<Float>>;
  finder_fee_multiplier: () => Promise<AsyncIterator<Float>>;
  profit_pool_option1_variable: () => Promise<AsyncIterator<Int>>;
  profit_pool_option1_multiplier: () => Promise<AsyncIterator<Float>>;
  profit_pool_option2_variable: () => Promise<AsyncIterator<Int>>;
  profit_pool_option2_multiplier: () => Promise<AsyncIterator<Float>>;
  profit_pool_percentage: () => Promise<AsyncIterator<Float>>;
  manual_change: () => Promise<AsyncIterator<Int>>;
}

export interface PromoCodeSubscriptionPayload {
  mutation: MutationType;
  node: PromoCode;
  updatedFields: String[];
  previousValues: PromoCodePreviousValues;
}

export interface PromoCodeSubscriptionPayloadPromise
  extends Promise<PromoCodeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PromoCodePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PromoCodePreviousValuesPromise>() => T;
}

export interface PromoCodeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PromoCodeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PromoCodeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PromoCodePreviousValuesSubscription>() => T;
}

export interface PromoCodePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  promo_code?: String;
  current_promo_code: Boolean;
}

export interface PromoCodePreviousValuesPromise
  extends Promise<PromoCodePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  promo_code: () => Promise<String>;
  current_promo_code: () => Promise<Boolean>;
}

export interface PromoCodePreviousValuesSubscription
  extends Promise<AsyncIterator<PromoCodePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  promo_code: () => Promise<AsyncIterator<String>>;
  current_promo_code: () => Promise<AsyncIterator<Boolean>>;
}

export interface RestoreCodeSubscriptionPayload {
  mutation: MutationType;
  node: RestoreCode;
  updatedFields: String[];
  previousValues: RestoreCodePreviousValues;
}

export interface RestoreCodeSubscriptionPayloadPromise
  extends Promise<RestoreCodeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RestoreCodePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RestoreCodePreviousValuesPromise>() => T;
}

export interface RestoreCodeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RestoreCodeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RestoreCodeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RestoreCodePreviousValuesSubscription>() => T;
}

export interface RestoreCodePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  valid_until: DateTimeOutput;
  code: String;
}

export interface RestoreCodePreviousValuesPromise
  extends Promise<RestoreCodePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  valid_until: () => Promise<DateTimeOutput>;
  code: () => Promise<String>;
}

export interface RestoreCodePreviousValuesSubscription
  extends Promise<AsyncIterator<RestoreCodePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  valid_until: () => Promise<AsyncIterator<DateTimeOutput>>;
  code: () => Promise<AsyncIterator<String>>;
}

export interface SettingsSubscriptionPayload {
  mutation: MutationType;
  node: Settings;
  updatedFields: String[];
  previousValues: SettingsPreviousValues;
}

export interface SettingsSubscriptionPayloadPromise
  extends Promise<SettingsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SettingsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SettingsPreviousValuesPromise>() => T;
}

export interface SettingsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SettingsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SettingsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SettingsPreviousValuesSubscription>() => T;
}

export interface SettingsPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  int_val?: Int;
  str_val?: String;
}

export interface SettingsPreviousValuesPromise
  extends Promise<SettingsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  int_val: () => Promise<Int>;
  str_val: () => Promise<String>;
}

export interface SettingsPreviousValuesSubscription
  extends Promise<AsyncIterator<SettingsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  int_val: () => Promise<AsyncIterator<Int>>;
  str_val: () => Promise<AsyncIterator<String>>;
}

export interface SubscriptionHistorySubscriptionPayload {
  mutation: MutationType;
  node: SubscriptionHistory;
  updatedFields: String[];
  previousValues: SubscriptionHistoryPreviousValues;
}

export interface SubscriptionHistorySubscriptionPayloadPromise
  extends Promise<SubscriptionHistorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubscriptionHistoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubscriptionHistoryPreviousValuesPromise>() => T;
}

export interface SubscriptionHistorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubscriptionHistorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubscriptionHistorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubscriptionHistoryPreviousValuesSubscription>() => T;
}

export interface SubscriptionHistoryPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  interval: String;
  amount: Int;
  subscriptionDate?: DateTimeOutput;
}

export interface SubscriptionHistoryPreviousValuesPromise
  extends Promise<SubscriptionHistoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  interval: () => Promise<String>;
  amount: () => Promise<Int>;
  subscriptionDate: () => Promise<DateTimeOutput>;
}

export interface SubscriptionHistoryPreviousValuesSubscription
  extends Promise<AsyncIterator<SubscriptionHistoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  interval: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Int>>;
  subscriptionDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TagSubscriptionPayload {
  mutation: MutationType;
  node: Tag;
  updatedFields: String[];
  previousValues: TagPreviousValues;
}

export interface TagSubscriptionPayloadPromise
  extends Promise<TagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagPreviousValuesPromise>() => T;
}

export interface TagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagPreviousValuesSubscription>() => T;
}

export interface TagPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  text: String;
}

export interface TagPreviousValuesPromise
  extends Promise<TagPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
}

export interface TagPreviousValuesSubscription
  extends Promise<AsyncIterator<TagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface TotalMinutesForArtistSubscriptionPayload {
  mutation: MutationType;
  node: TotalMinutesForArtist;
  updatedFields: String[];
  previousValues: TotalMinutesForArtistPreviousValues;
}

export interface TotalMinutesForArtistSubscriptionPayloadPromise
  extends Promise<TotalMinutesForArtistSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TotalMinutesForArtistPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TotalMinutesForArtistPreviousValuesPromise>() => T;
}

export interface TotalMinutesForArtistSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TotalMinutesForArtistSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TotalMinutesForArtistSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TotalMinutesForArtistPreviousValuesSubscription>() => T;
}

export interface TotalMinutesForArtistPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  year: Int;
  month: Int;
  minutes_as_owner1: Float;
  minutes_as_owner2: Float;
  minutes_as_owner3: Float;
  total_minutes: Float;
  artist_rating_factor: Float;
  final_minutes: Float;
  percent_of_profit_pool: Float;
  monthly_quantity: Int;
  annual_quantity: Int;
  finder_fee: Int;
  payment_from_profit_pool: Float;
  total_payment: Float;
}

export interface TotalMinutesForArtistPreviousValuesPromise
  extends Promise<TotalMinutesForArtistPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  year: () => Promise<Int>;
  month: () => Promise<Int>;
  minutes_as_owner1: () => Promise<Float>;
  minutes_as_owner2: () => Promise<Float>;
  minutes_as_owner3: () => Promise<Float>;
  total_minutes: () => Promise<Float>;
  artist_rating_factor: () => Promise<Float>;
  final_minutes: () => Promise<Float>;
  percent_of_profit_pool: () => Promise<Float>;
  monthly_quantity: () => Promise<Int>;
  annual_quantity: () => Promise<Int>;
  finder_fee: () => Promise<Int>;
  payment_from_profit_pool: () => Promise<Float>;
  total_payment: () => Promise<Float>;
}

export interface TotalMinutesForArtistPreviousValuesSubscription
  extends Promise<AsyncIterator<TotalMinutesForArtistPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  year: () => Promise<AsyncIterator<Int>>;
  month: () => Promise<AsyncIterator<Int>>;
  minutes_as_owner1: () => Promise<AsyncIterator<Float>>;
  minutes_as_owner2: () => Promise<AsyncIterator<Float>>;
  minutes_as_owner3: () => Promise<AsyncIterator<Float>>;
  total_minutes: () => Promise<AsyncIterator<Float>>;
  artist_rating_factor: () => Promise<AsyncIterator<Float>>;
  final_minutes: () => Promise<AsyncIterator<Float>>;
  percent_of_profit_pool: () => Promise<AsyncIterator<Float>>;
  monthly_quantity: () => Promise<AsyncIterator<Int>>;
  annual_quantity: () => Promise<AsyncIterator<Int>>;
  finder_fee: () => Promise<AsyncIterator<Int>>;
  payment_from_profit_pool: () => Promise<AsyncIterator<Float>>;
  total_payment: () => Promise<AsyncIterator<Float>>;
}

export interface TransferPlanSubscriptionPayload {
  mutation: MutationType;
  node: TransferPlan;
  updatedFields: String[];
  previousValues: TransferPlanPreviousValues;
}

export interface TransferPlanSubscriptionPayloadPromise
  extends Promise<TransferPlanSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TransferPlanPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TransferPlanPreviousValuesPromise>() => T;
}

export interface TransferPlanSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TransferPlanSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TransferPlanSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TransferPlanPreviousValuesSubscription>() => T;
}

export interface TransferPlanPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  year: Int;
  month: Int;
  amount: Int;
  ignore_status: Boolean;
  paid_status: Boolean;
  paid_date?: DateTimeOutput;
}

export interface TransferPlanPreviousValuesPromise
  extends Promise<TransferPlanPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  year: () => Promise<Int>;
  month: () => Promise<Int>;
  amount: () => Promise<Int>;
  ignore_status: () => Promise<Boolean>;
  paid_status: () => Promise<Boolean>;
  paid_date: () => Promise<DateTimeOutput>;
}

export interface TransferPlanPreviousValuesSubscription
  extends Promise<AsyncIterator<TransferPlanPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  year: () => Promise<AsyncIterator<Int>>;
  month: () => Promise<AsyncIterator<Int>>;
  amount: () => Promise<AsyncIterator<Int>>;
  ignore_status: () => Promise<AsyncIterator<Boolean>>;
  paid_status: () => Promise<AsyncIterator<Boolean>>;
  paid_date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TransferTransactionSubscriptionPayload {
  mutation: MutationType;
  node: TransferTransaction;
  updatedFields: String[];
  previousValues: TransferTransactionPreviousValues;
}

export interface TransferTransactionSubscriptionPayloadPromise
  extends Promise<TransferTransactionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TransferTransactionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TransferTransactionPreviousValuesPromise>() => T;
}

export interface TransferTransactionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TransferTransactionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TransferTransactionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TransferTransactionPreviousValuesSubscription>() => T;
}

export interface TransferTransactionPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  year: Int;
  month: Int;
  amount: Int;
  paid_status: Boolean;
  paid_date?: DateTimeOutput;
}

export interface TransferTransactionPreviousValuesPromise
  extends Promise<TransferTransactionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  year: () => Promise<Int>;
  month: () => Promise<Int>;
  amount: () => Promise<Int>;
  paid_status: () => Promise<Boolean>;
  paid_date: () => Promise<DateTimeOutput>;
}

export interface TransferTransactionPreviousValuesSubscription
  extends Promise<AsyncIterator<TransferTransactionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  year: () => Promise<AsyncIterator<Int>>;
  month: () => Promise<AsyncIterator<Int>>;
  amount: () => Promise<AsyncIterator<Int>>;
  paid_status: () => Promise<AsyncIterator<Boolean>>;
  paid_date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstname?: String;
  lastname?: String;
  username?: String;
  email: String;
  phone?: String;
  role: UserRole;
  approved?: Boolean;
  password_hash: String;
  password_salt: String;
  avatar?: String;
  background_image?: String;
  about_text?: String;
  payout_amount?: Int;
  payout_months_total?: Int;
  payout_months_left?: Int;
  payout_enabled?: Boolean;
  front_id_scan?: String;
  back_id_scan?: String;
  billing_subscription_active: Boolean;
  stripe_customer_id?: String;
  stripe_subsciption_json?: Json;
  last_login_date?: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstname: () => Promise<String>;
  lastname: () => Promise<String>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  phone: () => Promise<String>;
  role: () => Promise<UserRole>;
  approved: () => Promise<Boolean>;
  password_hash: () => Promise<String>;
  password_salt: () => Promise<String>;
  avatar: () => Promise<String>;
  background_image: () => Promise<String>;
  about_text: () => Promise<String>;
  payout_amount: () => Promise<Int>;
  payout_months_total: () => Promise<Int>;
  payout_months_left: () => Promise<Int>;
  payout_enabled: () => Promise<Boolean>;
  front_id_scan: () => Promise<String>;
  back_id_scan: () => Promise<String>;
  billing_subscription_active: () => Promise<Boolean>;
  stripe_customer_id: () => Promise<String>;
  stripe_subsciption_json: () => Promise<Json>;
  last_login_date: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstname: () => Promise<AsyncIterator<String>>;
  lastname: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<UserRole>>;
  approved: () => Promise<AsyncIterator<Boolean>>;
  password_hash: () => Promise<AsyncIterator<String>>;
  password_salt: () => Promise<AsyncIterator<String>>;
  avatar: () => Promise<AsyncIterator<String>>;
  background_image: () => Promise<AsyncIterator<String>>;
  about_text: () => Promise<AsyncIterator<String>>;
  payout_amount: () => Promise<AsyncIterator<Int>>;
  payout_months_total: () => Promise<AsyncIterator<Int>>;
  payout_months_left: () => Promise<AsyncIterator<Int>>;
  payout_enabled: () => Promise<AsyncIterator<Boolean>>;
  front_id_scan: () => Promise<AsyncIterator<String>>;
  back_id_scan: () => Promise<AsyncIterator<String>>;
  billing_subscription_active: () => Promise<AsyncIterator<Boolean>>;
  stripe_customer_id: () => Promise<AsyncIterator<String>>;
  stripe_subsciption_json: () => Promise<AsyncIterator<Json>>;
  last_login_date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface VideoSubscriptionPayload {
  mutation: MutationType;
  node: Video;
  updatedFields: String[];
  previousValues: VideoPreviousValues;
}

export interface VideoSubscriptionPayloadPromise
  extends Promise<VideoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VideoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VideoPreviousValuesPromise>() => T;
}

export interface VideoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VideoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VideoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VideoPreviousValuesSubscription>() => T;
}

export interface VideoPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title?: String;
  description?: String;
  publish_date?: DateTimeOutput;
  file_url?: String;
  video_duration?: Int;
  preview_url?: String;
  preview_video_url?: String;
  preview_video_duration?: String;
  deleted: Boolean;
}

export interface VideoPreviousValuesPromise
  extends Promise<VideoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  publish_date: () => Promise<DateTimeOutput>;
  file_url: () => Promise<String>;
  video_duration: () => Promise<Int>;
  preview_url: () => Promise<String>;
  preview_video_url: () => Promise<String>;
  preview_video_duration: () => Promise<String>;
  deleted: () => Promise<Boolean>;
}

export interface VideoPreviousValuesSubscription
  extends Promise<AsyncIterator<VideoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  publish_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  file_url: () => Promise<AsyncIterator<String>>;
  video_duration: () => Promise<AsyncIterator<Int>>;
  preview_url: () => Promise<AsyncIterator<String>>;
  preview_video_url: () => Promise<AsyncIterator<String>>;
  preview_video_duration: () => Promise<AsyncIterator<String>>;
  deleted: () => Promise<AsyncIterator<Boolean>>;
}

export interface VideoDataForMonthSubscriptionPayload {
  mutation: MutationType;
  node: VideoDataForMonth;
  updatedFields: String[];
  previousValues: VideoDataForMonthPreviousValues;
}

export interface VideoDataForMonthSubscriptionPayloadPromise
  extends Promise<VideoDataForMonthSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VideoDataForMonthPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VideoDataForMonthPreviousValuesPromise>() => T;
}

export interface VideoDataForMonthSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VideoDataForMonthSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VideoDataForMonthSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VideoDataForMonthPreviousValuesSubscription>() => T;
}

export interface VideoDataForMonthPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  year: Int;
  month: Int;
  video_length: Int;
  unique_users: Int;
  real_minutes_watched: Int;
  avg_minutes_watched: Int;
  exponent_applied: Int;
  minutes_after_exponent: Int;
}

export interface VideoDataForMonthPreviousValuesPromise
  extends Promise<VideoDataForMonthPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  year: () => Promise<Int>;
  month: () => Promise<Int>;
  video_length: () => Promise<Int>;
  unique_users: () => Promise<Int>;
  real_minutes_watched: () => Promise<Int>;
  avg_minutes_watched: () => Promise<Int>;
  exponent_applied: () => Promise<Int>;
  minutes_after_exponent: () => Promise<Int>;
}

export interface VideoDataForMonthPreviousValuesSubscription
  extends Promise<AsyncIterator<VideoDataForMonthPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  year: () => Promise<AsyncIterator<Int>>;
  month: () => Promise<AsyncIterator<Int>>;
  video_length: () => Promise<AsyncIterator<Int>>;
  unique_users: () => Promise<AsyncIterator<Int>>;
  real_minutes_watched: () => Promise<AsyncIterator<Int>>;
  avg_minutes_watched: () => Promise<AsyncIterator<Int>>;
  exponent_applied: () => Promise<AsyncIterator<Int>>;
  minutes_after_exponent: () => Promise<AsyncIterator<Int>>;
}

export interface VideoParametersSubscriptionPayload {
  mutation: MutationType;
  node: VideoParameters;
  updatedFields: String[];
  previousValues: VideoParametersPreviousValues;
}

export interface VideoParametersSubscriptionPayloadPromise
  extends Promise<VideoParametersSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VideoParametersPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VideoParametersPreviousValuesPromise>() => T;
}

export interface VideoParametersSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VideoParametersSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VideoParametersSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VideoParametersPreviousValuesSubscription>() => T;
}

export interface VideoParametersPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  owner1_percentage: Int;
  owner2_percentage: Int;
  owner3_percentage: Int;
}

export interface VideoParametersPreviousValuesPromise
  extends Promise<VideoParametersPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  owner1_percentage: () => Promise<Int>;
  owner2_percentage: () => Promise<Int>;
  owner3_percentage: () => Promise<Int>;
}

export interface VideoParametersPreviousValuesSubscription
  extends Promise<AsyncIterator<VideoParametersPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  owner1_percentage: () => Promise<AsyncIterator<Int>>;
  owner2_percentage: () => Promise<AsyncIterator<Int>>;
  owner3_percentage: () => Promise<AsyncIterator<Int>>;
}

export interface VideoParametersForMonthSubscriptionPayload {
  mutation: MutationType;
  node: VideoParametersForMonth;
  updatedFields: String[];
  previousValues: VideoParametersForMonthPreviousValues;
}

export interface VideoParametersForMonthSubscriptionPayloadPromise
  extends Promise<VideoParametersForMonthSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VideoParametersForMonthPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VideoParametersForMonthPreviousValuesPromise>() => T;
}

export interface VideoParametersForMonthSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VideoParametersForMonthSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VideoParametersForMonthSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = VideoParametersForMonthPreviousValuesSubscription
  >() => T;
}

export interface VideoParametersForMonthPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  year: Int;
  month: Int;
  owner1_percentage: Int;
  owner2_percentage: Int;
  owner3_percentage: Int;
  total_minutes: Float;
  owner1_minutes: Float;
  owner2_minutes: Float;
  owner3_minutes: Float;
}

export interface VideoParametersForMonthPreviousValuesPromise
  extends Promise<VideoParametersForMonthPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  year: () => Promise<Int>;
  month: () => Promise<Int>;
  owner1_percentage: () => Promise<Int>;
  owner2_percentage: () => Promise<Int>;
  owner3_percentage: () => Promise<Int>;
  total_minutes: () => Promise<Float>;
  owner1_minutes: () => Promise<Float>;
  owner2_minutes: () => Promise<Float>;
  owner3_minutes: () => Promise<Float>;
}

export interface VideoParametersForMonthPreviousValuesSubscription
  extends Promise<AsyncIterator<VideoParametersForMonthPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  year: () => Promise<AsyncIterator<Int>>;
  month: () => Promise<AsyncIterator<Int>>;
  owner1_percentage: () => Promise<AsyncIterator<Int>>;
  owner2_percentage: () => Promise<AsyncIterator<Int>>;
  owner3_percentage: () => Promise<AsyncIterator<Int>>;
  total_minutes: () => Promise<AsyncIterator<Float>>;
  owner1_minutes: () => Promise<AsyncIterator<Float>>;
  owner2_minutes: () => Promise<AsyncIterator<Float>>;
  owner3_minutes: () => Promise<AsyncIterator<Float>>;
}

export interface VideoTotalParametersSubscriptionPayload {
  mutation: MutationType;
  node: VideoTotalParameters;
  updatedFields: String[];
  previousValues: VideoTotalParametersPreviousValues;
}

export interface VideoTotalParametersSubscriptionPayloadPromise
  extends Promise<VideoTotalParametersSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VideoTotalParametersPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VideoTotalParametersPreviousValuesPromise>() => T;
}

export interface VideoTotalParametersSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VideoTotalParametersSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VideoTotalParametersSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VideoTotalParametersPreviousValuesSubscription>() => T;
}

export interface VideoTotalParametersPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  minutes_watched_multiplier: Float;
  exponent_for_minutes_watched: Float;
  star_rating_multiplier: Float;
  star_rating_on_off: Int;
}

export interface VideoTotalParametersPreviousValuesPromise
  extends Promise<VideoTotalParametersPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  minutes_watched_multiplier: () => Promise<Float>;
  exponent_for_minutes_watched: () => Promise<Float>;
  star_rating_multiplier: () => Promise<Float>;
  star_rating_on_off: () => Promise<Int>;
}

export interface VideoTotalParametersPreviousValuesSubscription
  extends Promise<AsyncIterator<VideoTotalParametersPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  minutes_watched_multiplier: () => Promise<AsyncIterator<Float>>;
  exponent_for_minutes_watched: () => Promise<AsyncIterator<Float>>;
  star_rating_multiplier: () => Promise<AsyncIterator<Float>>;
  star_rating_on_off: () => Promise<AsyncIterator<Int>>;
}

export interface WatchedVideoUserSubscriptionPayload {
  mutation: MutationType;
  node: WatchedVideoUser;
  updatedFields: String[];
  previousValues: WatchedVideoUserPreviousValues;
}

export interface WatchedVideoUserSubscriptionPayloadPromise
  extends Promise<WatchedVideoUserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WatchedVideoUserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WatchedVideoUserPreviousValuesPromise>() => T;
}

export interface WatchedVideoUserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WatchedVideoUserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WatchedVideoUserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WatchedVideoUserPreviousValuesSubscription>() => T;
}

export interface WatchedVideoUserPreviousValues {
  id: ID_Output;
  watched_seconds: Int;
}

export interface WatchedVideoUserPreviousValuesPromise
  extends Promise<WatchedVideoUserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  watched_seconds: () => Promise<Int>;
}

export interface WatchedVideoUserPreviousValuesSubscription
  extends Promise<AsyncIterator<WatchedVideoUserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  watched_seconds: () => Promise<AsyncIterator<Int>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Json = any;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "PromoCode",
    embedded: false
  },
  {
    name: "TransferPlan",
    embedded: false
  },
  {
    name: "TransferTransaction",
    embedded: false
  },
  {
    name: "Settings",
    embedded: false
  },
  {
    name: "ActivationCode",
    embedded: false
  },
  {
    name: "RestoreCode",
    embedded: false
  },
  {
    name: "UserRole",
    embedded: false
  },
  {
    name: "Video",
    embedded: false
  },
  {
    name: "WatchedVideoUser",
    embedded: false
  },
  {
    name: "Tag",
    embedded: false
  },
  {
    name: "Category",
    embedded: false
  },
  {
    name: "Post",
    embedded: false
  },
  {
    name: "Curriculum",
    embedded: false
  },
  {
    name: "PlayHistory",
    embedded: false
  },
  {
    name: "ChargeHistory",
    embedded: false
  },
  {
    name: "SubscriptionHistory",
    embedded: false
  },
  {
    name: "ArtistFactorsSetting",
    embedded: false
  },
  {
    name: "ArtistFactors",
    embedded: false
  },
  {
    name: "VideoTotalParameters",
    embedded: false
  },
  {
    name: "ProfitPoolFactor",
    embedded: false
  },
  {
    name: "VideoDataForMonth",
    embedded: false
  },
  {
    name: "VideoParameters",
    embedded: false
  },
  {
    name: "VideoParametersForMonth",
    embedded: false
  },
  {
    name: "TotalMinutesForArtist",
    embedded: false
  },
  {
    name: "ProfitPoolCalculation",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
